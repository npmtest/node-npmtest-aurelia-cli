{"/home/travis/build/npmtest/node-npmtest-aurelia-cli/test.js":"/* istanbul instrument in package npmtest_aurelia_cli */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-aurelia-cli/lib.npmtest_aurelia_cli.js":"/* istanbul instrument in package npmtest_aurelia_cli */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_aurelia_cli = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_aurelia_cli = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-aurelia-cli/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-aurelia-cli && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_aurelia_cli */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_aurelia_cli\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_aurelia_cli.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_aurelia_cli.rollup.js'] =\n            local.assetsDict['/assets.npmtest_aurelia_cli.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_aurelia_cli.__dirname + '/lib.npmtest_aurelia_cli.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-aurelia-cli/node_modules/aurelia-cli/lib/index.js":"require('aurelia-polyfills');\n\nexports.CLI = require('./cli').CLI;\nexports.CLIOptions = require('./cli-options').CLIOptions;\nexports.UI = require('./ui').UI;\nexports.Project = require('./project').Project;\nexports.ProjectItem = require('./project-item').ProjectItem;\nexports.build = require('./build');\n","/home/travis/build/npmtest/node-npmtest-aurelia-cli/node_modules/aurelia-cli/lib/cli.js":"'use strict';\nconst path = require('path');\nconst Container = require('aurelia-dependency-injection').Container;\nconst fs = require('./file-system');\nconst ui = require('./ui');\nconst Project = require('./project').Project;\nconst CLIOptions = require('./cli-options').CLIOptions;\nconst LogManager = require('aurelia-logging');\nconst Logger = require('./logger').Logger;\n\nexports.CLI = class {\n  constructor(options) {\n    this.options = options || new CLIOptions();\n    this.container = new Container();\n    this.ui = new ui.ConsoleUI(this.options);\n    this.configureContainer();\n  }\n\n  run(cmd, args) {\n    if (cmd === '--version' || cmd === '-v') {\n      return this.ui.log(require('../package.json').version);\n    }\n\n    return this._establishProject(this.options)\n      .then(project => {\n        if (project) {\n          this.project = project;\n          this.container.registerInstance(Project, project);\n        }\n\n        return this.createCommand(cmd, args);\n      })\n      .then((command) => {\n        this.configureLogger();\n\n        return command.execute(args);\n      });\n  }\n\n  configureLogger() {\n    LogManager.addAppender(this.container.get(Logger));\n    let level = CLIOptions.hasFlag('debug') ? LogManager.logLevel.debug : LogManager.logLevel.info;\n    LogManager.setLevel(level);\n  }\n\n  configureContainer() {\n    this.container.registerInstance(CLIOptions, this.options);\n    this.container.registerInstance(ui.UI, this.ui);\n  }\n\n  createCommand(commandText, commandArgs) {\n    return new Promise((resolve, reject) => {\n      if (!commandText) {\n        resolve(this.createHelpCommand());\n        return;\n      }\n\n      let parts = commandText.split(':');\n      let commandModule = parts[0];\n      let commandName = parts[1] || 'default';\n\n      try {\n        let alias = require('./commands/alias.json')[commandModule];\n        let found = this.container.get(require(`./commands/${alias || commandModule}/command`));\n        Object.assign(this.options, { args: commandArgs });\n        resolve(found);\n      } catch (e) {\n        if (this.project) {\n          this.project.resolveTask(commandModule).then(taskPath => {\n            if (taskPath) {\n              Object.assign(this.options, {\n                taskPath: taskPath,\n                args: commandArgs,\n                commandName: commandName\n              });\n\n              resolve(this.container.get(require('./commands/gulp')));\n            } else {\n              this.ui.log(`Invalid Command: ${commandText}`);\n              resolve(this.createHelpCommand());\n            }\n          });\n        } else {\n          this.ui.log(`Invalid Command: ${commandText}`);\n          resolve(this.createHelpCommand());\n        }\n      }\n    });\n  }\n\n  createHelpCommand() {\n    return this.container.get(require('./commands/help/command'));\n  }\n\n  _establishProject(options) {\n    if (!options.runningLocally) {\n      return Promise.resolve();\n    }\n\n    return determineWorkingDirectory(process.cwd())\n      .then(dir => dir ? Project.establish(this.ui, dir) : this.ui.log('No Aurelia project found.'));\n  }\n};\n\nfunction determineWorkingDirectory(dir) {\n  let parent = path.join(dir, '..');\n\n  if (parent === dir) {\n    return;\n  }\n\n  return fs.stat(path.join(dir, 'aurelia_project'))\n    .then(() => dir)\n    .catch(() => determineWorkingDirectory(parent));\n}\n\nprocess.on('unhandledRejection', (reason) => {\n  console.log('Uncaught promise rejection:');\n  console.log(reason);\n});\n","/home/travis/build/npmtest/node-npmtest-aurelia-cli/node_modules/aurelia-cli/lib/file-system.js":"'use strict';\nconst fs = require('fs');\nconst nodePath = require('path');\nconst mkdirp = require('./mkdirp').mkdirp;\n\nexports.fs = fs;\n\n/**\n * @deprecated\n *  fs.exists() is deprecated.\n *  See https://nodejs.org/api/fs.html#fs_fs_exists_path_callback.\n *  Functions using it can also not be properly tested.\n */\nexports.exists = function(path) {\n  return new Promise((resolve, reject) => fs.exists(path, resolve));\n};\n\nexports.stat = function(path) {\n  return new Promise((resolve, reject) => {\n    fs.stat(path, (error, stats) => {\n      if (error) reject(error);\n      else resolve(stats);\n    });\n  });\n};\n\nexports.existsSync = function(path) {\n  return fs.existsSync(path);\n};\n\nexports.mkdir = function(path) {\n  return new Promise((resolve, reject) => {\n    fs.mkdir(path, (error, result) => {\n      if (error) reject(error);\n      else resolve();\n    });\n  });\n};\n\nexports.mkdirp = function(path) {\n  return new Promise((resolve, reject) => {\n    mkdirp(path, error => {\n      if (error) reject(error);\n      else resolve();\n    });\n  });\n};\n\nexports.readdir = function(path) {\n  return new Promise((resolve, reject) => {\n    fs.readdir(path, (error, files) => {\n      if (error) reject(error);\n      else resolve(files);\n    });\n  });\n};\n\nexports.readdirSync = function(path) {\n  return fs.readdirSync(path);\n};\n\nexports.readFile = function(path, encoding) {\n  return new Promise((resolve, reject) => {\n    fs.readFile(path, encoding || 'utf8', (error, data) => {\n      if (error) reject(error);\n      else resolve(data);\n    });\n  });\n};\n\nexports.readFileSync = fs.readFileSync;\n\nexports.readFileSync = function(path, encoding) {\n  return fs.readFileSync(path, encoding || 'utf8');\n};\n\nexports.copySync = function(sourceFile, targetFile) {\n  fs.writeFileSync(targetFile, fs.readFileSync(sourceFile));\n};\n\nexports.resolve = function(path) {\n  return nodePath.resolve(path);\n};\n\nexports.join = function() {\n  return nodePath.join.apply(this, Array.prototype.slice.call(arguments));\n};\n\nexports.statSync = function(path) {\n  return fs.statSync(path);\n};\n\nexports.writeFile = function(path, content, encoding) {\n  return new Promise((resolve, reject) => {\n    mkdirp(nodePath.dirname(path), err => {\n      if (err) reject(err);\n      else {\n        fs.writeFile(path, content, encoding || 'utf8', error => {\n          if (error) reject(error);\n          else resolve();\n        });\n      }\n    });\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-aurelia-cli/node_modules/aurelia-cli/lib/mkdirp.js":"'use strict';\nconst path = require('path');\nconst fs = require('fs');\nconst _0777 = parseInt('0777', 8);\n\nfunction mkdirp(p, opts, f, made) {\n  if (typeof opts === 'function') {\n    f = opts;\n    opts = {};\n  } else if (!opts || typeof opts !== 'object') {\n    opts = { mode: opts };\n  }\n\n  let mode = opts.mode;\n  let xfs = opts.fs || fs;\n\n  if (mode === undefined) {\n    mode = _0777 & (~process.umask());\n  }\n  if (!made) made = null;\n\n  let cb = f || function() {};\n  p = path.resolve(p);\n\n  xfs.mkdir(p, mode, function(er) {\n    if (!er) {\n      made = made || p;\n      return cb(null, made);\n    }\n    switch (er.code) {\n    case 'ENOENT':\n      mkdirp(path.dirname(p), opts, function(err, isMade) {\n        if (err) cb(err, isMade);\n        else mkdirp(p, opts, cb, isMade);\n      });\n      break;\n\n    // In the case of any other error, just see if there's a dir\n    // there already.  If so, then hooray!  If not, then something\n    // is borked.\n    default:\n      xfs.stat(p, function(er2, stat) {\n        // if the stat fails, then that's super weird.\n        // let the original error be the failure reason.\n        if (er2 || !stat.isDirectory()) cb(er, made);\n        else cb(null, made);\n      });\n      break;\n    }\n  });\n}\n\nexports.mkdirp = mkdirp;\n","/home/travis/build/npmtest/node-npmtest-aurelia-cli/node_modules/aurelia-cli/lib/ui.js":"'use strict';\nconst readline = require('readline');\nconst os = require('os');\nconst fs = require('./file-system');\nconst transform = require('./colors/transform');\nconst createLines = require('./string').createLines;\nconst tty = require('tty');\n\nexports.UI = class {};\n\nexports.ConsoleUI = class {\n  constructor(cliOptions) {\n    this.cliOptions = cliOptions;\n  }\n\n  open() {\n    if (this.rl) {\n      return;\n    }\n\n    this.rl = readline.createInterface({\n      input: process.stdin,\n      output: process.stdout\n    });\n  }\n\n  close() {\n    if (this.rl) {\n      this.rl.close();\n      this.rl = null;\n    }\n  }\n\n  log(text) {\n    return new Promise((resolve, reject) => {\n      console.log(text);\n      resolve();\n    });\n  }\n\n  ensureAnswer(answer, question, suggestion) {\n    if (answer) {\n      return Promise.resolve(answer);\n    }\n\n    return this.question(question, suggestion);\n  }\n\n  question(text, optionsOrSuggestion) {\n    return new Promise((resolve, reject) => {\n      if (!optionsOrSuggestion || typeof optionsOrSuggestion === 'string') {\n        this.open();\n\n        let fullText = os.EOL + text + os.EOL + os.EOL;\n\n        if (optionsOrSuggestion) {\n          fullText += '[' + optionsOrSuggestion + ']';\n        }\n\n        this.rl.question(fullText + '> ', answer => {\n          this.close();\n\n          answer = answer || optionsOrSuggestion;\n\n          if (answer) {\n            resolve(answer);\n          } else {\n            return this.question(text, optionsOrSuggestion).then(theAnswer => resolve(theAnswer));\n          }\n        });\n      } else {\n        optionsOrSuggestion = optionsOrSuggestion.filter(x => includeOption(this.cliOptions, x));\n\n        if (optionsOrSuggestion.length === 1) {\n          return resolve(optionsOrSuggestion[0]);\n        }\n\n        let defaultOption = optionsOrSuggestion[0];\n        let fullText = os.EOL + text + os.EOL\n          + createOptionsText(this, optionsOrSuggestion) + os.EOL + '[' + defaultOption.displayName + ']' + '> ';\n\n        this.open();\n        this.rl.question(fullText, answer => {\n          this.close();\n          resolve(interpretAnswer(answer, optionsOrSuggestion));\n        });\n      }\n    });\n  }\n\n  multiselect(question, options) {\n    return new Promise(resolve => {\n      let info = 'Select one or more options separated by spaces';\n      let fullText = os.EOL + question + os.EOL\n          + createOptionsText(this, options, true) + os.EOL + info + os.EOL + '> ';\n\n      this.open();\n      this.rl.question(fullText, answer => {\n        this.close();\n        let answers = answer.split(' ');\n        answers = answers.filter(x => x.length > 0);\n        resolve(interpretAnswers(answers, options));\n      });\n    });\n  }\n\n  getWidth() {\n    return getWindowSize().width;\n  }\n\n  getHeight() {\n    return getWindowSize().height;\n  }\n\n  displayLogo() {\n    this.clearScreen();\n\n    if (this.getWidth() < 50) {\n      return this.log('Aurelia CLI' + os.EOL);\n    }\n\n    let logoLocation = require.resolve('./resources/logo.txt');\n\n    return fs.readFile(logoLocation).then(logo => {\n      console.log(logo.toString());\n    });\n  }\n\n  clearScreen() {\n    //let lines = this.getHeight();\n\n    //for(var i = 0; i < lines; i++) {\n    //  console.log('\\r\\n');\n    //}\n\n    return Promise.resolve();\n  }\n};\n\nfunction includeOption(cliOptions, option) {\n  if (option.disabled) {\n    return false;\n  }\n\n  if (option.flag) {\n    return cliOptions.hasFlag(option.flag);\n  }\n\n  return true;\n}\n\nfunction createOptionsText(ui, options, multi) {\n  let text = os.EOL;\n\n  for (let i = 0; i < options.length; ++i) {\n    text += `${i + 1}. ${options[i].displayName}`;\n\n    if (!multi && i === 0) {\n      text += ' (Default)';\n    }\n\n    text += os.EOL;\n\n    if (options[i].description) {\n      text += createLines(`<dim>${options[i].description}</dim>`, '   ', ui.getWidth());\n      text += os.EOL;\n    }\n  }\n\n  return transform(text);\n}\n\nfunction interpretAnswer(answer, options) {\n  if (!answer) {\n    return options[0];\n  }\n\n  let lowerCasedAnswer = answer.toLowerCase();\n  let found = options.find(x => x.displayName.toLowerCase().startsWith(lowerCasedAnswer));\n\n  if (found) {\n    return found;\n  }\n\n  let num = parseInt(answer, 10);\n  return options[num - 1] || options[0];\n}\n\nfunction interpretAnswers(answers, options) {\n  let foundAnswers = [];\n\n  for (let i = 0; i < answers.length; i++) {\n    let lowerCasedAnswer = answers[i].toLowerCase();\n    let found = options.find(x => x.displayName.toLowerCase().startsWith(lowerCasedAnswer));\n\n    if (found) {\n      foundAnswers.push(found);\n      continue;\n    }\n\n    let num = parseInt(answers[i], 10);\n\n    if (options[num - 1]) {\n      foundAnswers.push(options[num - 1]);\n    }\n  }\n\n  return foundAnswers;\n}\n\nfunction getWindowSize() {\n  let width;\n  let height;\n\n  if (tty.isatty(1) && tty.isatty(2)) {\n    if (process.stdout.getWindowSize) {\n      width = process.stdout.getWindowSize(1)[0];\n      height = process.stdout.getWindowSize(1)[1];\n    } else if (tty.getWindowSize) {\n      width = tty.getWindowSize()[1];\n      height = tty.getWindowSize()[0];\n    } else if (process.stdout.columns && process.stdout.rows) {\n      height = process.stdout.rows;\n      width = process.stdout.columns;\n    }\n  } else {\n    width = 80;\n    height = 100;\n  }\n\n  return {height: height, width: width};\n}\n","/home/travis/build/npmtest/node-npmtest-aurelia-cli/node_modules/aurelia-cli/lib/colors/transform.js":"'use strict';\nconst styles = require('./styles');\nconst supportsColor = require('./supports-colors');\n\nfunction writeStyleOpen(name) {\n  if (!styles[name]) {\n    return `<${name}>`;\n  }\n\n  if (supportsColor) {\n    return styles[name].open;\n  }\n\n  return '';\n}\n\nfunction writeStyleClose(name) {\n  if (!styles[name]) {\n    return `</${name}>`;\n  }\n\n  if (supportsColor) {\n    return styles[name].close;\n  }\n\n  return '';\n}\n\nmodule.exports = function(text) {\n  let final = '';\n  let state = 'text';\n  let tagName = '';\n\n  for(let i = 0, ii = text.length; i < ii; ++i) {\n    let current = text[i];\n\n    if (current === '<' && state === 'text') {\n      tagName = '';\n      state = 'start-tag';\n    } else if (current === '>' && (state === 'start-tag' || state === 'end-tag')) {\n      if (state === 'start-tag') {\n        final += writeStyleOpen(tagName);\n      } else {\n        final += writeStyleClose(tagName);\n      }\n\n      state = 'text';\n    } else if (current === '/' && state === 'start-tag') {\n      state = 'end-tag';\n    } else if (state === 'start-tag' || state === 'end-tag') {\n      tagName += current;\n    } else {\n      final += current;\n    }\n  }\n\n  return final;\n}\n","/home/travis/build/npmtest/node-npmtest-aurelia-cli/node_modules/aurelia-cli/lib/colors/styles.js":"/*\nThe MIT License (MIT)\n\nCopyright (c) Sindre Sorhus <sindresorhus@gmail.com> (sindresorhus.com)\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\n*/\n\nvar styles = {};\nmodule['exports'] = styles;\n\nvar codes = {\n  reset: [0, 0],\n\n  bold: [1, 22],\n  dim: [2, 22],\n  italic: [3, 23],\n  underline: [4, 24],\n  inverse: [7, 27],\n  hidden: [8, 28],\n  strikethrough: [9, 29],\n\n  black: [30, 39],\n  red: [31, 39],\n  green: [32, 39],\n  yellow: [33, 39],\n  blue: [34, 39],\n  magenta: [35, 39],\n  cyan: [36, 39],\n  white: [37, 39],\n  gray: [90, 39],\n  grey: [90, 39],\n\n  bgBlack: [40, 49],\n  bgRed: [41, 49],\n  bgGreen: [42, 49],\n  bgYellow: [43, 49],\n  bgBlue: [44, 49],\n  bgMagenta: [45, 49],\n  bgCyan: [46, 49],\n  bgWhite: [47, 49],\n\n  // legacy styles for colors pre v1.0.0\n  blackBG: [40, 49],\n  redBG: [41, 49],\n  greenBG: [42, 49],\n  yellowBG: [43, 49],\n  blueBG: [44, 49],\n  magentaBG: [45, 49],\n  cyanBG: [46, 49],\n  whiteBG: [47, 49]\n\n};\n\nObject.keys(codes).forEach(function (key) {\n  var val = codes[key];\n  var style = styles[key] = [];\n  style.open = '\\u001b[' + val[0] + 'm';\n  style.close = '\\u001b[' + val[1] + 'm';\n});","/home/travis/build/npmtest/node-npmtest-aurelia-cli/node_modules/aurelia-cli/lib/colors/supports-colors.js":"/*\nThe MIT License (MIT)\n\nCopyright (c) Sindre Sorhus <sindresorhus@gmail.com> (sindresorhus.com)\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\n*/\n\nvar argv = process.argv;\n\nmodule.exports = (function () {\n  if (argv.indexOf('--no-color') !== -1 ||\n    argv.indexOf('--color=false') !== -1) {\n    return false;\n  }\n\n  if (argv.indexOf('--color') !== -1 ||\n    argv.indexOf('--color=true') !== -1 ||\n    argv.indexOf('--color=always') !== -1) {\n    return true;\n  }\n\n  if (process.stdout && !process.stdout.isTTY) {\n    return false;\n  }\n\n  if (process.platform === 'win32') {\n    return true;\n  }\n\n  if ('COLORTERM' in process.env) {\n    return true;\n  }\n\n  if (process.env.TERM === 'dumb') {\n    return false;\n  }\n\n  if (/^screen|^xterm|^vt100|color|ansi|cygwin|linux/i.test(process.env.TERM)) {\n    return true;\n  }\n\n  return false;\n})();","/home/travis/build/npmtest/node-npmtest-aurelia-cli/node_modules/aurelia-cli/lib/string.js":"'use strict';\nconst os = require('os');\nconst transform = require('./colors/transform');\n\nexports.sluggify = function(str) {\n  return str.toString().toLowerCase()\n    .replace(/\\s+/g, '-')           // Replace spaces with -\n    .replace(/[^\\w\\-]+/g, '')       // Remove all non-word chars\n    .replace(/\\-\\-+/g, '-')         // Replace multiple - with single -\n    .replace(/^-+/, '')             // Trim - from start of text\n    .replace(/-+$/, '');            // Trim - from end of text\n};\n\nexports.lowerCamelCase = function(str) {\n  return str.charAt(0).toLowerCase() + str.slice(1).replace(/[_.-](\\w|$)/g, (_, x) => x.toUpperCase());\n};\n\nexports.upperCamelCase = function(str) {\n  return str.charAt(0).toUpperCase() + str.slice(1).replace(/[_.-](\\w|$)/g, (_, x) => x.toUpperCase());\n};\n\nexports.buildFromMetadata = function(metadata, width) {\n  let text = '';\n  metadata.forEach(json => text += transformCommandToStyledText(json, width));\n  return text;\n};\n\nexports.createLines = createLines;\n\nfunction transformCommandToStyledText(json, width) {\n  const tabSize = '    ';\n  let currentIndent = tabSize;\n\n  let text = `<magenta><bold>${json.name}</bold></magenta>`;\n  width = width || 1000;\n\n  if (json.parameters) {\n    json.parameters.forEach(parameter => {\n      if (parameter.optional) {\n        text += ' <dim><' + parameter.name + '></dim>';\n      } else {\n        text += ' ' + parameter.name;\n      }\n    });\n  }\n\n  if (json.flags) {\n    json.flags.forEach(flag => {\n      text += ' <yellow>--' + flag.name + '</yellow>';\n\n      if (flag.type !== 'boolean') {\n        text += ' value';\n      }\n    });\n  }\n\n  text += os.EOL + os.EOL;\n  text += createLines(json.description, currentIndent, width);\n\n  if (json.parameters) {\n    json.parameters.forEach(parameter => {\n      text += os.EOL + os.EOL;\n      let parameterInfo = '<blue>' + parameter.name;\n\n      if (parameter.optional) {\n        parameterInfo += ' (optional)';\n      }\n\n      parameterInfo += '</blue> - ' + parameter.description;\n      text += createLines(parameterInfo, currentIndent, width);\n    });\n  }\n\n  if (json.flags) {\n    json.flags.forEach(flag => {\n      text += os.EOL + os.EOL;\n      let flagInfo = '<yellow>--' + flag.name;\n      flagInfo += '</yellow> - ' + flag.description;\n      text += createLines(flagInfo, currentIndent, width);\n    });\n  }\n\n  text += os.EOL + os.EOL;\n\n  return transform(text);\n}\n\nfunction createLines(text, currentIndent, width) {\n  let toAdd = currentIndent + text;\n\n  if (toAdd.length > width) {\n    let parts = text.split(' ');\n    let lines = [];\n    let currentLine = '';\n\n    for (let i = 0, ii = parts.length; i < ii; ++i) {\n      let potential = currentIndent + currentLine + ' ' + parts[i];\n\n      if (potential.length > width) {\n        lines.push(currentIndent + currentLine.trim());\n        currentLine = parts[i];\n      } else {\n        currentLine = currentLine + ' ' + parts[i];\n      }\n    }\n\n    lines.push(currentIndent + currentLine);\n    toAdd = lines.join(os.EOL);\n  }\n\n  return toAdd;\n}\n","/home/travis/build/npmtest/node-npmtest-aurelia-cli/node_modules/aurelia-cli/lib/project.js":"'use strict';\nconst path = require('path');\nconst fs = require('./file-system');\nconst string = require('./string');\nconst ProjectItem = require('./project-item').ProjectItem;\nconst rfc6902 = require('rfc6902');\n\nexports.Project = class {\n  static establish(ui, dir) {\n    process.chdir(dir);\n\n    return fs.readFile(path.join(dir, 'aurelia_project', 'aurelia.json')).then(model => {\n      return fs.readFile(path.join(dir, 'package.json')).then(pack => {\n        return new exports.Project(ui, dir, JSON.parse(model.toString()), JSON.parse(pack.toString()));\n      });\n    });\n  }\n\n  constructor(ui, directory, model, pack) {\n    this.ui = ui;\n    this.directory = directory;\n    this.model = model;\n    this.package = pack;\n    this.taskDirectory = path.join(directory, 'aurelia_project/tasks');\n    this.generatorDirectory = path.join(directory, 'aurelia_project/generators');\n    this.aureliaJSONPath = path.join(directory, 'aurelia_project', 'aurelia.json');\n\n    this.locations = Object.keys(model.paths).map(key => this[key] = ProjectItem.directory(model.paths[key]));\n    this.locations.push(this.generators = ProjectItem.directory('aurelia_project/generators'));\n    this.locations.push(this.tasks = ProjectItem.directory('aurelia_project/tasks'));\n  }\n\n  commitChanges() {\n    return Promise.all(this.locations.map(x => x.create(this.ui, this.directory)));\n  }\n\n  makeFileName(name) {\n    return string.sluggify(name);\n  }\n\n  makeClassName(name) {\n    return string.upperCamelCase(name);\n  }\n\n  makeFunctionName(name) {\n    return string.lowerCamelCase(name);\n  }\n\n  installTranspiler() {\n    switch (this.model.transpiler.id) {\n    case 'babel':\n      installBabel();\n      break;\n    case 'typescript':\n      installTypeScript();\n      break;\n    default:\n      throw new Error(`${this.model.transpiler.displayName} is not a supported transpiler.`);\n    }\n  }\n\n  getExport(m, name) {\n    return name ? m[name] : m.default;\n  }\n\n  getGeneratorMetadata() {\n    return getMetadata(this.generatorDirectory);\n  }\n\n  getTaskMetadata() {\n    return getMetadata(this.taskDirectory);\n  }\n\n  resolveGenerator(name) {\n    let potential = path.join(this.generatorDirectory, `${name}${this.model.transpiler.fileExtension}`);\n    return fs.stat(potential).then(() => potential).catch(() => null);\n  }\n\n  resolveTask(name) {\n    let potential = path.join(this.taskDirectory, `${name}${this.model.transpiler.fileExtension}`);\n    return fs.stat(potential).then(() => potential).catch(() => null);\n  }\n\n  addDependency(bundle, dependency) {\n    if (!bundle.dependencies) {\n      bundle.dependencies = [];\n    }\n\n    bundle.dependencies.push(dependency);\n  }\n\n  addOrReplaceDependency(bundle, dependency) {\n    let name = (dependency.name || dependency);\n    if (this.hasDependency(bundle, name)) {\n      this.replaceDependency(bundle, this.getDependency(bundle, name), dependency);\n    } else {\n      this.addDependency(bundle, dependency);\n    }\n  }\n\n  replaceDependency(bundle, oldDependency, newDependency) {\n    let index = bundle.dependencies.indexOf(oldDependency);\n\n    bundle.dependencies[index] = newDependency;\n  }\n\n  removeDependency(bundle, dependency) {\n    let index = bundle.dependencies.indexOf(dependency);\n\n    bundle.dependencies.splice(index, 1);\n  }\n\n  getDependency(bundle, name) {\n    return (bundle.dependencies || []).find(item => (item.name || item) === name);\n  }\n\n  hasDependency(bundle, name) {\n    return this.getDependency(bundle, name) !== undefined;\n  }\n\n  hasBundle(bundleName) {\n    return this.getBundle(bundleName) !== undefined;\n  }\n\n  getBundle(bundleName) {\n    let bundles = this.model.build.bundles;\n    return bundles.find(item => item.name === bundleName);\n  }\n\n  addBundle(bundle) {\n    let bundles = this.model.build.bundles;\n\n    bundles.push(bundle);\n  }\n\n  removeBundle(bundle) {\n    let bundles = this.model.build.bundles;\n    let index = bundles.indexOf(bundle);\n\n    bundles.splice(index, 1);\n  }\n\n  replaceBundle(oldBundle, newBundle) {\n    let bundles = this.model.build.bundles;\n    let index = bundles.indexOf(oldBundle);\n\n    bundles[index] = newBundle;\n  }\n\n  getDefaultBundle() {\n    let bundles = this.model.build.bundles;\n\n    if (bundles.length === 0) {\n      throw new Error('There are no bundles in aurelia.json. Please create one');\n    }\n\n    return this.getLargestBundle(bundles);\n  }\n\n  getLargestBundle(bundles) {\n    let largest;\n\n    for (let i = 0; i < bundles.length; i++) {\n      if (!largest || (bundles[i].dependencies || []).length > (largest.dependencies || []).length) {\n        largest = bundles[i];\n      }\n    }\n\n    return largest;\n  }\n\n  writeAureliaJSON() {\n    return fs.writeFile(this.aureliaJSONPath, JSON.stringify(this.model, null, 2), 'utf8');\n  }\n\n  applyPatch(instructions) {\n    let result = rfc6902.applyPatch(this.model, instructions);\n    let errors = result.filter(err => err !== null);\n\n    if (errors.length > 0) {\n      throw new Error(`An error occurred while patching aurelia.json.\\nErrors: ${errors}`);\n    }\n  }\n};\n\nfunction getMetadata(dir) {\n  return fs.readdir(dir).then(files => {\n    return Promise.all(\n      files\n        .sort()\n        .map(file => path.join(dir, file))\n        .filter(file => path.extname(file) === '.json')\n        .map(file => fs.readFile(file).then(data => JSON.parse(data.toString())))\n    );\n  });\n}\n\nfunction installBabel() {\n  require('babel-polyfill');\n  require('babel-register')({\n    plugins: [\n      'transform-es2015-modules-commonjs'\n    ],\n    only: /aurelia_project/\n  });\n}\n\nfunction installTypeScript() {\n  let ts = require('typescript');\n\n  let json = require.extensions['.json'];\n  delete require.extensions['.json'];\n\n  require.extensions['.ts'] = function(module, filename) {\n    let source = fs.readFileSync(filename);\n    let result = ts.transpile(source, {\n      module: ts.ModuleKind.CommonJS,\n      declaration: false,\n      noImplicitAny: false,\n      noResolve: true,\n      removeComments: true,\n      noLib: false,\n      emitDecoratorMetadata: true,\n      experimentalDecorators: true\n    });\n\n    return module._compile(result, filename);\n  };\n\n  require.extensions['.json'] = json;\n}\n","/home/travis/build/npmtest/node-npmtest-aurelia-cli/node_modules/aurelia-cli/lib/project-item.js":"'use strict';\nconst path = require('path');\nconst fs = require('./file-system');\nconst locateResource = require('./resources').locateResource;\n\nexports.ProjectItem = class {\n  constructor(name, isDirectory) {\n    this.name = name;\n    this.isDirectory = !!isDirectory;\n    this._fileExistsStrategy = 'replace';\n  }\n\n  get children() {\n    if (!this._children) {\n      this._children = [];\n    }\n\n    return this._children;\n  }\n\n  get transformers() {\n    if (!this._transformers) {\n      this._transformers = [];\n    }\n\n    return this._transformers;\n  }\n\n  skipIfExists() {\n    this._fileExistsStrategy = 'skip';\n    return this;\n  }\n\n  mergeIfExists() {\n    this._fileExistsStrategy = 'merge';\n    return this;\n  }\n\n  askUserIfExists() {\n    this._fileExistsStrategy = 'ask';\n    return this;\n  }\n\n  add() {\n    if (!this.isDirectory) {\n      throw new Error('You cannot add items to a non-directory.');\n    }\n\n    for (let i = 0; i < arguments.length; ++i) {\n      let child = arguments[i];\n\n      if (this.children.indexOf(child) !== -1) {\n        continue;\n      }\n\n      child.parent = this;\n      this.children.push(child);\n    }\n\n    return this;\n  }\n\n  calculateRelativePath(fromLocation) {\n    if (this === fromLocation) {\n      return '';\n    }\n\n    let parentRelativePath = (this.parent && this.parent !== fromLocation)\n      ? this.parent.calculateRelativePath(fromLocation)\n      : '';\n\n    return path.posix.join(parentRelativePath, this.name);\n  }\n\n  setJSONObject(jsonObject) {\n    this.jsonObject = jsonObject;\n    return this;\n  }\n\n  setText(text) {\n    this.text = text;\n    return this;\n  }\n\n  setSourcePath(p) {\n    this.sourcePath = p;\n    return this;\n  }\n\n  transformWith(callback) {\n    this.transformers.push(callback);\n    return this;\n  }\n\n  create(ui, relativeTo) {\n    let fullPath = relativeTo ? path.posix.join(relativeTo, this.name) : this.name;\n\n    if (this.isDirectory) {\n      return fs.stat(fullPath)\n        .then(result => result)\n        .catch(() => fs.mkdir(fullPath))\n        .then(() => Promise.all(this.children.map(child =>\n          child.create(ui, fullPath)\n        )));\n    } else if (this.sourcePath) {\n      return fs.readFile(this.sourcePath).then(data => {\n        return this._write(fullPath, data, ui);\n      });\n    } else if (this.jsonObject) {\n      return this._write(fullPath, JSON.stringify(this.jsonObject, null, 2), ui);\n    } else if (this.text) {\n      return this._write(fullPath, this.text, ui);\n    }\n\n    return Promise.resolve();\n  }\n\n  _write(fullPath, content, ui) {\n    for (let i = 0, ii = this.transformers.length; i < ii; ++i) {\n      content = this.transformers[i](content);\n    }\n\n    return fs.stat(fullPath).then(() => {\n      switch (this._fileExistsStrategy) {\n      case 'skip':\n        return Promise.resolve();\n      case 'merge':\n        if (this.name === 'package.json') {\n          return fs.readFile(fullPath).then(data => {\n            let json = JSON.parse(data.toString());\n            let merged = mergePackageJson(json, this.jsonObject);\n            return fs.writeFile(fullPath, JSON.stringify(merged, null, 2));\n          });\n        }\n        throw new Error(`cannot merge ${this.name}`);\n      case 'ask':\n        let question = `An existing file named '${this.name}' was found. What would you like to do?`;\n        let options = [\n          {\n            displayName: 'Keep It',\n            description: 'Keeps your existing file. You may need to update its contents to work with Aurelia.'\n          },\n          {\n            displayName: 'Replace It',\n            description: 'Replaces the existing file with a new one designed for Aurelia.'\n          }\n        ];\n\n        return ui.question(question, options).then(answer => {\n          if (answer === options[0]) {\n            return Promise.resolve();\n          }\n\n          return fs.writeFile(fullPath, content);\n        });\n      default:\n        return fs.writeFile(fullPath, content);\n      }\n    }).catch(() => fs.writeFile(fullPath, content));\n  }\n\n  static jsonObject(name, jsonObject) {\n    return new exports.ProjectItem(name, false).setJSONObject(jsonObject);\n  }\n\n  static text(name, text) {\n    return new exports.ProjectItem(name, false).setText(text);\n  }\n\n  static resource(name, resourcePath, extensionOrConfig) {\n    if (extensionOrConfig) {\n      if (extensionOrConfig.fileExtension) {\n        extensionOrConfig = extensionOrConfig.fileExtension;\n      }\n\n      name = name.replace('.ext', extensionOrConfig);\n      resourcePath = resourcePath.replace('.ext', extensionOrConfig);\n    }\n\n    return exports.ProjectItem.source(name, locateResource(resourcePath));\n  }\n\n  static source(name, p) {\n    return new exports.ProjectItem(name, false).setSourcePath(p);\n  }\n\n  static file(name) {\n    return new exports.ProjectItem(name, false);\n  }\n\n  static directory(p) {\n    return new exports.ProjectItem(p, true);\n  }\n};\n\nfunction mergePackageJson(existing, update) {\n  mergeDependencies(existing, 'dependencies', update.dependencies);\n  mergeDependencies(existing, 'peerDependencies', update.peerDependencies);\n  mergeDependencies(existing, 'devDependencies', update.devDependencies);\n  return existing;\n}\n\nfunction mergeDependencies(source, prop, update) {\n  let existing = source[prop] || (source[prop] = {});\n\n  for (let key in update) {\n    existing[key] = update[key];\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-aurelia-cli/node_modules/aurelia-cli/lib/resources/index.js":"'use strict';\n\nexports.locateResource = function(path) {\n  try {\n    return require.resolve('./' + path);\n  } catch (e) {\n    console.log(`Error locating resource: ${path}`);\n    console.error(e);\n    throw e;\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-aurelia-cli/node_modules/aurelia-cli/lib/cli-options.js":"'use strict';\n\nexports.CLIOptions = class {\n  constructor() {\n    exports.CLIOptions.instance = this;\n  }\n\n  getEnvironment() {\n    let NODE_ENV;\n    let env = this.getFlagValue('env') || (process.env.NODE_ENV ? NODE_ENV = process.env.NODE_ENV : undefined) || 'dev';\n    if (NODE_ENV) {\n      console.log(`The selected Node Environment (${NODE_ENV}) is not a preconfigured option ('dev', 'stage', and 'prod')`);\n    }\n    return env;\n  }\n\n  hasFlag(name, shortcut) {\n    if (this.args) {\n      let lookup = '--' + name;\n      let found = this.args.indexOf(lookup) !== -1;\n\n      if (found) {\n        return true;\n      }\n\n      lookup = shortcut || ('-' + name[0]);\n      found = this.args.indexOf(lookup) !== -1;\n\n      if (found) {\n        return true;\n      }\n\n      lookup = '-' + name;\n      return this.args.indexOf(lookup) !== -1;\n    }\n\n    return false;\n  }\n\n  getFlagValue(name, shortcut) {\n    if (this.args) {\n      let lookup = '--' + name;\n      let index = this.args.indexOf(lookup);\n\n      if (index !== -1) {\n        return this.args[index + 1] || null;\n      }\n\n      lookup = shortcut || ('-' + name[0]);\n      index = this.args.indexOf(lookup);\n\n      if (index !== -1) {\n        return this.args[index + 1] || null;\n      }\n\n      lookup = '-' + name;\n      index = this.args.indexOf(lookup);\n\n      if (index !== -1) {\n        return this.args[index + 1] || null;\n      }\n\n      return null;\n    }\n\n    return null;\n  }\n\n  static hasFlag(name, shortcut) {\n    return exports.CLIOptions.instance.hasFlag(name, shortcut);\n  }\n\n  static getFlagValue(name, shortcut) {\n    return exports.CLIOptions.instance.getFlagValue(name, shortcut);\n  }\n\n  static getEnvironment() {\n    return exports.CLIOptions.instance.getEnvironment();\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-aurelia-cli/node_modules/aurelia-cli/lib/logger.js":"'use strict';\nconst UI = require('./ui').UI;\n\nexports.Logger = class {\n\n  static inject() { return [UI]; }\n\n  constructor(ui) {\n    this.ui = ui;\n  }\n\n  debug(logger, message) {\n    this.log(logger, 'DEBUG', message, arguments);\n  }\n\n  info(logger, message) {\n    this.log(logger, 'INFO', message, arguments);\n  }\n\n  warn(logger, message) {\n    this.log(logger, 'WARN', message, arguments);\n  }\n\n  error(logger, message) {\n    this.log(logger, 'ERROR', message, arguments);\n  }\n\n  log(logger, level, message, rest) {\n    let msg = `${level} [${logger.id}] ${message}`;\n    let args = Array.prototype.slice.call(rest, 2);\n\n    if (args.length > 0) {\n      msg += ` ${args.map(x => JSON.stringify(x)).join(' ')}`;\n    }\n\n    this.ui.log(msg);\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-aurelia-cli/node_modules/aurelia-cli/lib/build/index.js":"'use strict';\nconst Bundler = require('./bundler').Bundler;\nconst PackageAnalyzer = require('./package-analyzer').PackageAnalyzer;\n\nlet bundler;\nlet project;\nlet isUpdating = false;\nlet through;\n\nexports.src = function(p) {\n  if (bundler) {\n    isUpdating = true;\n    return Promise.resolve(bundler);\n  }\n\n  through = require('through2'); //dep of vinyl-fs\n  project = p;\n  return Bundler.create(project, new PackageAnalyzer(project)).then(b => bundler = b);\n};\n\nexports.createLoaderCode = function(p) {\n  const createLoaderCode = require('./loader').createLoaderCode;\n  project = p || project;\n  return buildLoaderConfig(project)\n      .then(() => {\n        let platform = project.build.targets[0];\n        return createLoaderCode(platform, bundler);\n      });\n};\n\nexports.createLoaderConfig = function(p) {\n  const createLoaderConfig = require('./loader').createLoaderConfig;\n  project = p || project;\n\n  return buildLoaderConfig(project)\n      .then(() => {\n        let platform = project.build.targets[0];\n        return createLoaderConfig(platform, bundler);\n      });\n};\n\nexports.bundle = function() {\n  return through.obj(function(file, encoding, callback) {\n    callback(null, capture(file));\n  });\n};\n\nexports.dest = function() {\n  return bundler.build()\n    .then(() => bundler.write());\n};\n\nfunction buildLoaderConfig(p) {\n  project = p || project;\n  through = require('through2'); //dep of vinyl-fs\n  let configPromise = Promise.resolve();\n\n  if (!bundler) {\n    //If a bundler doesn't exist then chances are we have not run through getting all the files, and therefore the \"bundles\" will not be complete\n    configPromise = configPromise.then(() => {\n      return Bundler.create(project, new PackageAnalyzer(project)).then(b => bundler = b);\n    });\n  }\n\n  return configPromise.then(() => {\n    return bundler.build();\n  });\n}\n\nfunction capture(file) {\n  if (isUpdating) {\n    bundler.updateFile(file);\n  } else {\n    bundler.addFile(file);\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-aurelia-cli/node_modules/aurelia-cli/lib/build/bundler.js":"'use strict';\nconst Bundle = require('./bundle').Bundle;\nconst BundledSource = require('./bundled-source').BundledSource;\nconst CLIOptions = require('../cli-options').CLIOptions;\nconst LoaderPlugin = require('./loader-plugin').LoaderPlugin;\nconst path = require('path');\n\nexports.Bundler = class {\n  constructor(project, packageAnalyzer) {\n    this.project = project;\n    this.packageAnalyzer = packageAnalyzer;\n    this.bundles = [];\n    this.items = [];\n    this.itemLookup = {};\n    this.environment = CLIOptions.getEnvironment();\n\n    let defaultBuildOptions = {\n      minify: 'stage & prod',\n      sourcemaps: 'dev & stage',\n      rev: false\n    };\n\n    this.buildOptions = this.interpretBuildOptions(project.build.options, defaultBuildOptions);\n    this.loaderOptions = project.build.loader;\n\n    this.loaderConfig = {\n      baseUrl: project.paths.root,\n      paths: ensurePathsRelativelyFromRoot(project.paths || {}),\n      packages: [],\n      stubModules: [],\n      shim: {}\n    };\n    Object.assign(this.loaderConfig, this.project.build.loader.config);\n\n    this.loaderOptions.plugins = (this.loaderOptions.plugins || []).map(x => {\n      let plugin = new LoaderPlugin(this, x);\n\n      if (plugin.stub && this.loaderConfig.stubModules.indexOf(plugin.name) === -1) {\n        this.loaderConfig.stubModules.push(plugin.name);\n      }\n\n      return plugin;\n    });\n  }\n\n  static create(project, packageAnalyzer) {\n    let bundler = new exports.Bundler(project, packageAnalyzer);\n\n    return Promise.all(\n      project.build.bundles.map(x => Bundle.create(bundler, x).then(bundle => {\n        bundler.addBundle(bundle);\n      }))\n    ).then(() => bundler);\n  }\n\n  interpretBuildOptions(options, defaultOptions) {\n    let env = this.environment;\n    options = Object.assign({}, defaultOptions, options);\n\n    for (let key in options) {\n      let value = options[key];\n\n      if (typeof value === 'boolean') {\n        continue;\n      } else if (typeof value === 'string') {\n        let parts = value.split('&').map(x => x.trim().toLowerCase());\n        options[key] = parts.indexOf(env) !== -1;\n      } else {\n        options[key] = false;\n      }\n    }\n\n    return options;\n  }\n\n  itemIncludedInBuild(item) {\n    if (typeof item === 'string' || !item.env) {\n      return true;\n    }\n\n    let value = item.env;\n    let parts = value.split('&').map(x => x.trim().toLowerCase());\n\n    return parts.indexOf(this.environment) !== -1;\n  }\n\n  getItemByPath(p) {\n    return this.itemLookup[normalizeKey(p)];\n  }\n\n  // cached traced to feedback to amodro-trace\n  getTraced() {\n    let traced = [];\n    const stubModules = this.loaderConfig.stubModules;\n\n    for (let key in this.itemLookup) {\n      const item = this.itemLookup[key];\n      if (!item.moduleId || !item.deps) continue;\n      // don't put stubbed in cache\n      if (stubModules.indexOf(item.moduleId) >= 0) continue;\n\n      let traceItem = {id: item.moduleId, deps: item.deps};\n\n      if (!item.requiresTransform) {\n        traceItem.contents = item.contents;\n      }\n\n      traced.push(traceItem);\n    }\n\n    return traced;\n  }\n\n  addFile(file, inclusion) {\n    let key =  normalizeKey(file.path);\n    let found = this.itemLookup[key];\n\n    if (!found) {\n      found = new BundledSource(this, file);\n      this.itemLookup[key] = found;\n      this.items.push(found);\n    }\n\n    if (inclusion) {\n      inclusion.addItem(found);\n    } else {\n      subsume(this.bundles, found);\n    }\n\n    return found;\n  }\n\n  updateFile(file, inclusion) {\n    let found = this.itemLookup[normalizeKey(file.path)];\n\n    if (found) {\n      found.update(file);\n    } else {\n      this.addFile(file, inclusion);\n    }\n  }\n\n  addBundle(bundle) {\n    this.bundles.push(bundle);\n  }\n\n  configureDependency(dependency) {\n    return analyzeDependency(this.packageAnalyzer, dependency).then(description => {\n      let loaderConfig = description.loaderConfig;\n\n      if (loaderConfig.main) {\n        this.loaderConfig.packages.push({\n          name: loaderConfig.name,\n          location: loaderConfig.path,\n          main: loaderConfig.main\n        });\n      } else {\n        this.loaderConfig.paths[loaderConfig.name] = loaderConfig.path;\n      }\n\n      if (loaderConfig.deps || loaderConfig.exports) {\n        let shim = this.loaderConfig.shim[loaderConfig.name] = {};\n\n        if (loaderConfig.deps) {\n          shim.deps = loaderConfig.deps;\n        }\n\n        if (loaderConfig.exports) {\n          shim.exports = loaderConfig.exports;\n        }\n      }\n\n      return description;\n    })\n    .catch(e => {\n      console.log(`Unable to analyze ${(dependency.name || dependency)}`);\n      console.log(e);\n      throw e;\n    });\n  }\n\n  build() {\n    let index = -1;\n    let items = this.bundles;\n\n    function doTransform() {\n      index++;\n\n      if (index < items.length) {\n        return items[index].transform().then(doTransform);\n      }\n\n      return Promise.resolve();\n    }\n\n    return doTransform()\n      .then(() => {\n        //Order the bundles so that the bundle containing the config is processed last.\n        let configTargetBundleIndex = this.bundles.findIndex(x => x.config.name === this.loaderOptions.configTarget);\n        this.bundles.splice(this.bundles.length, 0, this.bundles.splice(configTargetBundleIndex, 1)[0]);\n      })\n      .catch(e => {\n        console.log('Failed to do transforms');\n        console.log(e);\n        throw e;\n      });\n  }\n\n  write() {\n    return Promise.all(this.bundles.map(x => x.write(this.project.build.targets[0])));\n  }\n\n  getAllDependencyLocations() {\n    return this.bundles.reduce((a, b) => a.concat(b.getDependencyLocations()), []);\n  }\n};\n\nfunction analyzeDependency(packageAnalyzer, dependency) {\n  if (typeof dependency === 'string') {\n    return packageAnalyzer.analyze(dependency);\n  }\n\n  return packageAnalyzer.reverseEngineer(dependency);\n}\n\nfunction subsume(bundles, item) {\n  for (let i = 0, ii = bundles.length; i < ii; ++i) {\n    if (bundles[i].trySubsume(item)) {\n      return;\n    }\n  }\n}\n\nfunction normalizeKey(p) {\n  return path.normalize(p);\n}\n\nfunction ensurePathsRelativelyFromRoot(p) {\n  let keys = Object.keys(p);\n  let original = JSON.stringify(p, null, 2);\n  let warn = false;\n\n  for (let i = 0; i < keys.length; i++) {\n    let key = keys[i];\n    if (key !== 'root' && p[key].indexOf(p.root + '/') === 0) {\n      warn = true;\n      p[key] = p[key].slice(p.root.length + 1);\n    }\n  }\n\n  if (warn) {\n    console.log('Warning: paths in the \"paths\" object in aurelia.json must be relative from the root path. Change ');\n    console.log(original);\n    console.log('to: ');\n    console.log(JSON.stringify(p, null, 2));\n  }\n\n  return p;\n}\n","/home/travis/build/npmtest/node-npmtest-aurelia-cli/node_modules/aurelia-cli/lib/build/bundle.js":"'use strict';\nconst path = require('path');\nconst os = require('os');\nconst Convert = require('./convert-source-map');\nconst fs = require('../file-system');\nconst SourceInclusion = require('./source-inclusion').SourceInclusion;\nconst DependencyInclusion = require('./dependency-inclusion').DependencyInclusion;\nconst Utils = require('./utils');\n\nexports.Bundle = class {\n  constructor(bundler, config) {\n    this.Minimatch = require('minimatch').Minimatch; //nested dep of vinyl-fs\n    this.bundler = bundler;\n    this.config = config;\n    this.dependencies = [];\n    this.prepend = (config.prepend || []).filter(x => bundler.itemIncludedInBuild(x));\n    this.append = (config.append || []).filter(x => bundler.itemIncludedInBuild(x));\n    this.moduleId = config.name.replace(path.extname(config.name), '');\n    this.hash = '';\n    this.includes = (config.source || []);\n    this.excludes = [];\n    if (this.includes instanceof Array) {\n      this.includes = this.includes.map(x => new SourceInclusion(this, x));\n    } else {\n      this.excludes = (this.includes.exclude || []).map(x => this.createMatcher(x));\n      this.includes = this.includes.include.map(x => new SourceInclusion(this, x));\n    }\n    this.buildOptions = bundler.interpretBuildOptions(config.options, bundler.buildOptions);\n    this.requiresBuild = true;\n    this.fileCache = {};\n  }\n\n  static create(bundler, config) {\n    let bundle = new exports.Bundle(bundler, config);\n    let dependencies = config.dependencies || [];\n    let dependenciesToBuild = dependencies\n        .filter(x => bundler.itemIncludedInBuild(x));\n\n    return Utils.runSequentially(\n        dependenciesToBuild,\n        dep => bundler.configureDependency(dep))\n    .then(descriptions => {\n      return Utils.runSequentially(\n        descriptions,\n        description => bundle.addDependency(description)\n      );\n    })\n    .then(() => bundle);\n  }\n\n  createMatcher(pattern) {\n    return new this.Minimatch(pattern);\n  }\n\n  addDependency(description) {\n    this.dependencies.push(description);\n    let inclusion = new DependencyInclusion(this, description);\n    this.includes.push(inclusion);\n    return inclusion.traceResources();\n  }\n\n  trySubsume(item) {\n    let includes = this.includes;\n\n    for (let i = 0, ii = includes.length; i < ii; ++i) {\n      if (includes[i].trySubsume(item)) {\n        this.requiresBuild = true;\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  transform() {\n    if (this.requiresBuild) {\n      let index = -1;\n      let items = this.includes;\n\n      function doTransform() {\n        index++;\n\n        if (index < items.length) {\n          return items[index].transform().then(doTransform);\n        }\n\n        return Promise.resolve();\n      }\n\n      return doTransform();\n    }\n\n    return Promise.resolve();\n  }\n\n  getDependencyLocations() {\n    return this.includes.filter(inclusion => inclusion.description)\n      .map(inclusion => {\n        let normalizedLocation = path.posix.normalize(inclusion.description.location).replace(/\\\\/g, '\\/');\n        return {\n          location: normalizedLocation,\n          inclusion: inclusion\n        };\n      });\n  }\n\n  getBundledModuleIds() {\n    return unique(this.includes.reduce((a, b) => a.concat(b.getAllModuleIds()), []));\n  }\n\n  getBundledFiles() {\n    return this.includes.reduce((a, b) => a.concat(b.getAllFiles()), []);\n  }\n\n  write(platform) {\n    if (!this.requiresBuild) {\n      return Promise.resolve();\n    }\n\n\n    let work = Promise.resolve();\n    let loaderOptions = this.bundler.loaderOptions;\n    let buildOptions = this.buildOptions;\n    let files = [];\n\n    if (this.prepend.length) {\n      work = work.then(() => addFilesInOrder(this, this.prepend, files));\n    }\n\n    if (loaderOptions.configTarget === this.config.name) {\n      work = work.then(() => {\n        files.push({ contents: '_aureliaConfigureModuleLoader();'});\n      });\n    }\n\n    work = work.then(() => files = files.concat(this.getBundledFiles()));\n\n    if (this.append.length) {\n      work = work.then(() => addFilesInOrder(this, this.append, files));\n    }\n\n    return work.then(() => {\n      const Concat = require('./concat-with-sourcemaps');\n      let concat = new Concat(true, this.config.name, os.EOL);\n      const generateHashedPath = require('./utils').generateHashedPath;\n      const generateHash = require('./utils').generateHash;\n      let needsSourceMap = false;\n\n      for (let i = 0; i < files.length; ++i) {\n        let currentFile = files[i];\n        let sourceMap = buildOptions.sourcemaps ? currentFile.sourceMap : undefined;\n\n        function fileIsDependency(file) {\n          return file\n            && file.path\n            && file.path.indexOf('node_modules') >= 0;\n        }\n\n        function acquireSourceMapForDependency(file) {\n          if (!file || !file.path) {\n            return;\n          }\n\n          let parsedPath = path.parse(file.path);\n\n          let base64SourceMap = Convert.fromSource(file.contents.toString());\n\n          if (base64SourceMap) {\n            return null;\n          }\n\n          let converter;\n\n          try {\n            converter = Convert.fromMapFileSource(file.contents.toString(), parsedPath.dir);\n          } catch (e) {\n            console.log(e);\n            return null;\n          }\n\n          sourceMap = converter\n            ? converter.sourcemap\n            : null;\n\n          if (sourceMap !== null) {\n            // path.posix.relative(from, to) does not work here\n            sourceMap.sourceRoot = parsedPath.dir.substring(process.cwd().length);\n          }\n\n          return sourceMap;\n        }\n\n        if (fileIsDependency(currentFile)) {\n          sourceMap = acquireSourceMapForDependency(currentFile);\n        }\n\n        if (sourceMap) {\n          needsSourceMap = true;\n        }\n\n        concat.add(currentFile.path, currentFile.contents, sourceMap ? JSON.stringify(sourceMap) : undefined);\n      }\n\n      let mapContents;\n      let contents = concat.content;\n      let bundleFileName = this.config.name;\n\n      if (loaderOptions.configTarget === this.config.name) {\n        //Add to the config bundle the loader config. Can't change index.html yet because we haven't generated hashes for all the files\n        concat.add(undefined, this.writeLoaderCode(platform));\n        contents = concat.content;\n\n        if (buildOptions.rev) {\n          //Generate a unique hash based off of the bundle contents\n          //Must generate hash after we write the loader config so that any other bundle changes (hash changes) can cause a new hash for the vendor file\n          this.hash = generateHash(concat.content);\n          bundleFileName = generateHashedPath(this.config.name, this.hash);\n        }\n\n        //Again, in the config setup, we're at the last bundle, and we can modify the index.html correctly now\n        let outputDir = platform.baseUrl || platform.output; //If we have a baseUrl, then the files are served from there, else it's the output\n        if (platform.index) {\n          this.setIndexFileConfigTarget(platform, path.posix.join(outputDir, bundleFileName));\n        }\n      } else if (buildOptions.rev) {\n        //Generate a unique hash based off of the bundle contents\n        //Must generate hash after we write the loader config so that any other bundle changes (hash changes) can cause a new hash for the vendor file\n        this.hash = generateHash(concat.content);\n        bundleFileName = generateHashedPath(this.config.name, this.hash);\n      }\n\n      let mapFileName = bundleFileName + '.map';\n      let mapSourceRoot = path.posix.relative(\n        path.posix.join(process.cwd(), platform.output),\n        process.cwd()\n      );\n\n      console.log(`Writing ${bundleFileName}...`);\n\n      if (buildOptions.minify) {\n        let minificationOptions = { fromString: true };\n\n        if (needsSourceMap) {\n          minificationOptions.inSourceMap = Convert.fromJSON(concat.sourceMap).toObject();\n          minificationOptions.outSourceMap = mapFileName;\n          minificationOptions.sourceRoot = mapSourceRoot;\n        }\n\n        const UglifyJS = require('uglify-js'); //added to user project devDependencies\n        let minificationResult = UglifyJS.minify(String(contents), minificationOptions);\n\n        contents = minificationResult.code;\n        mapContents = needsSourceMap ? Convert.fromJSON(minificationResult.map).toJSON() : undefined;\n      } else if (needsSourceMap) {\n        mapContents = Convert.fromJSON(concat.sourceMap)\n          .setProperty('sourceRoot', mapSourceRoot)\n          .toJSON();\n\n        contents += os.EOL + '//# sourceMappingURL=' + mapFileName;\n      }\n\n      return fs.writeFile(path.posix.join(platform.output, bundleFileName), contents).then(() => {\n        this.requiresBuild = false;\n\n        if (mapContents) {\n          return fs.writeFile(path.posix.join(platform.output, mapFileName), mapContents)\n          .catch(e => {\n            console.log(`Unable to write the sourcemap to ${path.posix.join(platform.output, mapFileName)}`);\n          });\n        }\n      })\n      .catch(e => {\n        console.log(`Unable to write the bundle to ${path.posix.join(platform.output, bundleFileName)}`);\n        console.log(e);\n        throw e;\n      });\n    })\n    .catch(e => {\n      console.log('Failed to write the bundle');\n      console.log(e);\n      throw e;\n    });\n  }\n\n  getFileFromCacheOrLoad(x) {\n    let found = this.fileCache[x];\n    if (found) {\n      return Promise.resolve(found);\n    }\n\n    return fs.readFile(x).then(data => {\n      found = { contents: data.toString() };\n      this.fileCache[x] = found;\n      return found;\n    });\n  }\n\n  writeLoaderCode(platform) {\n    const createLoaderCode = require('./loader').createLoaderCode;\n    let config = createLoaderCode(platform, this.bundler);\n\n    return 'function _aureliaConfigureModuleLoader(){' + config + '}';\n  }\n\n  setIndexFileConfigTarget(platform, location) {\n    //Replace the reference to the vendor bundle in the \"index.html\" file to use the correct build revision file (or remove the build revision hash);\n    const createSrcFileRegex = require('./utils').createSrcFileRegex;\n    let indexLocation = platform.index;\n    try {\n      let indexFile = fs.readFileSync(indexLocation);\n      let outputDir = platform.baseUrl || platform.output; //If we have a baseUrl, then the files are served from there, else it's the output\n      let configMatcher = createSrcFileRegex(outputDir, this.moduleId);\n      if (configMatcher.test(indexFile)) {\n        indexFile = indexFile.replace(configMatcher, 'src=\"$2' + location + '\"');//Replace the old reference to the file with whatever the new one is (preserving any unknown path parts before)\n        fs.writeFile(indexLocation, indexFile);\n      } else {\n        console.log('Error: Unable to update ' + this.moduleId + ' path to ' + location + ', could not find existing reference to replace');\n      }\n    } catch (err) {\n      if (err.code === 'ENOENT') {\n        console.log('Error: No index file found at \"' + indexLocation + '\"');\n      } else {\n        console.log(err);\n      }\n    }\n  }\n};\n\nfunction addFilesInOrder(bundle, paths, files) {\n  let index = -1;\n\n  function addFile() {\n    index++;\n\n    if (index < paths.length) {\n      return bundle.getFileFromCacheOrLoad(paths[index])\n        .then(file => files.push(file))\n        .then(addFile);\n    }\n\n    return Promise.resolve();\n  }\n\n  return addFile();\n}\n\nfunction unique(collection) {\n  let u = {};\n  let a = [];\n\n  for (let i = 0, l = collection.length; i < l; ++i) {\n    if (u.hasOwnProperty(collection[i])) {\n      continue;\n    }\n\n    a.push(collection[i]);\n    u[collection[i]] = 1;\n  }\n\n  return a;\n}\n","/home/travis/build/npmtest/node-npmtest-aurelia-cli/node_modules/aurelia-cli/lib/build/convert-source-map/index.js":"'use strict';\nvar fs = require('fs');\nvar path = require('path');\n\nvar commentRx = /^\\s*\\/(?:\\/|\\*)[@#]\\s+sourceMappingURL=data:(?:application|text)\\/json;(?:charset[:=]\\S+;)?base64,(.*)$/mg;\nvar mapFileCommentRx =\n  //Example (Extra space between slashes added to solve Safari bug. Exclude space in production):\n  //     / /# sourceMappingURL=foo.js.map           /*# sourceMappingURL=foo.js.map */\n  /(?:\\/\\/[@#][ \\t]+sourceMappingURL=([^\\s'\"]+?)[ \\t]*$)|(?:\\/\\*[@#][ \\t]+sourceMappingURL=([^\\*]+?)[ \\t]*(?:\\*\\/){1}[ \\t]*$)/mg\n\nfunction decodeBase64(base64) {\n  return new Buffer(base64, 'base64').toString();\n}\n\nfunction stripComment(sm) {\n  return sm.split(',').pop();\n}\n\nfunction readFromFileMap(sm, dir) {\n  // NOTE: this will only work on the server since it attempts to read the map file\n\n  var r = mapFileCommentRx.exec(sm);\n  mapFileCommentRx.lastIndex = 0;\n\n  // for some odd reason //# .. captures in 1 and /* .. */ in 2\n  var filename = r[1] || r[2];\n  var filepath = path.join(dir, filename);\n\n  try {\n    return fs.readFileSync(filepath, 'utf8');\n  } catch (e) {\n    throw new Error('An error occurred while trying to read the map file at ' + filepath + '\\n' + e);\n  }\n}\n\nfunction Converter (sm, opts) {\n  opts = opts || {};\n\n  if (opts.isFileComment) sm = readFromFileMap(sm, opts.commentFileDir);\n  if (opts.hasComment) sm = stripComment(sm);\n  if (opts.isEncoded) sm = decodeBase64(sm);\n  if (opts.isJSON || opts.isEncoded) sm = JSON.parse(sm);\n\n  this.sourcemap = sm;\n}\n\nfunction convertFromLargeSource(content){\n  var lines = content.split('\\n');\n  var line;\n  // find first line which contains a source map starting at end of content\n  for (var i = lines.length - 1; i > 0; i--) {\n    line = lines[i]\n    if (~line.indexOf('sourceMappingURL=data:')) return exports.fromComment(line);\n  }\n}\n\nConverter.prototype.toJSON = function (space) {\n  return JSON.stringify(this.sourcemap, null, space);\n};\n\nConverter.prototype.toBase64 = function () {\n  var json = this.toJSON();\n  return new Buffer(json).toString('base64');\n};\n\nConverter.prototype.toComment = function (options) {\n  var base64 = this.toBase64();\n  var data = 'sourceMappingURL=data:application/json;base64,' + base64;\n  return options && options.multiline ? '/*# ' + data + ' */' : '//# ' + data;\n};\n\n// returns copy instead of original\nConverter.prototype.toObject = function () {\n  return JSON.parse(this.toJSON());\n};\n\nConverter.prototype.addProperty = function (key, value) {\n  if (this.sourcemap.hasOwnProperty(key)) throw new Error('property %s already exists on the sourcemap, use set property instead');\n  return this.setProperty(key, value);\n};\n\nConverter.prototype.setProperty = function (key, value) {\n  this.sourcemap[key] = value;\n  return this;\n};\n\nConverter.prototype.getProperty = function (key) {\n  return this.sourcemap[key];\n};\n\nexports.fromObject = function (obj) {\n  return new Converter(obj);\n};\n\nexports.fromJSON = function (json) {\n  return new Converter(json, { isJSON: true });\n};\n\nexports.fromBase64 = function (base64) {\n  return new Converter(base64, { isEncoded: true });\n};\n\nexports.fromComment = function (comment) {\n  comment = comment\n    .replace(/^\\/\\*/g, '//')\n    .replace(/\\*\\/$/g, '');\n\n  return new Converter(comment, { isEncoded: true, hasComment: true });\n};\n\nexports.fromMapFileComment = function (comment, dir) {\n  return new Converter(comment, { commentFileDir: dir, isFileComment: true, isJSON: true });\n};\n\n// Finds last sourcemap comment in file or returns null if none was found\nexports.fromSource = function (content, largeSource) {\n  if (largeSource) {\n    var res = convertFromLargeSource(content);\n    return res ? res : null;\n  }\n\n  var m = content.match(commentRx);\n  commentRx.lastIndex = 0;\n  return m ? exports.fromComment(m.pop()) : null;\n};\n\n// Finds last sourcemap comment in file or returns null if none was found\nexports.fromMapFileSource = function (content, dir) {\n  var m = content.match(mapFileCommentRx);\n  mapFileCommentRx.lastIndex = 0;\n  return m ? exports.fromMapFileComment(m.pop(), dir) : null;\n};\n\nexports.removeComments = function (src) {\n  commentRx.lastIndex = 0;\n  return src.replace(commentRx, '');\n};\n\nexports.removeMapFileComments = function (src) {\n  mapFileCommentRx.lastIndex = 0;\n  return src.replace(mapFileCommentRx, '');\n};\n\nexports.generateMapFileComment = function (file, options) {\n  var data = 'sourceMappingURL=' + file;\n  return options && options.multiline ? '/*# ' + data + ' */' : '//# ' + data;\n};\n\nObject.defineProperty(exports, 'commentRegex', {\n  get: function getCommentRegex () {\n    commentRx.lastIndex = 0;\n    return commentRx;\n  }\n});\n\nObject.defineProperty(exports, 'mapFileCommentRegex', {\n  get: function getMapFileCommentRegex () {\n    mapFileCommentRx.lastIndex = 0;\n    return mapFileCommentRx;\n  }\n});\n","/home/travis/build/npmtest/node-npmtest-aurelia-cli/node_modules/aurelia-cli/lib/build/source-inclusion.js":"'use strict';\nconst path = require('path');\nconst mapStream = require('./map-stream');\n\nexports.SourceInclusion = class {\n  constructor(bundle, pattern) {\n    this.bundle = bundle;\n    this.orignalPattern = pattern;\n\n    if (pattern[0] === '[' && pattern[pattern.length - 1] === ']') {\n      this.traceDependencies = false;\n      pattern = pattern.substring(1, pattern.length - 1);\n    } else {\n      this.traceDependencies = true;\n    }\n\n    this.pattern = pattern;\n    this.matcher = this.bundle.createMatcher(pattern);\n\t  this.excludes = this.bundle.excludes;\n    this.items = [];\n  }\n\n  addItem(item) {\n    item.includedBy = this;\n    item.includedIn = this.bundle;\n    this.items.push(item);\n  }\n\n  isExcluded(item) {\n    let found = this.excludes.findIndex(exclusion => {\n      return exclusion.match(item.path);\n    });\n\t  return found > -1;\n  }\n\n  trySubsume(item) {\n    if (this.matcher.match(item.path) && !this.isExcluded(item)) {\n      item.includedBy = this;\n      item.includedIn = this.bundle;\n      this.items.push(item);\n      return true;\n    }\n\n    return false;\n  }\n\n  addAllMatchingResources(loaderConfig) {\n    return new Promise(resolve => {\n      const vfs = require('vinyl-fs');\n\n      let bundler = this.bundle.bundler;\n      let root = path.resolve(bundler.project.paths.root, loaderConfig.path);\n      let pattern = path.resolve(bundler.project.paths.root, this.pattern);\n\n      let subsume = (file, cb) => {\n        let filePath = file.path;\n        let moduleId = path.join(loaderConfig.name, filePath.replace(root, ''));\n        moduleId = moduleId.replace(/\\\\/g, '/');\n        let ext = path.extname(moduleId);\n        moduleId = moduleId.substring(0, moduleId.length - ext.length);\n\n        let bundledSource = bundler.addFile(file, this);\n        bundledSource.moduleId = moduleId;\n\n        cb(null, file);\n      };\n\n      vfs.src(pattern).pipe(mapStream(subsume))\n        .on('error', e => {\n          console.log(`Error while adding all matching resources of pattern \"${this.pattern}\": ${e.message}`);\n        })\n        .on('end', resolve);\n    });\n  }\n\n  transform() {\n    let index = -1;\n    let items = this.items;\n\n    function doTransform() {\n      index++;\n\n      if (index < items.length) {\n        return items[index].transform().then(doTransform);\n      }\n\n      return Promise.resolve();\n    }\n\n    return doTransform();\n  }\n\n  getAllModuleIds() {\n    return this.items.map(x => x.moduleId);\n  }\n\n  getAllFiles() {\n    return this.items;\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-aurelia-cli/node_modules/aurelia-cli/lib/build/map-stream/index.js":"//filter will reemit the data if cb(err,pass) pass is truthy\n\n// reduce is more tricky\n// maybe we want to group the reductions or emit progress updates occasionally\n// the most basic reduce just emits one 'data' event after it has recieved 'end'\n\n\nvar Stream = require('stream').Stream\n\n\n//create an event stream and apply function to each .write\n//emitting each response as data\n//unless it's an empty callback\n\nmodule.exports = function (mapper, opts) {\n\n  var stream = new Stream()\n    , self = this\n    , inputs = 0\n    , outputs = 0\n    , ended = false\n    , paused = false\n    , destroyed = false\n    , lastWritten = 0\n    , inNext = false\n\n  this.opts = opts || {};\n  var errorEventName = this.opts.failures ? 'failure' : 'error';\n\n  // Items that are not ready to be written yet (because they would come out of\n  // order) get stuck in a queue for later.\n  var writeQueue = {}\n\n  stream.writable = true\n  stream.readable = true\n\n  function queueData (data, number) {\n    var nextToWrite = lastWritten + 1\n\n    if (number === nextToWrite) {\n      // If it's next, and its not undefined write it\n      if (data !== undefined) {\n        stream.emit.apply(stream, ['data', data])\n      }\n      lastWritten ++\n      nextToWrite ++\n    } else {\n      // Otherwise queue it for later.\n      writeQueue[number] = data\n    }\n\n    // If the next value is in the queue, write it\n    if (writeQueue.hasOwnProperty(nextToWrite)) {\n      var dataToWrite = writeQueue[nextToWrite]\n      delete writeQueue[nextToWrite]\n      return queueData(dataToWrite, nextToWrite)\n    }\n\n    outputs ++\n    if(inputs === outputs) {\n      if(paused) paused = false, stream.emit('drain') //written all the incoming events\n      if(ended) end()\n    }\n  }\n\n  function next (err, data, number) {\n    if(destroyed) return\n    inNext = true\n\n    if (!err || self.opts.failures) {\n      queueData(data, number)\n    }\n\n    if (err) {\n      stream.emit.apply(stream, [ errorEventName, err ]);\n    }\n\n    inNext = false;\n  }\n\n  // Wrap the mapper function by calling its callback with the order number of\n  // the item in the stream.\n  function wrappedMapper (input, number, callback) {\n    return mapper.call(null, input, function(err, data){\n      callback(err, data, number)\n    })\n  }\n\n  stream.write = function (data) {\n    if(ended) throw new Error('map stream is not writable')\n    inNext = false\n    inputs ++\n\n    try {\n      //catch sync errors and handle them like async errors\n      var written = wrappedMapper(data, inputs, next)\n      paused = (written === false)\n      return !paused\n    } catch (err) {\n      //if the callback has been called syncronously, and the error\n      //has occured in an listener, throw it again.\n      if(inNext)\n        throw err\n      next(err)\n      return !paused\n    }\n  }\n\n  function end (data) {\n    //if end was called with args, write it,\n    ended = true //write will emit 'end' if ended is true\n    stream.writable = false\n    if(data !== undefined) {\n      return queueData(data, inputs)\n    } else if (inputs == outputs) { //wait for processing\n      stream.readable = false, stream.emit('end'), stream.destroy()\n    }\n  }\n\n  stream.end = function (data) {\n    if(ended) return\n    end(data)\n  }\n\n  stream.destroy = function () {\n    ended = destroyed = true\n    stream.writable = stream.readable = paused = false\n    process.nextTick(function () {\n      stream.emit('close')\n    })\n  }\n  stream.pause = function () {\n    paused = true\n  }\n\n  stream.resume = function () {\n    paused = false\n  }\n\n  return stream\n}\n","/home/travis/build/npmtest/node-npmtest-aurelia-cli/node_modules/aurelia-cli/lib/build/dependency-inclusion.js":"'use strict';\nconst path = require('path');\nconst SourceInclusion = require('./source-inclusion').SourceInclusion;\n\nexports.DependencyInclusion = class {\n  constructor(bundle, description) {\n    this.bundle = bundle;\n    this.description = description;\n    this.items = [];\n    this.traceDependencies = true;\n    bundle.bundler.addFile(new DependencyFile(bundle, description), this);\n  }\n\n  traceResources() {\n    let loaderConfig = this.description.loaderConfig;\n    let resources = loaderConfig.resources;\n    let bundle = this.bundle;\n\n    if (resources) {\n      let promises = [];\n\n      resources.forEach(x => {\n        let pattern = path.join(loaderConfig.path, x);\n        let inclusion = new SourceInclusion(bundle, pattern);\n        promises.push(inclusion.addAllMatchingResources(loaderConfig));\n        bundle.includes.push(inclusion);\n      });\n\n      return Promise.all(promises);\n    }\n\n    return Promise.resolve();\n  }\n\n  addItem(item) {\n    item.includedBy = this;\n    item.includedIn = this.bundle;\n    this.items.push(item);\n  }\n\n  trySubsume(item) {\n    return false;\n  }\n\n  transform() {\n    let index = -1;\n    let items = this.items;\n\n    function doTransform() {\n      index++;\n\n      if (index < items.length) {\n        return items[index].transform().then(doTransform);\n      }\n\n      return Promise.resolve();\n    }\n\n    return doTransform();\n  }\n\n  getAllModuleIds() {\n    return this.items.map(x => x.moduleId);\n  }\n\n  getAllFiles() {\n    return this.items;\n  }\n};\n\nclass DependencyFile {\n  constructor(bundle, description) {\n    this.bundle = bundle;\n    this.description = description;\n    this._contents = null;\n    this._path = null;\n  }\n\n  get path() {\n    return this._path || (this._path = this.description.calculateMainPath(this.bundle.bundler.loaderConfig.baseUrl));\n  }\n\n  get contents() {\n    return this._contents || (this._contents = this.description.readMainFileSync(this.bundle.bundler.loaderConfig.baseUrl));\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-aurelia-cli/node_modules/aurelia-cli/lib/build/utils.js":"'use strict';\nconst path = require('path');\nconst crypto = require('crypto');\n\nexports.generateBundleName = function(contents, fileName, rev) {\n  let hash;\n  if (rev === true) {\n    hash = exports.generateHash(new Buffer(contents, 'utf-8'));\n  } else {\n    hash = rev;\n  }\n  return rev ? exports.generateHashedPath(fileName, hash) : fileName;\n};\n\nexports.runSequentially = function(tasks, cb) {\n  let index = -1;\n  let result = [];\n\n  function exec() {\n    index ++;\n\n    if (index < tasks.length) {\n      return cb(tasks[index]).then(r => result.push(r)).then(exec);\n    }\n\n    return Promise.resolve();\n  }\n\n  return exec().then(() => result);\n};\n\nexports.generateHashedPath = function(pth, hash) {\n  if (arguments.length !== 2) {\n    throw new Error('`path` and `hash` required');\n  }\n\n  return modifyFilename(pth, function(filename, ext) {\n    return filename + '-' + hash + ext;\n  });\n};\n\nexports.revertHashedPath = function(pth, hash) {\n  if (arguments.length !== 2) {\n    throw new Error('`path` and `hash` required');\n  }\n\n  return modifyFilename(pth, function(filename, ext) {\n    return filename.replace(new RegExp('-' + hash + '$'), '') + ext;\n  });\n};\n\nexports.generateHash = function(buf) {\n  if (!Buffer.isBuffer(buf)) {\n    throw new TypeError('Expected a buffer');\n  }\n  return crypto.createHash('md5').update(buf).digest('hex').slice(0, 10);\n};\n\nexports.escapeForRegex = function(str) {\n  let matchers = /[|\\\\{}()[\\]^$+*?.]/g;\n  return str.replace(matchers, '\\\\$&');\n};\n\nexports.createSrcFileRegex = function() {\n  let parts = Array.prototype.slice.call(arguments);\n  let regexString = \"\\\\b(?:src=(\\\"|')(.*))(\";\n  for (let i = 0; i < parts.length; i ++) {\n    regexString = regexString + exports.escapeForRegex(parts[i]) + (i < (parts.length - 1) ? '(\\/|\\\\\\\\)' : '');\n  }\n  regexString = regexString + \"(.*?).js)(?:(\\\"|'))\";\n  return new RegExp(regexString);\n};\n\nfunction modifyFilename(pth, modifier) {\n  if (arguments.length !== 2) {\n    throw new Error('`path` and `modifier` required');\n  }\n\n  if (Array.isArray(pth)) {\n    return pth.map(function(el) {\n      return modifyFilename(el, modifier);\n    });\n  }\n\n  let ext = path.extname(pth);\n  return path.posix.join(path.dirname(pth), modifier(path.basename(pth, ext), ext));\n}\n","/home/travis/build/npmtest/node-npmtest-aurelia-cli/node_modules/aurelia-cli/lib/build/bundled-source.js":"'use strict';\nconst path = require('path');\nconst amodroTrace = require('./amodro-trace');\nconst cjsTransform = require('./amodro-trace/read/cjs');\nconst allWriteTransforms = require('./amodro-trace/write/all');\nconst fs = require('../file-system');\n\nexports.BundledSource = class {\n  constructor(bundler, file) {\n    this.bundler = bundler;\n    this.file = file;\n    this.includedIn = null;\n    this.includedBy = null;\n    this.moduleId = null;\n    this._contents = null;\n    this._deps = null;\n    this.requiresTransform = true;\n  }\n\n  get sourceMap() {\n    return this.file.sourceMap;\n  }\n\n  get path() {\n    return this.file.path;\n  }\n\n  set deps(deps) {\n    this._deps = deps || [];\n  }\n\n  get deps() {\n    return this._deps;\n  }\n\n  set contents(value) {\n    this._contents = value;\n  }\n\n  get contents() {\n    return this._contents === null\n      ? (this._contents = this.file.contents.toString())\n      : this._contents;\n  }\n\n  update(file) {\n    this.file = file;\n    this._contents = null;\n    this.requiresTransform = true;\n    this.includedIn.requiresBuild = true;\n  }\n\n  transform() {\n    if (!this.requiresTransform) {\n      return Promise.resolve();\n    }\n\n    let bundler = this.bundler;\n    let loaderConfig = bundler.loaderConfig;\n    let loaderPlugins = bundler.loaderOptions.plugins;\n    let rootDir = process.cwd();\n    let moduleId = this.moduleId || (this.moduleId = this.calculateModuleId(rootDir, loaderConfig));\n    let that = this;\n    let modulePath = this.path;\n\n    console.log(`Tracing ${moduleId}...`);\n\n    for (let i = 0, ii = loaderPlugins.length; i < ii; ++i) {\n      let current = loaderPlugins[i];\n\n      if (current.matches(this.path)) {\n        return current.transform(moduleId, this.path, this.contents).then(contents => {\n          this.contents = contents;\n          this.requiresTransform = false;\n        });\n      }\n    }\n\n    return amodroTrace(\n      {\n        rootDir: rootDir,\n        id: moduleId,\n        traced: bundler.getTraced(),\n        fileExists: function(defaultExists, id, filePath) {\n          // always force amodro to use our fileRead func.\n          // this bypasses amodro bug https://github.com/amodrojs/amodro-trace/issues/6\n          return true;\n        },\n        fileRead: function(defaultRead, id, filePath) {\n          let location = calculateFileName(filePath);\n          let found = bundler.getItemByPath(location);\n\n          if (found) {\n            // ensure to use contents before stub\n            return found.contentsBeforeStub || found.contents;\n          }\n\n          let contents = '';\n\n          try {\n            contents = fs.readFileSync(location).toString();\n\n            bundler.addFile({\n              path: location,\n              contents: contents\n            }, that.getInclusion(location));\n          } catch (e) {\n            console.log(`File not found or not accessible: ${location}. Requested by ${modulePath}`);\n            console.log(e);\n          }\n\n          return contents;\n        },\n        includeContents: true,\n        readTransform: function(id, url, contents) {\n          return cjsTransform(url, contents);\n        },\n        writeTransform: allWriteTransforms({\n          stubModules: loaderConfig.stubModules,\n          wrapShim: loaderConfig.wrapShim\n        })\n      },\n      loaderConfig\n    ).then(traceResult => {\n      let traced = traceResult.traced;\n      let errors = traceResult.errors;\n      let warnings = traceResult.warnings;\n\n      if (errors) {\n        for (let i = 0; i < errors.length; i++) {\n          console.log(`Trace error: ${errors[i]}`);\n        }\n      }\n\n      if (warnings) {\n        for (let i = 0; i < warnings.length; i++) {\n          console.log(`Trace warning: ${warnings[i]}`);\n        }\n      }\n\n      for (let i = 0, ii = traced.length; i < ii; ++i) {\n        let result = traceResult.traced[i];\n        let item = bundler.getItemByPath(result.path);\n\n        if (item) {\n          item.deps = result.deps;\n          if (item.requiresTransform) {\n            if (loaderConfig.stubModules.indexOf(result.id) >= 0) {\n              // retain contents before stub\n              item.contentsBeforeStub = item.contents;\n            }\n            item.contents = result.contents;\n            item.requiresTransform = false;\n            if (!item.moduleId) {\n              item.moduleId = result.id;\n            }\n          }\n        } else if (this.includedBy.traceDependencies) {\n          let newItem = bundler.addFile({\n            path: result.path,\n            contents: result.contents\n          }, this.getInclusion(result.path));\n\n          newItem.deps = result.deps;\n        }\n      }\n    })\n    .catch(e => {\n      console.log('Error occurred while tracing');\n      console.log(e);\n      throw e;\n    });\n  }\n\n  getInclusion(filePath) {\n    let dir = path.dirname(path.posix.normalize(filePath).replace(/\\\\/g, '\\/'));\n    let dependencyLocations = this.bundler.getAllDependencyLocations();\n    let dependencyLocation = dependencyLocations.find(x => dir.indexOf(x.location) === 0);\n\n    if (dependencyLocation) {\n      return dependencyLocation.inclusion;\n    }\n\n    return this.includedBy;\n  }\n\n  calculateModuleId(rootDir, loaderConfig) {\n    if (this.file.description) {\n      return this.file.description.name;\n    }\n\n    let baseUrl = loaderConfig.baseUrl;\n    let modulePath = path.relative(baseUrl, this.path);\n\n    return path.normalize(modulePath.replace(path.extname(modulePath), '')).replace(/\\\\/g, '\\/');\n  }\n};\n\nfunction calculateFileName(filePath) {\n  if (filePath.indexOf('.') === -1) {\n    return filePath + '.js';\n  }\n\n  return filePath;\n}\n","/home/travis/build/npmtest/node-npmtest-aurelia-cli/node_modules/aurelia-cli/lib/build/amodro-trace/index.js":"'use strict';\nvar Prom = require('./lib/prom'),\n    Loader = require('./lib/loader/Loader'),\n    specialDepIds = {\n      require: true,\n      exports: true,\n      module: true\n    };\n\n/**\n * Returns the set of nested dependencies for a given module ID in the options.\n * @param  {Object} options the set of options for trace. Possible options:\n * - rootDir: String. The full path to the root of the project to be scanned.\n *   This is usually the top level directory of the project that is served to\n *   the web, and the reference directory for relative baseUrls in an AMD loader\n *   config.\n * - id: String. the module ID to trace.\n * - findNestedDependencies: Boolean. Defaults to false. Normally require([])\n *   calls inside a define()'d module are not traced, as they are usually meant\n *   to be dynamically loaded dependencies and are not static module\n *   dependencies. However, for some tracing cases it is useful to know these\n *   dynamic dependencies. Setting this option to true will do that. It only\n *   captures require([]) calls that use string literals for dependency IDs. It\n *   cannot trace dependency IDs that are variables for JS expressions.\n * - fileRead: Function. A function that synchronously returns the file contents\n *   for the given file path. Allows overriding where file contents come from,\n *   for instance, building up an in-memory map of file names and contents from\n *   a stream. Arguments passed to this function:\n *   function(defaultReadFunction, moduleName, filePath) {}\n *   Where defaultReadFunction is the default read function used. You can call\n *   it with the filePath to get the contents via the normal file methods this\n *   module uses to get file contents.\n * - fileExists: Function. If fileRead is provided, this function should be\n *   provided too. Determines if a file exists for the mechanism that reads\n *   files. A synchronous Boolean answer is expected. Signature is:\n *   function(defaultExistsFunction, moduleName, filePath) {}\n *   Where defaultExistsFunction is the default exists function used by the\n *   internals of this module.\n * - readTransform: Function. A function that is used to transform the contents\n *   of the modules after the contents are read but before they are parsed for\n *   module APIs. The function will receive these arguments:\n *   function(moduleName, filePath, contents), and should synchronously return a\n *   string that will be used as the contents.\n * - includeContents: Boolean. Set to true if the contents of the modules should\n *   be included in the output. The contents will be the contents after the\n *   readTransform function has run, if it is provided.\n * - writeTransform: Function. When contents are added to the result, run\n *   this function to allow transforming the contents. See the write/\n *   directory for example transforms. Setting this option automatically sets\n *   includeContents to be true.\n * - keepLoader: Boolean. Keep the loader instance and pass it in the return\n *   value. This is useful if transforms that depend on the instance's context\n *   will be used to transform the contents, and where writeTransform is not\n *   the right fit.\n * @param  {Object} loaderConfig the requirejs loader config to use for tracing\n * and finding modules.\n * @return {Object} The trace result.\n */\nmodule.exports = function trace(options, loaderConfig) {\n  return new Prom(function(resolve, reject) {\n    // Validate the options.\n    if (!options.id) {\n      reject(new Error('options must include \"id\" ' +\n                       'to know what module ID to trace'));\n      return;\n    }\n\n    if (options.writeTransform) {\n      options.includeContents = true;\n    }\n\n    var logger = {\n      warnings: [],\n      errors: [],\n      warn: function(msg) {\n        logger.warnings.push(msg);\n      },\n      error: function(msg) {\n        logger.errors.push(msg);\n      }\n    };\n    options.logger = logger;\n\n    var loader = new Loader(options);\n\n    if (loaderConfig) {\n      loader.getContext().configure(loaderConfig);\n    }\n\n    function onOk() {\n      var context = loader.getContext();\n      var traceCache = context._traceCache || {};\n\n      // Pull out the list of IDs for this layer as the return value.\n      var paths = context._layer.buildFilePaths,\n          idMap = context._layer.buildFileToModule;\n\n      var result = paths.map(function(filePath) {\n        var id = idMap[filePath];\n        // If a loader plugin, try to guess the path instead of use the ID as\n        // the filePath.\n        if (id.indexOf('!') !== -1) {\n          var ext, modifiedName, resourcePath,\n              map = context.makeModuleMap(id),\n              name = map.name;\n\n          var lastIndex = name.lastIndexOf('.');\n          if (lastIndex !== -1) {\n            ext = name.substring(lastIndex);\n            modifiedName = name.substring(0, lastIndex);\n            resourcePath = context.nameToUrl(modifiedName, ext, true);\n            if (context.fileExists(id, resourcePath)) {\n              filePath = resourcePath;\n            } else {\n              resourcePath = null;\n            }\n          }\n\n          // Try to find a path that might correspond to the loader plugin by\n          // looking for the following in priority order:\n          // * resourceId[.extension]\n          // * resourceId\n          // * resourceId.pluginId.\n          if (!resourcePath) {\n            resourcePath = context.nameToUrl(name, '', true);\n            if (context.fileExists(id, resourcePath)) {\n              filePath = resourcePath;\n            } else {\n              resourcePath = context.nameToUrl(name, '.' + map.prefix, true);\n              if (context.fileExists(id, resourcePath)) {\n                filePath = resourcePath;\n              } else {\n                filePath = null;\n              }\n            }\n          }\n        }\n\n        var item = {\n          id: id\n        };\n\n        if (filePath) {\n          item.path = filePath;\n        }\n\n        if (options.includeContents && filePath) {\n          var cacheEntry = traceCache[id];\n          if (cacheEntry && cacheEntry.contents) {\n            item.contents = cacheEntry.contents;\n          } else {\n            var contents = context._readTransformedContents[filePath];\n            if (!contents && context.fileExists(id, filePath)) {\n              contents = context.fileRead(id, filePath) || '';\n              if (options.writeTransform) {\n                contents = options\n                           .writeTransform(context, id, filePath, contents);\n              }\n            }\n            if (contents && options.writeTransform) {\n              contents = options.writeTransform(context,\n                                                id,\n                                                filePath,\n                                                contents);\n            }\n\n            item.contents = contents;\n          }\n        }\n\n        if (filePath) {\n          var inlinedIds = context.urlToDefines[filePath];\n          if (inlinedIds) {\n            var otherIds;\n            inlinedIds.forEach(function(inlinedId) {\n              var deps = context.depsForId[inlinedId];\n\n              // Do not include the special dependency IDs, they do not help\n              // in tracing inter-module dependencies, they are meta ones that\n              // are always available.\n              if (deps) {\n                deps = deps.filter(function(dep) {\n                  return !specialDepIds.hasOwnProperty(dep);\n                });\n              }\n\n              if (inlinedId === id) {\n                // Matches main ID for the file, just add to root of the item.\n                if (deps && deps.length) {\n                  item.deps = deps;\n                }\n              } else {\n                // Another ID in the file, add it to \"otherIds\".\n                if (!otherIds) {\n                  otherIds = {};\n                }\n                var idProps = otherIds[inlinedId] = {};\n                if (deps && deps.length) {\n                  idProps.deps = deps;\n                }\n                var inlinedIdDependents = context.dependentsForId[inlinedId];\n                if (inlinedIdDependents) {\n                  idProps.dependents = inlinedIdDependents;\n                }\n              }\n            });\n            if (otherIds) {\n              item.otherIds = otherIds;\n            }\n          }\n        }\n\n        var dependents = context.dependentsForId[id];\n        if (dependents) {\n          item.dependents = dependents;\n        }\n\n        return item;\n      });\n\n      // Clean up resources used by this loader instance.\n      if (!options.keepLoader) {\n        loader.discard();\n        loader = null;\n      }\n\n      var resolved = {\n        traced: result\n      };\n\n      if (loader) {\n        resolved.loader = loader;\n      }\n\n      // Return logger warnings and errors\n      if (logger.warnings.length) {\n        resolved.warnings = logger.warnings;\n      }\n      if (logger.errors.length) {\n        resolved.errors = logger.errors;\n      }\n      // Remove logger as it was added above. longer term, clone the object\n      // to avoid this.\n      delete options.logger;\n\n      // Used for updating tests when structure changes\n      // console.log(JSON.stringify(resolved, null, '  '));\n\n      resolve(resolved);\n    }\n\n    // Inform requirejs that we want this function executed when done.\n    onOk.__requireJsBuild = true;\n\n    loader.require([options.id], onOk, function(err) {\n      loader.discard();\n      reject(err);\n    });\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-aurelia-cli/node_modules/aurelia-cli/lib/build/amodro-trace/lib/prom.js":"'use strict';\nif (typeof Promise !== 'undefined') {\n  module.exports = Promise;\n} else {\n  module.exports = require('./prim');\n}\n","/home/travis/build/npmtest/node-npmtest-aurelia-cli/node_modules/aurelia-cli/lib/build/amodro-trace/lib/loader/Loader.js":"/*jshint evil: true, strict: false */\n/*global requirejs, define */\n// Using sloppy since this uses eval for some code like plugins,\n// which may not be strict mode compliant. So if use strict is used\n// below they will have strict rules applied and may cause an error.\n\nvar fs = require('fs'),\n    lang = require('../lang'),\n    parse = require('../parse'),\n    path = require('path'),\n    exists = fs.existsSync || path.existsSync,\n    nodeRequire = require;\n\neval(fs.readFileSync(path.join(__dirname, 'require.js'), 'utf8'));\n\n// Method to contain eval scope a bit for code evaluations.\nfunction __exec(contents, r, d, c) {\n  /*jshint unused: false */\n  var exports, module,\n      requirejs = r,\n      require = r,\n      define = d;\n  // Used by some loader plugins. Would be good to remove long term.\n  r.nodeRequire = nodeRequire;\n\n  r._readFile = function(path) {\n    return c.fileRead(undefined, path);\n  };\n  r._fileExists = function(path) {\n    return c.fileExists(undefined, path);\n  };\n\n  eval(contents);\n}\n\n// Patch requirejs to work for build purposes.\n(function() {\n  var hasProp = lang.hasProp,\n    falseProp = lang.falseProp,\n    getOwn = lang.getOwn,\n    // Used to strip out use strict from toString()'d functions for the\n    // shim config since they will explicitly want to not be bound by strict,\n    // but some envs, explicitly xpcshell, adds a use strict.\n    useStrictRegExp = /['\"]use strict['\"];/g;\n\n  var layer,\n    pluginBuilderRegExp =\n                    /([\"']?)pluginBuilder([\"']?)\\s*[=\\:]\\s*[\"']([^'\"\\s]+)[\"']/,\n    oldNewContext = requirejs.s.newContext,\n    oldDef = define;\n\n  function frontSlash(filePath) {\n      return filePath.replace(/\\\\/g, '/');\n  }\n\n  function defaultExists(id, filePath) {\n    return exists(filePath) && fs.statSync(filePath).isFile();\n  }\n\n  function defaultRead(context, id, filePath, encoding) {\n    if (lang.hasProp(context._cachedRawText, filePath)) {\n      return context._cachedRawText[filePath];\n    } else {\n      var text = fs.readFileSync(filePath, encoding || 'utf8');\n      context._cachedRawText[filePath] = text;\n      return text;\n    }\n  }\n\n  function makeDefine(context) {\n    // Override define() to catch modules that just define an object, so that\n    // a dummy define call is not put in the build file for them. They do\n    // not end up getting defined via context.execCb, so we need to catch them\n    // at the define call.\n\n    // This function signature does not have to be exact, just match what we\n    // are looking for.\n    var define = function (name) {\n      var layer = context._layer;\n      if (typeof name === 'string') {\n        // Store the defined name related to the URL that loaded it.\n        var loadingUrl =\n                context.currentLoadingUrl[context.currentLoadingUrl.length - 1];\n        if (loadingUrl) {\n          var defines = context.urlToDefines[loadingUrl] ||\n                        (context.urlToDefines[loadingUrl] = []);\n          defines.push(name);\n        }\n\n        if (falseProp(layer.needsDefine, name)) {\n          layer.modulesWithNames[name] = true;\n        }\n      }\n      return oldDef.apply(null, arguments);\n    };\n\n    define.amd = oldDef.amd;\n\n    return define;\n  }\n\n  // Overrides the new context call to add existing tracking features.\n  requirejs.s.newContext = function (name) {\n    var context = oldNewContext(name),\n      oldEnable = context.enable,\n      moduleProto = context.Module.prototype,\n      oldInit = moduleProto.init,\n      oldCallPlugin = moduleProto.callPlugin;\n\n    layer = context._layer = {\n      buildPathMap: {},\n      buildFileToModule: {},\n      buildFilePaths: [],\n      pathAdded: {},\n      modulesWithNames: {},\n      needsDefine: {},\n      existingRequireUrl: '',\n      ignoredUrls: {},\n      context: context\n    };\n\n    context.needFullExec = {};\n    context.fullExec = {};\n    context.plugins = {};\n    context.buildShimExports = {};\n\n    context.currentLoadingUrl = [];\n    context.urlToDefines = {};\n    context.depsForId = {};\n    context.dependentsForId = {};\n\n    // Stored raw text caches, used by browser use.\n    context._cachedRawText = {};\n    // Stored cached file contents for reuse in other layers.\n    context._cachedFileContents = {};\n    // Store which cached files contain a require definition.\n    context._cachedDefinesRequireUrls = {};\n\n    // Stores the _options.readTransform contents for use in top level results.\n    context._readTransformedContents = {};\n\n    // Stores previous trace results for use in this trace.\n    context._traceCache = {};\n\n    // For tracing, do everything sync so that build runs are more reproducible.\n    // Otherwise, async IO could lead to differing results.\n    context.nextTick = function (fn) {\n      fn();\n    };\n\n    context.normalizePath = function(filePath) {\n      var rootDir = context.config._options && context.config._options.rootDir;\n\n      // If path starts with a slash or has a colon in it, then already\n      // considered a full path without needing rootDir.\n      if (rootDir &&\n          filePath.indexOf('/') !== 0 &&\n          filePath.indexOf(':') === -1) {\n        filePath = path.join(rootDir, filePath);\n      }\n      filePath = frontSlash(path.normalize(filePath));\n      return filePath;\n    };\n\n    var oldNameToUrl = context.nameToUrl;\n    context.nameToUrl = function (moduleName, ext, skipExt) {\n      var url = oldNameToUrl.call(context, moduleName, ext, skipExt);\n      return context.normalizePath(url);\n    };\n\n    context._setToolOptions = function(options) {\n      context.config._options = options;\n\n      // Caching function for performance.\n      var contextRead = defaultRead.bind(null, context);\n      if (context.config._options.fileRead) {\n        var optionRead = context.config._options.fileRead;\n        context.fileRead = function(id, filePath, encoding) {\n          return optionRead(contextRead, id, filePath, encoding);\n        };\n\n        var optionExists = context.config._options.fileExists;\n        context.fileExists = function(id, filePath) {\n          return optionExists(defaultExists, id, filePath);\n        };\n      } else {\n        context.fileRead = contextRead;\n        context.fileExists = defaultExists;\n      }\n    };\n\n    // Called by output of the parse() function, when a file does not\n    // explicitly call define, probably just require, but the parse()\n    // function normalizes on define() for dependency mapping and file\n    // ordering works correctly.\n    context.require.needsDefine = function (moduleName) {\n      context._layer.needsDefine[moduleName] = true;\n    };\n\n    context._isSupportedBuildUrl = function (url) {\n      var layer = context._layer;\n      // Ignore URLs with protocols, hosts or question marks, means either\n      // network access is needed to fetch it or it is too dynamic. Note that\n      // on Windows, full paths are used for some urls, which include\n      // the drive, like c:/something, so need to test for something other\n      // than just a colon.\n      if (url.indexOf('://') === -1 && url.indexOf('?') === -1 &&\n          url.indexOf('empty:') !== 0 && url.indexOf('//') !== 0) {\n        return true;\n      } else {\n        if (!layer.ignoredUrls[url]) {\n          if (url.indexOf('empty:') === -1) {\n            var logger = context.config._options.logger;\n            if (logger && logger.warn) {\n              logger.warn('Cannot optimize network URL, skipping: ' + url);\n            }\n          }\n          layer.ignoredUrls[url] = true;\n        }\n        return false;\n      }\n    };\n\n    // Override the shim exports function generator to just\n    // spit out strings that can be used in the stringified\n    // build output.\n    context.makeShimExports = function (value) {\n      var fn;\n      if (context.config.wrapShim) {\n        fn = function () {\n          var str = 'return ';\n          // If specifies an export that is just a global\n          // name, no dot for a `this.` and such, then also\n          // attach to the global, for `var a = {}` files\n          // where the function closure would hide that from\n          // the global object.\n          if (value.exports && value.exports.indexOf('.') === -1) {\n            str += 'root.' + value.exports + ' = ';\n          }\n\n          if (value.init) {\n            str += '(' + value.init.toString()\n                 .replace(useStrictRegExp, '') + '.apply(this, arguments))';\n          }\n          if (value.init && value.exports) {\n            str += ' || ';\n          }\n          if (value.exports) {\n            str += value.exports;\n          }\n          str += ';';\n          return str;\n        };\n      } else {\n        fn = function () {\n          return '(function (global) {\\n' +\n            '  return function () {\\n' +\n            '    var ret, fn;\\n' +\n            (value.init ?\n                ('     fn = ' + value.init.toString()\n                .replace(useStrictRegExp, '') + ';\\n' +\n                '    ret = fn.apply(global, arguments);\\n') : '') +\n            (value.exports ?\n                '    return ret || global.' + value.exports + ';\\n' :\n                '    return ret;\\n') +\n            '  };\\n' +\n            '}(this))';\n        };\n      }\n\n      return fn;\n    };\n\n    context.enable = function (depMap, parent) {\n      var id = depMap.id,\n        parentId = parent && parent.map.id,\n        needFullExec = context.needFullExec,\n        fullExec = context.fullExec,\n        mod = getOwn(context.registry, id);\n\n      if (mod && !mod.defined) {\n        if (parentId && getOwn(needFullExec, parentId)) {\n          needFullExec[id] = depMap;\n        }\n\n      } else if ((getOwn(needFullExec, id) && falseProp(fullExec, id)) ||\n             (parentId && getOwn(needFullExec, parentId) &&\n            falseProp(fullExec, id))) {\n        context.require.undef(id);\n      }\n\n      return oldEnable.apply(context, arguments);\n    };\n\n    // Override load so that the file paths can be collected.\n    context.load = function (moduleName, url) {\n      /*jslint evil: true */\n      var contents, pluginBuilderMatch, builderName,\n        shim, shimExports, traceCacheEntry,\n        currentLoadingUrl = context.currentLoadingUrl;\n\n      // If this module is no longer in the registry, because it was undefined,\n      // then do not bother doing the work.\n      if (falseProp(context.registry, moduleName)) {\n        return;\n      }\n\n      // Given the async nature of the rest of these steps, the full load\n      // may be canceled in the middle of these steps if the module needs to\n      // be undef()'d and re-evaluated in full as a loader plugin dependency.\n      // So need a way to indicate this to the logic below, so it can stop\n      // processing if this specific load was canceled.\n      var loadStatus = {\n        canceled: false\n      };\n      context.registry[moduleName]._loadStatus = loadStatus;\n\n      var layer = context._layer;\n\n      // Do not mark the url as fetched if it is\n      // not an empty: URL, used by the optimizer.\n      // In that case we need to be sure to call\n      // load() for each module that is mapped to\n      // empty: so that dependencies are satisfied\n      // correctly.\n      if (url.indexOf('empty:') === 0) {\n        delete context.urlFetched[url];\n      }\n\n      // Only handle urls that can be inlined, so that means avoiding some\n      // URLs like ones that require network access or may be too dynamic,\n      // like JSONP\n      if (context._isSupportedBuildUrl(url)) {\n\n        // Save the module name to path  and path to module name mappings.\n        layer.buildPathMap[moduleName] = url;\n        layer.buildFileToModule[url] = moduleName;\n\n        if (hasProp(context.plugins, moduleName)) {\n          // plugins need to have their source evaled as-is.\n          context.needFullExec[moduleName] = true;\n        }\n\n        if (hasProp(context._cachedFileContents, url) &&\n            (falseProp(context.needFullExec, moduleName) ||\n            getOwn(context.fullExec, moduleName))) {\n          contents = context._cachedFileContents[url];\n\n          // If it defines require, mark it so it can be hoisted.\n          // Done here and in the else below, before the\n          // else block removes code from the contents.\n          // Related to #263\n          if (!layer.existingRequireUrl &&\n              context._cachedDefinesRequireUrls[url]) {\n            layer.existingRequireUrl = url;\n          }\n        } else {\n          traceCacheEntry = getOwn(context._traceCache, moduleName);\n          if (traceCacheEntry && falseProp(context.needFullExec, moduleName)) {\n            contents = 'define(\"' + moduleName + '\",';\n            if (traceCacheEntry.deps) {\n              contents += '[\"' + traceCacheEntry.deps.join('\",\"') + '\"]';\n            } else {\n              contents += '[]';\n            }\n            contents += ');';\n          } else {\n            // Load the file contents, process for conditionals, then\n            // evaluate it.\n            contents = context.fileRead(moduleName, url);\n\n            if (context.config._options.readTransform) {\n              contents = context.config._options\n                         .readTransform(moduleName, url, contents);\n            }\n\n            if (context.config._options.includeContents) {\n              context._readTransformedContents[url] = contents;\n            }\n\n            // Find out if the file contains a require() definition. Need to\n            // know this so we can inject plugins right after it, but before\n            // they are needed, and to make sure this file is first, so that\n            // define calls work.\n            try {\n              if (!layer.existingRequireUrl &&\n                  parse.definesRequire(url, contents)) {\n                layer.existingRequireUrl = url;\n                context._cachedDefinesRequireUrls[url] = true;\n              }\n            } catch (e1) {\n              throw new Error('Parse error using esprima ' +\n                      'for file: ' + url + '\\n' + e1);\n            }\n\n            if (hasProp(context.plugins, moduleName)) {\n              // This is a loader plugin, check to see if it has a build\n              // extension, otherwise the plugin will act as the plugin\n              // builder too.\n              pluginBuilderMatch = pluginBuilderRegExp.exec(contents);\n              if (pluginBuilderMatch) {\n                // Load the plugin builder for the plugin contents.\n                builderName = context.makeModuleMap(pluginBuilderMatch[3],\n                                  context.makeModuleMap(moduleName),\n                                  null,\n                                  true).id;\n                contents = context.fileRead(builderName,\n                                            context.nameToUrl(builderName));\n              }\n            }\n\n            // Parse out the require and define calls.\n            // Do this even for plugins in case they have their own\n            // dependencies that may be separate to how the pluginBuilder\n            // works.\n            try {\n              if (falseProp(context.needFullExec, moduleName)) {\n                contents = parse(moduleName, url, contents, {\n                  insertNeedsDefine: true,\n                  has: context.config.has,\n                  findNestedDependencies:\n                                context.config._options.findNestedDependencies\n                });\n              }\n            } catch (e2) {\n              throw new Error('Parse error using esprima ' +\n                      'for file: ' + url + '\\n' + e2);\n            }\n          }\n\n          context._cachedFileContents[url] = contents;\n        }\n\n        // Track current URL for loading, so that modules in the URL can be\n        // traced back to the URL. Useful for when there are multiple modules\n        // in a file.\n        currentLoadingUrl.push(url);\n\n        if (contents) {\n          __exec(contents, context.require, makeDefine(context), context);\n        }\n\n        var lastUrl = currentLoadingUrl[currentLoadingUrl.length - 1];\n        if (url === lastUrl) {\n          currentLoadingUrl.pop();\n        } else {\n          // If this is not a match, need to know, likely need to do fixes\n          // somewhere.\n          throw new Error('Unexpected currentLoadingUrl: expected ' + url +\n                          ' but found ' + lastUrl);\n        }\n\n        try {\n          // If have a string shim config, and this is\n          // a fully executed module, try to see if\n          // it created a variable in this eval scope\n          if (getOwn(context.needFullExec, moduleName)) {\n            shim = getOwn(context.config.shim, moduleName);\n            if (shim && shim.exports) {\n              shimExports = __exec(shim.exports,\n                                   context.require,\n                                   makeDefine(context),\n                                   context);\n              if (typeof shimExports !== 'undefined') {\n                context.buildShimExports[moduleName] = shimExports;\n              }\n            }\n          }\n\n          if (loadStatus.canceled) {\n            return;\n          }\n\n          // Need to close out completion of this module\n          // so that listeners will get notified that it is available.\n          context.completeLoad(moduleName);\n        } catch (e) {\n          // Track which module could not complete loading.\n          if (!e.moduleTree) {\n            e.moduleTree = [];\n          }\n          e.moduleTree.push(moduleName);\n\n          if (!e.fileName) {\n            e.fileName = url;\n          }\n\n          var mod = context.registry[moduleName];\n          if (mod) {\n            mod.emit('error', e);\n          } else {\n            var logger = context.config._options.logger;\n            if (logger && logger.error) {\n              logger.error('Error loading: ' + url + ': ' + e);\n            }\n          }\n        }\n      } else {\n        // With unsupported URLs still need to call completeLoad to\n        // finish loading.\n        context.completeLoad(moduleName);\n      }\n    };\n\n    // Marks module has having a name, and optionally executes the\n    // callback, but only if it meets certain criteria.\n    context.execCb = function (name, cb, args, exports) {\n      var layer = context._layer;\n      var buildShimExports = getOwn(layer.context.buildShimExports, name);\n\n      if (buildShimExports) {\n        return buildShimExports;\n      } else if (cb.__requireJsBuild ||\n                 getOwn(layer.context.needFullExec, name)) {\n        return cb.apply(exports, args);\n      }\n      return undefined;\n    };\n\n    // Override undef to set _loadStatus to canceled when undefined.\n    var oldUndef = context.require.undef;\n    context.require.undef = function(id) {\n      var mod = context.registry[id];\n      if (mod && mod._loadStatus) {\n        mod._loadStatus.canceled = true;\n      }\n      return oldUndef.call(context.require, id);\n    };\n\n    moduleProto.init = function (depMaps) {\n      if (context.needFullExec[this.map.id]) {\n        lang.each(depMaps, lang.bind(this, function (depMap) {\n          if (typeof depMap === 'string') {\n            depMap = context.makeModuleMap(depMap,\n                     (this.map.isDefine ? this.map : this.map.parentMap));\n          }\n\n          if (!context.fullExec[depMap.id]) {\n            context.require.undef(depMap.id);\n          }\n        }));\n      }\n\n      return oldInit.apply(this, arguments);\n    };\n\n    moduleProto.callPlugin = function () {\n      var map = this.map,\n        pluginMap = context.makeModuleMap(map.prefix),\n        pluginId = pluginMap.id,\n        pluginMod = getOwn(context.registry, pluginId);\n\n      context.plugins[pluginId] = true;\n      context.needFullExec[pluginId] = map;\n\n      // If the module is not waiting to finish being defined,\n      // undef it and start over, to get full execution.\n      if (falseProp(context.fullExec, pluginId) &&\n          (!pluginMod || pluginMod.defined)) {\n        context.require.undef(pluginMap.id);\n      }\n\n      return oldCallPlugin.apply(this, arguments);\n    };\n\n    return context;\n  };\n\n  if (!requirejs.onResourceLoad) {\n    // Called when execManager runs for a dependency. Used to figure out\n    // what order of execution.\n    requirejs.onResourceLoad = function (context, map, depMaps) {\n      var id = map.id,\n          layer = context._layer,\n          url;\n\n      // A loader plugin resource is dependent on the plugin.\n      if (map.prefix) {\n        var pluginDependents = context.dependentsForId[map.prefix] ||\n                               (context.dependentsForId[map.prefix] = []);\n        if (pluginDependents.indexOf(id) === -1) {\n          pluginDependents.push(id);\n        }\n      }\n\n      var deps = depMaps.map(function(depMap) {\n        var depId = depMap.id;\n        // Track dependents\n        var dependents = context.dependentsForId[depId] ||\n                         (context.dependentsForId[depId] = []);\n        if (dependents.indexOf(id) === -1) {\n          dependents.push(id);\n        }\n\n        return depId;\n      });\n\n      if (deps.length) {\n        context.depsForId[id] = deps;\n      }\n\n      // Fix up any maps that need to be normalized as part of the fullExec\n      // plumbing for plugins to participate in the build.\n      if (context.plugins && lang.hasProp(context.plugins, id)) {\n        lang.eachProp(context.needFullExec, function(value, prop) {\n          // For plugin entries themselves, they do not have a map\n          // value in needFullExec, just a \"true\" entry.\n          if (value !== true && value.prefix === id && value.unnormalized) {\n            var map = context.makeModuleMap(value.originalName,\n                                            value.parentMap);\n            context.needFullExec[map.id] = map;\n          }\n        });\n      }\n\n      // If build needed a full execution, indicate it\n      // has been done now. But only do it if the context is tracking\n      // that. Only valid for the context used in a build, not for\n      // other contexts being run, like for useLib, plain requirejs\n      // use in node/rhino.\n      if (context.needFullExec && getOwn(context.needFullExec, id)) {\n        context.fullExec[id] = map;\n      }\n\n      // A plugin.\n      if (map.prefix) {\n        if (falseProp(layer.pathAdded, id)) {\n          layer.buildFilePaths.push(id);\n          // For plugins the real path is not knowable, use the name\n          // for both module to file and file to module mappings.\n          layer.buildPathMap[id] = id;\n          layer.buildFileToModule[id] = id;\n          layer.modulesWithNames[id] = true;\n          layer.pathAdded[id] = true;\n        }\n      } else if (map.url && context._isSupportedBuildUrl(map.url)) {\n        // If the url has not been added to the layer yet, and it\n        // is from an actual file that was loaded, add it now.\n        url = map.url;\n        if (!layer.pathAdded[url] && getOwn(layer.buildPathMap, id)) {\n          // Remember the list of dependencies for this layer.\n          layer.buildFilePaths.push(url);\n          layer.pathAdded[url] = true;\n        }\n      }\n    };\n  }\n\n  var idCounter = 0;\n\n  function Loader(options) {\n    var id;\n    while (!id) {\n      id = 'context' + (idCounter++);\n      if (hasProp(requirejs.s.contexts, id)) {\n        id = null;\n      }\n    }\n\n    this.id = id;\n    this.require = requirejs.config({\n      context: id,\n      // isBuild is used by loader plugins.\n      isBuild: true,\n      // Legacy setting from r.js, allows text loader plugin to work without\n      // extra config. Can be overridden by consumers via another\n      // config call. Ideally just move this out as something to explicitly\n      // pass in.\n      inlineText: true\n    });\n\n    var context = this.getContext();\n    context._setToolOptions(options || {});\n\n    if (options.traced) {\n      options.traced.forEach(function(traceItem) {\n        context._traceCache[traceItem.id] = traceItem;\n      });\n    }\n  }\n\n  Loader.prototype = {\n    getContext: function() {\n      return requirejs.s.contexts[this.id];\n    },\n    discard: function() {\n      delete requirejs.s.contexts[this.id];\n    }\n  };\n\n  module.exports = Loader;\n}());\n","/home/travis/build/npmtest/node-npmtest-aurelia-cli/node_modules/aurelia-cli/lib/build/amodro-trace/lib/lang.js":"var define = function(fn) { module.exports = fn(); };\n\n/**\n * @license Copyright (c) 2010-2015, The Dojo Foundation All Rights Reserved.\n * Available via the MIT or new BSD license.\n * see: http://github.com/jrburke/requirejs for details\n */\n\n/*jslint plusplus: true */\n/*global define, java */\n\ndefine(function () {\n    'use strict';\n\n    var lang, isJavaObj,\n        hasOwn = Object.prototype.hasOwnProperty;\n\n    function hasProp(obj, prop) {\n        return hasOwn.call(obj, prop);\n    }\n\n    isJavaObj = function () {\n        return false;\n    };\n\n    //Rhino, but not Nashorn (detected by importPackage not existing)\n    //Can have some strange foreign objects.\n    if (typeof java !== 'undefined' && java.lang && java.lang.Object && typeof importPackage !== 'undefined') {\n        isJavaObj = function (obj) {\n            return obj instanceof java.lang.Object;\n        };\n    }\n\n    lang = {\n        // makeJsArrayString added after porting to this project\n        //Converts an JS array of strings to a string representation.\n        //Not using JSON.stringify() for Rhino's sake.\n        makeJsArrayString: function (ary) {\n            return '[\"' + ary.map(function (item) {\n                //Escape any double quotes, backslashes\n                return lang.jsEscape(item);\n            }).join('\",\"') + '\"]';\n        },\n\n        backSlashRegExp: /\\\\/g,\n        ostring: Object.prototype.toString,\n\n        isArray: Array.isArray || function (it) {\n            return lang.ostring.call(it) === \"[object Array]\";\n        },\n\n        isFunction: function(it) {\n            return lang.ostring.call(it) === \"[object Function]\";\n        },\n\n        isRegExp: function(it) {\n            return it && it instanceof RegExp;\n        },\n\n        hasProp: hasProp,\n\n        //returns true if the object does not have an own property prop,\n        //or if it does, it is a falsy value.\n        falseProp: function (obj, prop) {\n            return !hasProp(obj, prop) || !obj[prop];\n        },\n\n        //gets own property value for given prop on object\n        getOwn: function (obj, prop) {\n            return hasProp(obj, prop) && obj[prop];\n        },\n\n        _mixin: function(dest, source, override){\n            var name;\n            for (name in source) {\n                if(source.hasOwnProperty(name) &&\n                    (override || !dest.hasOwnProperty(name))) {\n                    dest[name] = source[name];\n                }\n            }\n\n            return dest; // Object\n        },\n\n        /**\n         * mixin({}, obj1, obj2) is allowed. If the last argument is a boolean,\n         * then the source objects properties are force copied over to dest.\n         */\n        mixin: function(dest){\n            var parameters = Array.prototype.slice.call(arguments),\n                override, i, l;\n\n            if (!dest) { dest = {}; }\n\n            if (parameters.length > 2 && typeof arguments[parameters.length-1] === 'boolean') {\n                override = parameters.pop();\n            }\n\n            for (i = 1, l = parameters.length; i < l; i++) {\n                lang._mixin(dest, parameters[i], override);\n            }\n            return dest; // Object\n        },\n\n        /**\n         * Does a deep mix of source into dest, where source values override\n         * dest values if a winner is needed.\n         * @param  {Object} dest destination object that receives the mixed\n         * values.\n         * @param  {Object} source source object contributing properties to mix\n         * in.\n         * @return {[Object]} returns dest object with the modification.\n         */\n        deepMix: function(dest, source) {\n            lang.eachProp(source, function (value, prop) {\n                if (typeof value === 'object' && value &&\n                    !lang.isArray(value) && !lang.isFunction(value) &&\n                    !(value instanceof RegExp)) {\n\n                    if (!dest[prop]) {\n                        dest[prop] = {};\n                    }\n                    lang.deepMix(dest[prop], value);\n                } else {\n                    dest[prop] = value;\n                }\n            });\n            return dest;\n        },\n\n        /**\n         * Does a type of deep copy. Do not give it anything fancy, best\n         * for basic object copies of objects that also work well as\n         * JSON-serialized things, or has properties pointing to functions.\n         * For non-array/object values, just returns the same object.\n         * @param  {Object} obj      copy properties from this object\n         * @param  {Object} [result] optional result object to use\n         * @return {Object}\n         */\n        deeplikeCopy: function (obj) {\n            var type, result;\n\n            if (lang.isArray(obj)) {\n                result = [];\n                obj.forEach(function(value) {\n                    result.push(lang.deeplikeCopy(value));\n                });\n                return result;\n            }\n\n            type = typeof obj;\n            if (obj === null || obj === undefined || type === 'boolean' ||\n                type === 'string' || type === 'number' || lang.isFunction(obj) ||\n                lang.isRegExp(obj)|| isJavaObj(obj)) {\n                return obj;\n            }\n\n            //Anything else is an object, hopefully.\n            result = {};\n            lang.eachProp(obj, function(value, key) {\n                result[key] = lang.deeplikeCopy(value);\n            });\n            return result;\n        },\n\n        delegate: (function () {\n            // boodman/crockford delegation w/ cornford optimization\n            function TMP() {}\n            return function (obj, props) {\n                TMP.prototype = obj;\n                var tmp = new TMP();\n                TMP.prototype = null;\n                if (props) {\n                    lang.mixin(tmp, props);\n                }\n                return tmp; // Object\n            };\n        }()),\n\n        /**\n         * Helper function for iterating over an array. If the func returns\n         * a true value, it will break out of the loop.\n         */\n        each: function each(ary, func) {\n            if (ary) {\n                var i;\n                for (i = 0; i < ary.length; i += 1) {\n                    if (func(ary[i], i, ary)) {\n                        break;\n                    }\n                }\n            }\n        },\n\n        /**\n         * Cycles over properties in an object and calls a function for each\n         * property value. If the function returns a truthy value, then the\n         * iteration is stopped.\n         */\n        eachProp: function eachProp(obj, func) {\n            var prop;\n            for (prop in obj) {\n                if (hasProp(obj, prop)) {\n                    if (func(obj[prop], prop)) {\n                        break;\n                    }\n                }\n            }\n        },\n\n        //Similar to Function.prototype.bind, but the \"this\" object is specified\n        //first, since it is easier to read/figure out what \"this\" will be.\n        bind: function bind(obj, fn) {\n            return function () {\n                return fn.apply(obj, arguments);\n            };\n        },\n\n        //Escapes a content string to be be a string that has characters escaped\n        //for inclusion as part of a JS string.\n        jsEscape: function (content) {\n            return content.replace(/([\"'\\\\])/g, '\\\\$1')\n                .replace(/[\\f]/g, \"\\\\f\")\n                .replace(/[\\b]/g, \"\\\\b\")\n                .replace(/[\\n]/g, \"\\\\n\")\n                .replace(/[\\t]/g, \"\\\\t\")\n                .replace(/[\\r]/g, \"\\\\r\");\n        }\n    };\n    return lang;\n});\n","/home/travis/build/npmtest/node-npmtest-aurelia-cli/node_modules/aurelia-cli/lib/build/amodro-trace/lib/parse.js":"// Taken from r.js, preserving its style for now to easily port changes in the\n// near term.\nvar define = function(ary, fn) {\n    module.exports = fn.apply(undefined,\n                              (ary.map(function(id) { return require(id); })));\n};\n\n/*jslint plusplus: true */\n/*global define: false */\ndefine(['esprima', './lang'], function (esprima, lang) {\n    'use strict';\n\n    function arrayToString(ary) {\n        var output = '[';\n        if (ary) {\n            ary.forEach(function (item, i) {\n                output += (i > 0 ? ',' : '') + '\"' + lang.jsEscape(item) + '\"';\n            });\n        }\n        output += ']';\n\n        return output;\n    }\n\n    //This string is saved off because JSLint complains\n    //about obj.arguments use, as 'reserved word'\n    var argPropName = 'arguments',\n        //Default object to use for \"scope\" checking for UMD identifiers.\n        emptyScope = {},\n        mixin = lang.mixin,\n        hasProp = lang.hasProp;\n\n    //From an esprima example for traversing its ast.\n    function traverse(object, visitor) {\n        var child;\n\n        if (!object) {\n            return;\n        }\n\n        if (visitor.call(null, object) === false) {\n            return false;\n        }\n        for (var i = 0, keys = Object.keys(object); i < keys.length; i++) {\n            child = object[keys[i]];\n            if (typeof child === 'object' && child !== null) {\n                if (traverse(child, visitor) === false) {\n                    return false;\n                }\n            }\n        }\n    }\n\n    //Like traverse, but visitor returning false just\n    //stops that subtree analysis, not the rest of tree\n    //visiting.\n    function traverseBroad(object, visitor) {\n        var child;\n\n        if (!object) {\n            return;\n        }\n\n        if (visitor.call(null, object) === false) {\n            return false;\n        }\n        for (var i = 0, keys = Object.keys(object); i < keys.length; i++) {\n            child = object[key];\n            if (typeof child === 'object' && child !== null) {\n                traverseBroad(child, visitor);\n            }\n        }\n    }\n\n    /**\n     * Pulls out dependencies from an array literal with just string members.\n     * If string literals, will just return those string values in an array,\n     * skipping other items in the array.\n     *\n     * @param {Node} node an AST node.\n     *\n     * @returns {Array} an array of strings.\n     * If null is returned, then it means the input node was not a valid\n     * dependency.\n     */\n    function getValidDeps(node) {\n        if (!node || node.type !== 'ArrayExpression' || !node.elements) {\n            return;\n        }\n\n        var deps = [];\n\n        node.elements.some(function (elem) {\n            if (elem.type === 'Literal') {\n                deps.push(elem.value);\n            }\n        });\n\n        return deps.length ? deps : undefined;\n    }\n\n    // Detects regular or arrow function expressions as the desired expression\n    // type.\n    function isFnExpression(node) {\n        return (node && (node.type === 'FunctionExpression' ||\n                             node.type === 'ArrowFunctionExpression'));\n    }\n\n    /**\n     * Main parse function. Returns a string of any valid require or\n     * define/require.def calls as part of one JavaScript source string.\n     * @param {String} moduleName the module name that represents this file.\n     * It is used to create a default define if there is not one already for the\n     * file. This allows properly tracing dependencies for builds. Otherwise, if\n     * the file just has a require() call, the file dependencies will not be\n     * properly reflected: the file will come before its dependencies.\n     * @param {String} moduleName\n     * @param {String} fileName\n     * @param {String} fileContents\n     * @param {Object} options optional options. insertNeedsDefine: true will\n     * add calls to require.needsDefine() if appropriate.\n     * @returns {String} JS source string or null, if no require or\n     * define/require.def calls are found.\n     */\n    function parse(moduleName, fileName, fileContents, options) {\n        options = options || {};\n\n        //Set up source input\n        var i, moduleCall, depString,\n            moduleDeps = [],\n            result = '',\n            moduleList = [],\n            needsDefine = true,\n            astRoot = esprima.parse(fileContents);\n\n        parse.recurse(astRoot, function (callName, config, name, deps, node, factoryIdentifier, fnExpScope) {\n            if (!deps) {\n                deps = [];\n            }\n\n            if (callName === 'define' && (!name || name === moduleName)) {\n                needsDefine = false;\n            }\n\n            if (!name) {\n                //If there is no module name, the dependencies are for\n                //this file/default module name.\n                moduleDeps = moduleDeps.concat(deps);\n            } else {\n                moduleList.push({\n                    name: name,\n                    deps: deps\n                });\n            }\n\n            if (callName === 'define' && factoryIdentifier && hasProp(fnExpScope, factoryIdentifier)) {\n                return factoryIdentifier;\n            }\n\n            //If define was found, no need to dive deeper, unless\n            //the config explicitly wants to dig deeper.\n            return !!options.findNestedDependencies;\n        }, options);\n\n        if (options.insertNeedsDefine && needsDefine) {\n            result += 'require.needsDefine(\"' + moduleName + '\");';\n        }\n\n        if (moduleDeps.length || moduleList.length) {\n            for (i = 0; i < moduleList.length; i++) {\n                moduleCall = moduleList[i];\n                if (result) {\n                    result += '\\n';\n                }\n\n                //If this is the main module for this file, combine any\n                //\"anonymous\" dependencies (could come from a nested require\n                //call) with this module.\n                if (moduleCall.name === moduleName) {\n                    moduleCall.deps = moduleCall.deps.concat(moduleDeps);\n                    moduleDeps = [];\n                }\n\n                depString = arrayToString(moduleCall.deps);\n                result += 'define(\"' + moduleCall.name + '\",' +\n                          depString + ');';\n            }\n            if (moduleDeps.length) {\n                if (result) {\n                    result += '\\n';\n                }\n                depString = arrayToString(moduleDeps);\n                result += 'define(\"' + moduleName + '\",' + depString + ');';\n            }\n        }\n\n        return result || null;\n    }\n\n    parse.traverse = traverse;\n    parse.traverseBroad = traverseBroad;\n    parse.isFnExpression = isFnExpression;\n\n    /**\n     * Handles parsing a file recursively for require calls.\n     * @param {Array} parentNode the AST node to start with.\n     * @param {Function} onMatch function to call on a parse match.\n     * @param {Object} [options] This is normally the build config options if\n     * it is passed.\n     * @param {Object} [fnExpScope] holds list of function expresssion\n     * argument identifiers, set up internally, not passed in\n     */\n    parse.recurse = function (object, onMatch, options, fnExpScope) {\n        //Like traverse, but skips if branches that would not be processed\n        //after has application that results in tests of true or false boolean\n        //literal values.\n        var keys, child, result, i, params, param, tempObject,\n            hasHas = options && options.has;\n\n        fnExpScope = fnExpScope || emptyScope;\n\n        if (!object) {\n            return;\n        }\n\n        //If has replacement has resulted in if(true){} or if(false){}, take\n        //the appropriate branch and skip the other one.\n        if (hasHas && object.type === 'IfStatement' && object.test.type &&\n                object.test.type === 'Literal') {\n            if (object.test.value) {\n                //Take the if branch\n                this.recurse(object.consequent, onMatch, options, fnExpScope);\n            } else {\n                //Take the else branch\n                this.recurse(object.alternate, onMatch, options, fnExpScope);\n            }\n        } else {\n            result = this.parseNode(object, onMatch, fnExpScope);\n            if (result === false) {\n                return;\n            } else if (typeof result === 'string') {\n                return result;\n            }\n\n            //Build up a \"scope\" object that informs nested recurse calls if\n            //the define call references an identifier that is likely a UMD\n            //wrapped function expression argument.\n            //Catch (function(a) {... wrappers\n            if (object.type === 'ExpressionStatement' && object.expression &&\n                    object.expression.type === 'CallExpression' && object.expression.callee &&\n                    isFnExpression(object.expression.callee)) {\n                tempObject = object.expression.callee;\n            }\n            // Catch !function(a) {... wrappers\n            if (object.type === 'UnaryExpression' && object.argument &&\n                object.argument.type === 'CallExpression' && object.argument.callee &&\n                isFnExpression(object.argument.callee)) {\n                tempObject = object.argument.callee;\n            }\n            if (tempObject && tempObject.params && tempObject.params.length) {\n                params = tempObject.params;\n                fnExpScope = mixin({}, fnExpScope, true);\n                for (i = 0; i < params.length; i++) {\n                    param = params[i];\n                    if (param.type === 'Identifier') {\n                        fnExpScope[param.name] = true;\n                    }\n                }\n            }\n\n            for (i = 0, keys = Object.keys(object); i < keys.length; i++) {\n                child = object[keys[i]];\n                if (typeof child === 'object' && child !== null) {\n                    result = this.recurse(child, onMatch, options, fnExpScope);\n                    if (typeof result === 'string' && hasProp(fnExpScope, result)) {\n                        //The result was still in fnExpScope so break. Otherwise,\n                        //was a return from a a tree that had a UMD definition,\n                        //but now out of that scope so keep siblings.\n                        break;\n                    }\n                }\n            }\n\n            //Check for an identifier for a factory function identifier being\n            //passed in as a function expression, indicating a UMD-type of\n            //wrapping.\n            if (typeof result === 'string') {\n                if (hasProp(fnExpScope, result)) {\n                    //result still in scope, keep jumping out indicating the\n                    //identifier still in use.\n                    return result;\n                }\n\n                return;\n            }\n        }\n    };\n\n    /**\n     * Determines if the file defines the require/define module API.\n     * Specifically, it looks for the `define.amd = ` expression.\n     * @param {String} fileName\n     * @param {String} fileContents\n     * @returns {Boolean}\n     */\n    parse.definesRequire = function (fileName, fileContents) {\n        var foundDefine = false,\n            foundDefineAmd = false;\n\n        traverse(esprima.parse(fileContents), function (node) {\n            // Look for a top level declaration of a define, like\n            // var requirejs, require, define, off Program body.\n            if (node.type === 'Program' && node.body && node.body.length) {\n                foundDefine = node.body.some(function(bodyNode) {\n                    // var define\n                    if (bodyNode.type === 'VariableDeclaration') {\n                        var decls = bodyNode.declarations;\n                        if (decls) {\n                            var hasVarDefine = decls.some(function(declNode) {\n                                return (declNode.type === 'VariableDeclarator' &&\n                                        declNode.id &&\n                                        declNode.id.type === 'Identifier' &&\n                                        declNode.id.name === 'define');\n                            });\n                            if (hasVarDefine) {\n                                return true;\n                            }\n                        }\n                    }\n\n                    // function define() {}\n                    if (bodyNode.type === 'FunctionDeclaration' &&\n                        bodyNode.id &&\n                        bodyNode.id.type === 'Identifier' &&\n                        bodyNode.id.name === 'define') {\n                        return true;\n                    }\n\n\n\n\n\n\n                });\n            }\n\n            // Need define variable found first, before detecting define.amd.\n            if (foundDefine && parse.hasDefineAmd(node)) {\n                foundDefineAmd = true;\n\n                //Stop traversal\n                return false;\n            }\n        });\n\n        return foundDefine && foundDefineAmd;\n    };\n\n    /**\n     * Finds require(\"\") calls inside a CommonJS anonymous module wrapped in a\n     * define(function(require, exports, module){}) wrapper. These dependencies\n     * will be added to a modified define() call that lists the dependencies\n     * on the outside of the function.\n     * @param {String} fileName\n     * @param {String|Object} fileContents: a string of contents, or an already\n     * parsed AST tree.\n     * @returns {Array} an array of module names that are dependencies. Always\n     * returns an array, but could be of length zero.\n     */\n    parse.getAnonDeps = function (fileName, fileContents) {\n        var astRoot = typeof fileContents === 'string' ?\n                      esprima.parse(fileContents) : fileContents,\n            defFunc = this.findAnonDefineFactory(astRoot);\n\n        return parse.getAnonDepsFromNode(defFunc);\n    };\n\n    /**\n     * Finds require(\"\") calls inside a CommonJS anonymous module wrapped\n     * in a define function, given an AST node for the definition function.\n     * @param {Node} node the AST node for the definition function.\n     * @returns {Array} and array of dependency names. Can be of zero length.\n     */\n    parse.getAnonDepsFromNode = function (node) {\n        var deps = [],\n            funcArgLength;\n\n        if (node) {\n            this.findRequireDepNames(node, deps);\n\n            //If no deps, still add the standard CommonJS require, exports,\n            //module, in that order, to the deps, but only if specified as\n            //function args. In particular, if exports is used, it is favored\n            //over the return value of the function, so only add it if asked.\n            funcArgLength = node.params && node.params.length;\n            if (funcArgLength) {\n                deps = (funcArgLength > 1 ? [\"require\", \"exports\", \"module\"] :\n                        [\"require\"]).concat(deps);\n            }\n        }\n        return deps;\n    };\n\n    parse.isDefineNodeWithArgs = function (node) {\n        return node && node.type === 'CallExpression' &&\n               node.callee && node.callee.type === 'Identifier' &&\n               node.callee.name === 'define' && node[argPropName];\n    };\n\n    /**\n     * Finds the function in define(function (require, exports, module){});\n     * @param {Array} node\n     * @returns {Boolean}\n     */\n    parse.findAnonDefineFactory = function (node) {\n        var match;\n\n        traverse(node, function (node) {\n            var arg0, arg1;\n\n            if (parse.isDefineNodeWithArgs(node)) {\n\n                //Just the factory function passed to define\n                arg0 = node[argPropName][0];\n                if (isFnExpression(arg0)) {\n                    match = arg0;\n                    return false;\n                }\n\n                //A string literal module ID followed by the factory function.\n                arg1 = node[argPropName][1];\n                if (arg0.type === 'Literal' && isFnExpression(arg1)) {\n                    match = arg1;\n                    return false;\n                }\n            }\n        });\n\n        return match;\n    };\n\n    /**\n     * Finds any config that is passed to requirejs. That includes calls to\n     * require/requirejs.config(), as well as require({}, ...) and\n     * requirejs({}, ...)\n     * @param {String} fileContents\n     *\n     * @returns {Object} a config details object with the following properties:\n     * - config: {Object} the config object found. Can be undefined if no\n     * config found.\n     * - range: {Array} the start index and end index in the contents where\n     * the config was found. Can be undefined if no config found.\n     * Can throw an error if the config in the file cannot be evaluated in\n     * a build context to valid JavaScript.\n     */\n    parse.findConfig = function (fileContents) {\n        /*jslint evil: true */\n        var jsConfig, foundConfig, stringData, foundRange, quote, quoteMatch,\n            quoteRegExp = /(:\\s|\\[\\s*)(['\"])/,\n            astRoot = esprima.parse(fileContents, {\n                loc: true\n            });\n\n        traverse(astRoot, function (node) {\n            var arg,\n                requireType = parse.hasRequire(node);\n\n            if (requireType && (requireType === 'require' ||\n                    requireType === 'requirejs' ||\n                    requireType === 'requireConfig' ||\n                    requireType === 'requirejsConfig')) {\n\n                arg = node[argPropName] && node[argPropName][0];\n\n                if (arg && arg.type === 'ObjectExpression') {\n                    stringData = parse.nodeToString(fileContents, arg);\n                    jsConfig = stringData.value;\n                    foundRange = stringData.range;\n                    return false;\n                }\n            } else {\n                arg = parse.getRequireObjectLiteral(node);\n                if (arg) {\n                    stringData = parse.nodeToString(fileContents, arg);\n                    jsConfig = stringData.value;\n                    foundRange = stringData.range;\n                    return false;\n                }\n            }\n        });\n\n        if (jsConfig) {\n            // Eval the config\n            quoteMatch = quoteRegExp.exec(jsConfig);\n            quote = (quoteMatch && quoteMatch[2]) || '\"';\n            foundConfig = eval('(' + jsConfig + ')');\n        }\n\n        return {\n            config: foundConfig,\n            range: foundRange,\n            quote: quote\n        };\n    };\n\n    /** Returns the node for the object literal assigned to require/requirejs,\n     * for holding a declarative config.\n     */\n    parse.getRequireObjectLiteral = function (node) {\n        if (node.id && node.id.type === 'Identifier' &&\n                (node.id.name === 'require' || node.id.name === 'requirejs') &&\n                node.init && node.init.type === 'ObjectExpression') {\n            return node.init;\n        }\n    };\n\n    /**\n     * Renames require/requirejs/define calls to be ns + '.' + require/requirejs/define\n     * Does *not* do .config calls though. See pragma.namespace for the complete\n     * set of namespace transforms. This function is used because require calls\n     * inside a define() call should not be renamed, so a simple regexp is not\n     * good enough.\n     * @param  {String} fileContents the contents to transform.\n     * @param  {String} ns the namespace, *not* including trailing dot.\n     * @return {String} the fileContents with the namespace applied\n     */\n    parse.renameNamespace = function (fileContents, ns) {\n        var lines,\n            locs = [],\n            astRoot = esprima.parse(fileContents, {\n                loc: true\n            });\n\n        parse.recurse(astRoot, function (callName, config, name, deps, node) {\n            locs.push(node.loc);\n            //Do not recurse into define functions, they should be using\n            //local defines.\n            return callName !== 'define';\n        }, {});\n\n        if (locs.length) {\n            lines = fileContents.split('\\n');\n\n            //Go backwards through the found locs, adding in the namespace name\n            //in front.\n            locs.reverse();\n            locs.forEach(function (loc) {\n                var startIndex = loc.start.column,\n                //start.line is 1-based, not 0 based.\n                lineIndex = loc.start.line - 1,\n                line = lines[lineIndex];\n\n                lines[lineIndex] = line.substring(0, startIndex) +\n                                   ns + '.' +\n                                   line.substring(startIndex,\n                                                      line.length);\n            });\n\n            fileContents = lines.join('\\n');\n        }\n\n        return fileContents;\n    };\n\n    /**\n     * Finds all dependencies specified in dependency arrays and inside\n     * simplified commonjs wrappers.\n     * @param {String} fileName\n     * @param {String} fileContents\n     *\n     * @returns {Array} an array of dependency strings. The dependencies\n     * have not been normalized, they may be relative IDs.\n     */\n    parse.findDependencies = function (fileName, fileContents, options) {\n        var dependencies = [],\n            astRoot = esprima.parse(fileContents);\n\n        parse.recurse(astRoot, function (callName, config, name, deps) {\n            if (deps) {\n                dependencies = dependencies.concat(deps);\n            }\n        }, options);\n\n        return dependencies;\n    };\n\n    /**\n     * Finds only CJS dependencies, ones that are the form\n     * require('stringLiteral')\n     */\n    parse.findCjsDependencies = function (fileName, fileContents) {\n        var dependencies = [];\n\n        traverse(esprima.parse(fileContents), function (node) {\n            var arg;\n\n            if (node && node.type === 'CallExpression' && node.callee &&\n                    node.callee.type === 'Identifier' &&\n                    node.callee.name === 'require' && node[argPropName] &&\n                    node[argPropName].length === 1) {\n                arg = node[argPropName][0];\n                if (arg.type === 'Literal') {\n                    dependencies.push(arg.value);\n                }\n            }\n        });\n\n        return dependencies;\n    };\n\n    //function define() {}\n    parse.hasDefDefine = function (node) {\n        return node.type === 'FunctionDeclaration' && node.id &&\n                    node.id.type === 'Identifier' && node.id.name === 'define';\n    };\n\n    //define.amd = ...\n    parse.hasDefineAmd = function (node) {\n        return node && node.type === 'AssignmentExpression' &&\n            node.left && node.left.type === 'MemberExpression' &&\n            node.left.object && node.left.object.name === 'define' &&\n            node.left.property && node.left.property.name === 'amd';\n    };\n\n    //define.amd reference, as in: if (define.amd)\n    parse.refsDefineAmd = function (node) {\n        return node && node.type === 'MemberExpression' &&\n        node.object && node.object.name === 'define' &&\n        node.object.type === 'Identifier' &&\n        node.property && node.property.name === 'amd' &&\n        node.property.type === 'Identifier';\n    };\n\n    //require(), requirejs(), require.config() and requirejs.config()\n    parse.hasRequire = function (node) {\n        var callName,\n            c = node && node.callee;\n\n        if (node && node.type === 'CallExpression' && c) {\n            if (c.type === 'Identifier' &&\n                    (c.name === 'require' ||\n                    c.name === 'requirejs')) {\n                //A require/requirejs({}, ...) call\n                callName = c.name;\n            } else if (c.type === 'MemberExpression' &&\n                    c.object &&\n                    c.object.type === 'Identifier' &&\n                    (c.object.name === 'require' ||\n                        c.object.name === 'requirejs') &&\n                    c.property && c.property.name === 'config') {\n                // require/requirejs.config({}) call\n                callName = c.object.name + 'Config';\n            }\n        }\n\n        return callName;\n    };\n\n    //define()\n    parse.hasDefine = function (node) {\n        return node && node.type === 'CallExpression' && node.callee &&\n            node.callee.type === 'Identifier' &&\n            node.callee.name === 'define';\n    };\n\n    /**\n     * If there is a named define in the file, returns the name. Does not\n     * scan for mulitple names, just the first one.\n     */\n    parse.getNamedDefine = function (fileContents) {\n        var name;\n        traverse(esprima.parse(fileContents), function (node) {\n            if (node && node.type === 'CallExpression' && node.callee &&\n            node.callee.type === 'Identifier' &&\n            node.callee.name === 'define' &&\n            node[argPropName] && node[argPropName][0] &&\n            node[argPropName][0].type === 'Literal') {\n                name = node[argPropName][0].value;\n                return false;\n            }\n        });\n\n        return name;\n    };\n\n    /**\n     * Finds all the named define module IDs in a file.\n     */\n    parse.getAllNamedDefines = function (fileContents, excludeMap) {\n        var names = [];\n        parse.recurse(esprima.parse(fileContents),\n        function (callName, config, name, deps, node, factoryIdentifier, fnExpScope) {\n            if (callName === 'define' && name) {\n                if (!excludeMap.hasOwnProperty(name)) {\n                    names.push(name);\n                }\n            }\n\n            //If a UMD definition that points to a factory that is an Identifier,\n            //indicate processing should not traverse inside the UMD definition.\n            if (callName === 'define' && factoryIdentifier && hasProp(fnExpScope, factoryIdentifier)) {\n                return factoryIdentifier;\n            }\n\n            //If define was found, no need to dive deeper, unless\n            //the config explicitly wants to dig deeper.\n            return true;\n        }, {});\n\n        return names;\n    };\n\n    /**\n     * Determines if define(), require({}|[]) or requirejs was called in the\n     * file. Also finds out if define() is declared and if define.amd is called.\n     */\n    parse.usesAmdOrRequireJs = function (fileName, fileContents) {\n        var uses;\n\n        traverse(esprima.parse(fileContents), function (node) {\n            var type, callName, arg;\n\n            if (parse.hasDefDefine(node)) {\n                //function define() {}\n                type = 'declaresDefine';\n            } else if (parse.hasDefineAmd(node)) {\n                type = 'defineAmd';\n            } else {\n                callName = parse.hasRequire(node);\n                if (callName) {\n                    arg = node[argPropName] && node[argPropName][0];\n                    if (arg && (arg.type === 'ObjectExpression' ||\n                            arg.type === 'ArrayExpression')) {\n                        type = callName;\n                    }\n                } else if (parse.hasDefine(node)) {\n                    type = 'define';\n                }\n            }\n\n            if (type) {\n                if (!uses) {\n                    uses = {};\n                }\n                uses[type] = true;\n            }\n        });\n\n        return uses;\n    };\n\n    /**\n     * Determines if require(''), exports.x =, module.exports =,\n     * __dirname, __filename are used. So, not strictly traditional CommonJS,\n     * also checks for Node variants.\n     */\n    parse.usesCommonJs = function (fileName, fileContents) {\n        var uses = null,\n            assignsExports = false;\n\n\n        traverse(esprima.parse(fileContents), function (node) {\n            var type,\n                exp = node.expression || node.init;\n\n            if (node.type === 'Identifier' &&\n                    (node.name === '__dirname' || node.name === '__filename')) {\n                type = node.name.substring(2);\n            } else if (node.type === 'VariableDeclarator' && node.id &&\n                    node.id.type === 'Identifier' &&\n                        node.id.name === 'exports') {\n                //Hmm, a variable assignment for exports, so does not use cjs\n                //exports.\n                type = 'varExports';\n            } else if (exp && exp.type === 'AssignmentExpression' && exp.left &&\n                    exp.left.type === 'MemberExpression' && exp.left.object) {\n                if (exp.left.object.name === 'module' && exp.left.property &&\n                        exp.left.property.name === 'exports') {\n                    type = 'moduleExports';\n                } else if (exp.left.object.name === 'exports' &&\n                        exp.left.property) {\n                    type = 'exports';\n                } else if (exp.left.object.type === 'MemberExpression' &&\n                           exp.left.object.object.name === 'module' &&\n                           exp.left.object.property.name === 'exports' &&\n                           exp.left.object.property.type === 'Identifier') {\n                    type = 'moduleExports';\n                }\n\n            } else if (node && node.type === 'CallExpression' && node.callee &&\n                    node.callee.type === 'Identifier' &&\n                    node.callee.name === 'require' && node[argPropName] &&\n                    node[argPropName].length === 1 &&\n                    node[argPropName][0].type === 'Literal') {\n                type = 'require';\n            }\n\n            if (type) {\n                if (type === 'varExports') {\n                    assignsExports = true;\n                } else if (type !== 'exports' || !assignsExports) {\n                    if (!uses) {\n                        uses = {};\n                    }\n                    uses[type] = true;\n                }\n            }\n        });\n\n        return uses;\n    };\n\n\n    parse.findRequireDepNames = function (node, deps) {\n        traverse(node, function (node) {\n            var arg;\n\n            if (node && node.type === 'CallExpression' && node.callee &&\n                    node.callee.type === 'Identifier' &&\n                    node.callee.name === 'require' &&\n                    node[argPropName] && node[argPropName].length === 1) {\n\n                arg = node[argPropName][0];\n                if (arg.type === 'Literal') {\n                    deps.push(arg.value);\n                }\n            }\n        });\n    };\n\n    /**\n     * Determines if a specific node is a valid require or define/require.def\n     * call.\n     * @param {Array} node\n     * @param {Function} onMatch a function to call when a match is found.\n     * It is passed the match name, and the config, name, deps possible args.\n     * The config, name and deps args are not normalized.\n     * @param {Object} fnExpScope an object whose keys are all function\n     * expression identifiers that should be in scope. Useful for UMD wrapper\n     * detection to avoid parsing more into the wrapped UMD code.\n     *\n     * @returns {String} a JS source string with the valid require/define call.\n     * Otherwise null.\n     */\n    parse.parseNode = function (node, onMatch, fnExpScope) {\n        var name, deps, cjsDeps, arg, factory, exp, refsDefine, bodyNode,\n            args = node && node[argPropName],\n            callName = parse.hasRequire(node),\n            isUmd = false;\n\n        if (callName === 'require' || callName === 'requirejs') {\n            //A plain require/requirejs call\n            arg = node[argPropName] && node[argPropName][0];\n            if (arg && arg.type !== 'ArrayExpression') {\n                if (arg.type === 'ObjectExpression') {\n                    //A config call, try the second arg.\n                    arg = node[argPropName][1];\n                }\n            }\n\n            deps = getValidDeps(arg);\n            if (!deps) {\n                return;\n            }\n\n            return onMatch(\"require\", null, null, deps, node);\n        } else if (parse.hasDefine(node) && args && args.length) {\n            name = args[0];\n            deps = args[1];\n            factory = args[2];\n\n            if (name.type === 'ArrayExpression') {\n                //No name, adjust args\n                factory = deps;\n                deps = name;\n                name = null;\n            } else if (isFnExpression(name)) {\n                //Just the factory, no name or deps\n                factory = name;\n                name = deps = null;\n            } else if (name.type === 'Identifier' && args.length === 1 &&\n                       hasProp(fnExpScope, name.name)) {\n                //define(e) where e is a UMD identifier for the factory\n                //function.\n                isUmd = true;\n                factory = name;\n                name = null;\n            } else if (name.type !== 'Literal') {\n                 //An object literal, just null out\n                name = deps = factory = null;\n            }\n\n            if (name && name.type === 'Literal' && deps) {\n                if (isFnExpression(deps)) {\n                    //deps is the factory\n                    factory = deps;\n                    deps = null;\n                } else if (deps.type === 'ObjectExpression') {\n                    //deps is object literal, null out\n                    deps = factory = null;\n                } else if (deps.type === 'Identifier') {\n                    if (args.length === 2) {\n                        //define('id', factory)\n                        deps = factory = null;\n                    } else if (args.length === 3 && isFnExpression(factory)) {\n                        //define('id', depsIdentifier, factory)\n                        //Since identifier, cannot know the deps, but do not\n                        //error out, assume they are taken care of outside of\n                        //static parsing.\n                        deps = null;\n                    }\n                }\n            }\n\n            if (deps && deps.type === 'ArrayExpression') {\n                deps = getValidDeps(deps);\n            } else if (isFnExpression(factory)) {\n                //If no deps and a factory function, could be a commonjs sugar\n                //wrapper, scan the function for dependencies.\n                cjsDeps = parse.getAnonDepsFromNode(factory);\n                if (cjsDeps.length) {\n                    deps = cjsDeps;\n                }\n            } else if (deps || (factory && !isUmd)) {\n                //Does not match the shape of an AMD call.\n                return;\n            }\n\n            //Just save off the name as a string instead of an AST object.\n            if (name && name.type === 'Literal') {\n                name = name.value;\n            }\n\n            return onMatch(\"define\", null, name, deps, node,\n                           (factory && factory.type === 'Identifier' ? factory.name : undefined),\n                           fnExpScope);\n        } else if (node.type === 'CallExpression' && node.callee &&\n                   isFnExpression(node.callee) &&\n                   node.callee.body && node.callee.body.body &&\n                   node.callee.body.body.length === 1 &&\n                   node.callee.body.body[0].type === 'IfStatement') {\n            bodyNode = node.callee.body.body[0];\n            //Look for a define(Identifier) case, but only if inside an\n            //if that has a define.amd test\n            if (bodyNode.consequent && bodyNode.consequent.body) {\n                exp = bodyNode.consequent.body[0];\n                if (exp.type === 'ExpressionStatement' && exp.expression &&\n                    parse.hasDefine(exp.expression) &&\n                    exp.expression.arguments &&\n                    exp.expression.arguments.length === 1 &&\n                    exp.expression.arguments[0].type === 'Identifier') {\n\n                    //Calls define(Identifier) as first statement in body.\n                    //Confirm the if test references define.amd\n                    traverse(bodyNode.test, function (node) {\n                        if (parse.refsDefineAmd(node)) {\n                            refsDefine = true;\n                            return false;\n                        }\n                    });\n\n                    if (refsDefine) {\n                        return onMatch(\"define\", null, null, null, exp.expression,\n                                       exp.expression.arguments[0].name, fnExpScope);\n                    }\n                }\n            }\n        }\n    };\n\n    /**\n     * Converts an AST node into a JS source string by extracting\n     * the node's location from the given contents string. Assumes\n     * esprima.parse() with loc was done.\n     * @param {String} contents\n     * @param {Object} node\n     * @returns {String} a JS source string.\n     */\n    parse.nodeToString = function (contents, node) {\n        var extracted,\n            loc = node.loc,\n            lines = contents.split('\\n'),\n            firstLine = loc.start.line > 1 ?\n                        lines.slice(0, loc.start.line - 1).join('\\n') + '\\n' :\n                        '',\n            preamble = firstLine +\n                       lines[loc.start.line - 1].substring(0, loc.start.column);\n\n        if (loc.start.line === loc.end.line) {\n            extracted = lines[loc.start.line - 1].substring(loc.start.column,\n                                                            loc.end.column);\n        } else {\n            extracted =  lines[loc.start.line - 1].substring(loc.start.column) +\n                     '\\n' +\n                     lines.slice(loc.start.line, loc.end.line - 1).join('\\n') +\n                     '\\n' +\n                     lines[loc.end.line - 1].substring(0, loc.end.column);\n        }\n\n        return {\n            value: extracted,\n            range: [\n                preamble.length,\n                preamble.length + extracted.length\n            ]\n        };\n    };\n\n    /**\n     * Extracts license comments from JS text.\n     * @param {String} fileName\n     * @param {String} contents\n     * @returns {String} a string of license comments.\n     */\n    parse.getLicenseComments = function (fileName, contents) {\n        var commentNode, refNode, subNode, value, i, j,\n            //xpconnect's Reflect does not support comment or range, but\n            //prefer continued operation vs strict parity of operation,\n            //as license comments can be expressed in other ways, like\n            //via wrap args, or linked via sourcemaps.\n            ast = esprima.parse(contents, {\n                comment: true,\n                range: true\n            }),\n            result = '',\n            existsMap = {},\n            lineEnd = contents.indexOf('\\r') === -1 ? '\\n' : '\\r\\n';\n\n        if (ast.comments) {\n            for (i = 0; i < ast.comments.length; i++) {\n                commentNode = ast.comments[i];\n\n                if (commentNode.type === 'Line') {\n                    value = '//' + commentNode.value + lineEnd;\n                    refNode = commentNode;\n\n                    if (i + 1 >= ast.comments.length) {\n                        value += lineEnd;\n                    } else {\n                        //Look for immediately adjacent single line comments\n                        //since it could from a multiple line comment made out\n                        //of single line comments. Like this comment.\n                        for (j = i + 1; j < ast.comments.length; j++) {\n                            subNode = ast.comments[j];\n                            if (subNode.type === 'Line' &&\n                                    subNode.range[0] === refNode.range[1] + 1) {\n                                //Adjacent single line comment. Collect it.\n                                value += '//' + subNode.value + lineEnd;\n                                refNode = subNode;\n                            } else {\n                                //No more single line comment blocks. Break out\n                                //and continue outer looping.\n                                break;\n                            }\n                        }\n                        value += lineEnd;\n                        i = j - 1;\n                    }\n                } else {\n                    value = '/*' + commentNode.value + '*/' + lineEnd + lineEnd;\n                }\n\n                if (!existsMap[value] && (value.indexOf('license') !== -1 ||\n                        (commentNode.type === 'Block' &&\n                            value.indexOf('/*!') === 0) ||\n                        value.indexOf('opyright') !== -1 ||\n                        value.indexOf('(c)') !== -1)) {\n\n                    result += value;\n                    existsMap[value] = true;\n                }\n\n            }\n        }\n\n        return result;\n    };\n\n    return parse;\n});\n","/home/travis/build/npmtest/node-npmtest-aurelia-cli/node_modules/aurelia-cli/lib/build/amodro-trace/node_modules/esprima/index.js":"/*\n  Copyright (c) jQuery Foundation, Inc. and Contributors, All Rights Reserved.\n\n  Redistribution and use in source and binary forms, with or without\n  modification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n(function (root, factory) {\n    'use strict';\n\n    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js,\n    // Rhino, and plain browser loading.\n\n    /* istanbul ignore next */\n    if (typeof define === 'function' && define.amd) {\n        define(['exports'], factory);\n    } else if (typeof exports !== 'undefined') {\n        factory(exports);\n    } else {\n        factory((root.esprima = {}));\n    }\n}(this, function (exports) {\n    'use strict';\n\n    var Token,\n        TokenName,\n        FnExprTokens,\n        Syntax,\n        PlaceHolders,\n        Messages,\n        Regex,\n        source,\n        strict,\n        index,\n        lineNumber,\n        lineStart,\n        hasLineTerminator,\n        lastIndex,\n        lastLineNumber,\n        lastLineStart,\n        startIndex,\n        startLineNumber,\n        startLineStart,\n        scanning,\n        length,\n        lookahead,\n        state,\n        extra,\n        isBindingElement,\n        isAssignmentTarget,\n        firstCoverInitializedNameError;\n\n    Token = {\n        BooleanLiteral: 1,\n        EOF: 2,\n        Identifier: 3,\n        Keyword: 4,\n        NullLiteral: 5,\n        NumericLiteral: 6,\n        Punctuator: 7,\n        StringLiteral: 8,\n        RegularExpression: 9,\n        Template: 10\n    };\n\n    TokenName = {};\n    TokenName[Token.BooleanLiteral] = 'Boolean';\n    TokenName[Token.EOF] = '<end>';\n    TokenName[Token.Identifier] = 'Identifier';\n    TokenName[Token.Keyword] = 'Keyword';\n    TokenName[Token.NullLiteral] = 'Null';\n    TokenName[Token.NumericLiteral] = 'Numeric';\n    TokenName[Token.Punctuator] = 'Punctuator';\n    TokenName[Token.StringLiteral] = 'String';\n    TokenName[Token.RegularExpression] = 'RegularExpression';\n    TokenName[Token.Template] = 'Template';\n\n    // A function following one of those tokens is an expression.\n    FnExprTokens = ['(', '{', '[', 'in', 'typeof', 'instanceof', 'new',\n                    'return', 'case', 'delete', 'throw', 'void',\n                    // assignment operators\n                    '=', '+=', '-=', '*=', '/=', '%=', '<<=', '>>=', '>>>=',\n                    '&=', '|=', '^=', ',',\n                    // binary/unary operators\n                    '+', '-', '*', '/', '%', '++', '--', '<<', '>>', '>>>', '&',\n                    '|', '^', '!', '~', '&&', '||', '?', ':', '===', '==', '>=',\n                    '<=', '<', '>', '!=', '!=='];\n\n    Syntax = {\n        AssignmentExpression: 'AssignmentExpression',\n        AssignmentPattern: 'AssignmentPattern',\n        ArrayExpression: 'ArrayExpression',\n        ArrayPattern: 'ArrayPattern',\n        ArrowFunctionExpression: 'ArrowFunctionExpression',\n        BlockStatement: 'BlockStatement',\n        BinaryExpression: 'BinaryExpression',\n        BreakStatement: 'BreakStatement',\n        CallExpression: 'CallExpression',\n        CatchClause: 'CatchClause',\n        ClassBody: 'ClassBody',\n        ClassDeclaration: 'ClassDeclaration',\n        ClassExpression: 'ClassExpression',\n        ConditionalExpression: 'ConditionalExpression',\n        ContinueStatement: 'ContinueStatement',\n        DoWhileStatement: 'DoWhileStatement',\n        DebuggerStatement: 'DebuggerStatement',\n        EmptyStatement: 'EmptyStatement',\n        ExportAllDeclaration: 'ExportAllDeclaration',\n        ExportDefaultDeclaration: 'ExportDefaultDeclaration',\n        ExportNamedDeclaration: 'ExportNamedDeclaration',\n        ExportSpecifier: 'ExportSpecifier',\n        ExpressionStatement: 'ExpressionStatement',\n        ForStatement: 'ForStatement',\n        ForOfStatement: 'ForOfStatement',\n        ForInStatement: 'ForInStatement',\n        FunctionDeclaration: 'FunctionDeclaration',\n        FunctionExpression: 'FunctionExpression',\n        Identifier: 'Identifier',\n        IfStatement: 'IfStatement',\n        ImportDeclaration: 'ImportDeclaration',\n        ImportDefaultSpecifier: 'ImportDefaultSpecifier',\n        ImportNamespaceSpecifier: 'ImportNamespaceSpecifier',\n        ImportSpecifier: 'ImportSpecifier',\n        Literal: 'Literal',\n        LabeledStatement: 'LabeledStatement',\n        LogicalExpression: 'LogicalExpression',\n        MemberExpression: 'MemberExpression',\n        MetaProperty: 'MetaProperty',\n        MethodDefinition: 'MethodDefinition',\n        NewExpression: 'NewExpression',\n        ObjectExpression: 'ObjectExpression',\n        ObjectPattern: 'ObjectPattern',\n        Program: 'Program',\n        Property: 'Property',\n        RestElement: 'RestElement',\n        ReturnStatement: 'ReturnStatement',\n        SequenceExpression: 'SequenceExpression',\n        SpreadElement: 'SpreadElement',\n        Super: 'Super',\n        SwitchCase: 'SwitchCase',\n        SwitchStatement: 'SwitchStatement',\n        TaggedTemplateExpression: 'TaggedTemplateExpression',\n        TemplateElement: 'TemplateElement',\n        TemplateLiteral: 'TemplateLiteral',\n        ThisExpression: 'ThisExpression',\n        ThrowStatement: 'ThrowStatement',\n        TryStatement: 'TryStatement',\n        UnaryExpression: 'UnaryExpression',\n        UpdateExpression: 'UpdateExpression',\n        VariableDeclaration: 'VariableDeclaration',\n        VariableDeclarator: 'VariableDeclarator',\n        WhileStatement: 'WhileStatement',\n        WithStatement: 'WithStatement',\n        YieldExpression: 'YieldExpression'\n    };\n\n    PlaceHolders = {\n        ArrowParameterPlaceHolder: 'ArrowParameterPlaceHolder'\n    };\n\n    // Error messages should be identical to V8.\n    Messages = {\n        UnexpectedToken: 'Unexpected token %0',\n        UnexpectedNumber: 'Unexpected number',\n        UnexpectedString: 'Unexpected string',\n        UnexpectedIdentifier: 'Unexpected identifier',\n        UnexpectedReserved: 'Unexpected reserved word',\n        UnexpectedTemplate: 'Unexpected quasi %0',\n        UnexpectedEOS: 'Unexpected end of input',\n        NewlineAfterThrow: 'Illegal newline after throw',\n        InvalidRegExp: 'Invalid regular expression',\n        UnterminatedRegExp: 'Invalid regular expression: missing /',\n        InvalidLHSInAssignment: 'Invalid left-hand side in assignment',\n        InvalidLHSInForIn: 'Invalid left-hand side in for-in',\n        InvalidLHSInForLoop: 'Invalid left-hand side in for-loop',\n        MultipleDefaultsInSwitch: 'More than one default clause in switch statement',\n        NoCatchOrFinally: 'Missing catch or finally after try',\n        UnknownLabel: 'Undefined label \\'%0\\'',\n        Redeclaration: '%0 \\'%1\\' has already been declared',\n        IllegalContinue: 'Illegal continue statement',\n        IllegalBreak: 'Illegal break statement',\n        IllegalReturn: 'Illegal return statement',\n        StrictModeWith: 'Strict mode code may not include a with statement',\n        StrictCatchVariable: 'Catch variable may not be eval or arguments in strict mode',\n        StrictVarName: 'Variable name may not be eval or arguments in strict mode',\n        StrictParamName: 'Parameter name eval or arguments is not allowed in strict mode',\n        StrictParamDupe: 'Strict mode function may not have duplicate parameter names',\n        StrictFunctionName: 'Function name may not be eval or arguments in strict mode',\n        StrictOctalLiteral: 'Octal literals are not allowed in strict mode.',\n        StrictDelete: 'Delete of an unqualified identifier in strict mode.',\n        StrictLHSAssignment: 'Assignment to eval or arguments is not allowed in strict mode',\n        StrictLHSPostfix: 'Postfix increment/decrement may not have eval or arguments operand in strict mode',\n        StrictLHSPrefix: 'Prefix increment/decrement may not have eval or arguments operand in strict mode',\n        StrictReservedWord: 'Use of future reserved word in strict mode',\n        TemplateOctalLiteral: 'Octal literals are not allowed in template strings.',\n        ParameterAfterRestParameter: 'Rest parameter must be last formal parameter',\n        DefaultRestParameter: 'Unexpected token =',\n        ObjectPatternAsRestParameter: 'Unexpected token {',\n        DuplicateProtoProperty: 'Duplicate __proto__ fields are not allowed in object literals',\n        ConstructorSpecialMethod: 'Class constructor may not be an accessor',\n        DuplicateConstructor: 'A class may only have one constructor',\n        StaticPrototype: 'Classes may not have static property named prototype',\n        MissingFromClause: 'Unexpected token',\n        NoAsAfterImportNamespace: 'Unexpected token',\n        InvalidModuleSpecifier: 'Unexpected token',\n        IllegalImportDeclaration: 'Unexpected token',\n        IllegalExportDeclaration: 'Unexpected token',\n        DuplicateBinding: 'Duplicate binding %0'\n    };\n\n    // See also tools/generate-unicode-regex.js.\n    Regex = {\n        // ECMAScript 6/Unicode v7.0.0 NonAsciiIdentifierStart:\n        NonAsciiIdentifierStart: /[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0620-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u08A0-\\u08B2\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D\\u0C58\\u0C59\\u0C60\\u0C61\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D60\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1877\\u1880-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19C1-\\u19C7\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1CE9-\\u1CEC\\u1CEE-\\u1CF1\\u1CF5\\u1CF6\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2118-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u309B-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA66E\\uA67F-\\uA69D\\uA6A0-\\uA6EF\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA7AD\\uA7B0\\uA7B1\\uA7F7-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF\\uA9E0-\\uA9E4\\uA9E6-\\uA9EF\\uA9FA-\\uA9FE\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA76\\uAA7A\\uAA7E-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB5F\\uAB64\\uAB65\\uABC0-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]|\\uD800[\\uDC00-\\uDC0B\\uDC0D-\\uDC26\\uDC28-\\uDC3A\\uDC3C\\uDC3D\\uDC3F-\\uDC4D\\uDC50-\\uDC5D\\uDC80-\\uDCFA\\uDD40-\\uDD74\\uDE80-\\uDE9C\\uDEA0-\\uDED0\\uDF00-\\uDF1F\\uDF30-\\uDF4A\\uDF50-\\uDF75\\uDF80-\\uDF9D\\uDFA0-\\uDFC3\\uDFC8-\\uDFCF\\uDFD1-\\uDFD5]|\\uD801[\\uDC00-\\uDC9D\\uDD00-\\uDD27\\uDD30-\\uDD63\\uDE00-\\uDF36\\uDF40-\\uDF55\\uDF60-\\uDF67]|\\uD802[\\uDC00-\\uDC05\\uDC08\\uDC0A-\\uDC35\\uDC37\\uDC38\\uDC3C\\uDC3F-\\uDC55\\uDC60-\\uDC76\\uDC80-\\uDC9E\\uDD00-\\uDD15\\uDD20-\\uDD39\\uDD80-\\uDDB7\\uDDBE\\uDDBF\\uDE00\\uDE10-\\uDE13\\uDE15-\\uDE17\\uDE19-\\uDE33\\uDE60-\\uDE7C\\uDE80-\\uDE9C\\uDEC0-\\uDEC7\\uDEC9-\\uDEE4\\uDF00-\\uDF35\\uDF40-\\uDF55\\uDF60-\\uDF72\\uDF80-\\uDF91]|\\uD803[\\uDC00-\\uDC48]|\\uD804[\\uDC03-\\uDC37\\uDC83-\\uDCAF\\uDCD0-\\uDCE8\\uDD03-\\uDD26\\uDD50-\\uDD72\\uDD76\\uDD83-\\uDDB2\\uDDC1-\\uDDC4\\uDDDA\\uDE00-\\uDE11\\uDE13-\\uDE2B\\uDEB0-\\uDEDE\\uDF05-\\uDF0C\\uDF0F\\uDF10\\uDF13-\\uDF28\\uDF2A-\\uDF30\\uDF32\\uDF33\\uDF35-\\uDF39\\uDF3D\\uDF5D-\\uDF61]|\\uD805[\\uDC80-\\uDCAF\\uDCC4\\uDCC5\\uDCC7\\uDD80-\\uDDAE\\uDE00-\\uDE2F\\uDE44\\uDE80-\\uDEAA]|\\uD806[\\uDCA0-\\uDCDF\\uDCFF\\uDEC0-\\uDEF8]|\\uD808[\\uDC00-\\uDF98]|\\uD809[\\uDC00-\\uDC6E]|[\\uD80C\\uD840-\\uD868\\uD86A-\\uD86C][\\uDC00-\\uDFFF]|\\uD80D[\\uDC00-\\uDC2E]|\\uD81A[\\uDC00-\\uDE38\\uDE40-\\uDE5E\\uDED0-\\uDEED\\uDF00-\\uDF2F\\uDF40-\\uDF43\\uDF63-\\uDF77\\uDF7D-\\uDF8F]|\\uD81B[\\uDF00-\\uDF44\\uDF50\\uDF93-\\uDF9F]|\\uD82C[\\uDC00\\uDC01]|\\uD82F[\\uDC00-\\uDC6A\\uDC70-\\uDC7C\\uDC80-\\uDC88\\uDC90-\\uDC99]|\\uD835[\\uDC00-\\uDC54\\uDC56-\\uDC9C\\uDC9E\\uDC9F\\uDCA2\\uDCA5\\uDCA6\\uDCA9-\\uDCAC\\uDCAE-\\uDCB9\\uDCBB\\uDCBD-\\uDCC3\\uDCC5-\\uDD05\\uDD07-\\uDD0A\\uDD0D-\\uDD14\\uDD16-\\uDD1C\\uDD1E-\\uDD39\\uDD3B-\\uDD3E\\uDD40-\\uDD44\\uDD46\\uDD4A-\\uDD50\\uDD52-\\uDEA5\\uDEA8-\\uDEC0\\uDEC2-\\uDEDA\\uDEDC-\\uDEFA\\uDEFC-\\uDF14\\uDF16-\\uDF34\\uDF36-\\uDF4E\\uDF50-\\uDF6E\\uDF70-\\uDF88\\uDF8A-\\uDFA8\\uDFAA-\\uDFC2\\uDFC4-\\uDFCB]|\\uD83A[\\uDC00-\\uDCC4]|\\uD83B[\\uDE00-\\uDE03\\uDE05-\\uDE1F\\uDE21\\uDE22\\uDE24\\uDE27\\uDE29-\\uDE32\\uDE34-\\uDE37\\uDE39\\uDE3B\\uDE42\\uDE47\\uDE49\\uDE4B\\uDE4D-\\uDE4F\\uDE51\\uDE52\\uDE54\\uDE57\\uDE59\\uDE5B\\uDE5D\\uDE5F\\uDE61\\uDE62\\uDE64\\uDE67-\\uDE6A\\uDE6C-\\uDE72\\uDE74-\\uDE77\\uDE79-\\uDE7C\\uDE7E\\uDE80-\\uDE89\\uDE8B-\\uDE9B\\uDEA1-\\uDEA3\\uDEA5-\\uDEA9\\uDEAB-\\uDEBB]|\\uD869[\\uDC00-\\uDED6\\uDF00-\\uDFFF]|\\uD86D[\\uDC00-\\uDF34\\uDF40-\\uDFFF]|\\uD86E[\\uDC00-\\uDC1D]|\\uD87E[\\uDC00-\\uDE1D]/,\n\n        // ECMAScript 6/Unicode v7.0.0 NonAsciiIdentifierPart:\n        NonAsciiIdentifierPart: /[\\xAA\\xB5\\xB7\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0300-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u0483-\\u0487\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0610-\\u061A\\u0620-\\u0669\\u066E-\\u06D3\\u06D5-\\u06DC\\u06DF-\\u06E8\\u06EA-\\u06FC\\u06FF\\u0710-\\u074A\\u074D-\\u07B1\\u07C0-\\u07F5\\u07FA\\u0800-\\u082D\\u0840-\\u085B\\u08A0-\\u08B2\\u08E4-\\u0963\\u0966-\\u096F\\u0971-\\u0983\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BC-\\u09C4\\u09C7\\u09C8\\u09CB-\\u09CE\\u09D7\\u09DC\\u09DD\\u09DF-\\u09E3\\u09E6-\\u09F1\\u0A01-\\u0A03\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A3C\\u0A3E-\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A59-\\u0A5C\\u0A5E\\u0A66-\\u0A75\\u0A81-\\u0A83\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABC-\\u0AC5\\u0AC7-\\u0AC9\\u0ACB-\\u0ACD\\u0AD0\\u0AE0-\\u0AE3\\u0AE6-\\u0AEF\\u0B01-\\u0B03\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3C-\\u0B44\\u0B47\\u0B48\\u0B4B-\\u0B4D\\u0B56\\u0B57\\u0B5C\\u0B5D\\u0B5F-\\u0B63\\u0B66-\\u0B6F\\u0B71\\u0B82\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BBE-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCD\\u0BD0\\u0BD7\\u0BE6-\\u0BEF\\u0C00-\\u0C03\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D-\\u0C44\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C58\\u0C59\\u0C60-\\u0C63\\u0C66-\\u0C6F\\u0C81-\\u0C83\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBC-\\u0CC4\\u0CC6-\\u0CC8\\u0CCA-\\u0CCD\\u0CD5\\u0CD6\\u0CDE\\u0CE0-\\u0CE3\\u0CE6-\\u0CEF\\u0CF1\\u0CF2\\u0D01-\\u0D03\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D-\\u0D44\\u0D46-\\u0D48\\u0D4A-\\u0D4E\\u0D57\\u0D60-\\u0D63\\u0D66-\\u0D6F\\u0D7A-\\u0D7F\\u0D82\\u0D83\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0DCA\\u0DCF-\\u0DD4\\u0DD6\\u0DD8-\\u0DDF\\u0DE6-\\u0DEF\\u0DF2\\u0DF3\\u0E01-\\u0E3A\\u0E40-\\u0E4E\\u0E50-\\u0E59\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB9\\u0EBB-\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EC8-\\u0ECD\\u0ED0-\\u0ED9\\u0EDC-\\u0EDF\\u0F00\\u0F18\\u0F19\\u0F20-\\u0F29\\u0F35\\u0F37\\u0F39\\u0F3E-\\u0F47\\u0F49-\\u0F6C\\u0F71-\\u0F84\\u0F86-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u1000-\\u1049\\u1050-\\u109D\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u135D-\\u135F\\u1369-\\u1371\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1714\\u1720-\\u1734\\u1740-\\u1753\\u1760-\\u176C\\u176E-\\u1770\\u1772\\u1773\\u1780-\\u17D3\\u17D7\\u17DC\\u17DD\\u17E0-\\u17E9\\u180B-\\u180D\\u1810-\\u1819\\u1820-\\u1877\\u1880-\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1920-\\u192B\\u1930-\\u193B\\u1946-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u19D0-\\u19DA\\u1A00-\\u1A1B\\u1A20-\\u1A5E\\u1A60-\\u1A7C\\u1A7F-\\u1A89\\u1A90-\\u1A99\\u1AA7\\u1AB0-\\u1ABD\\u1B00-\\u1B4B\\u1B50-\\u1B59\\u1B6B-\\u1B73\\u1B80-\\u1BF3\\u1C00-\\u1C37\\u1C40-\\u1C49\\u1C4D-\\u1C7D\\u1CD0-\\u1CD2\\u1CD4-\\u1CF6\\u1CF8\\u1CF9\\u1D00-\\u1DF5\\u1DFC-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u200C\\u200D\\u203F\\u2040\\u2054\\u2071\\u207F\\u2090-\\u209C\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2118-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D7F-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2DE0-\\u2DFF\\u3005-\\u3007\\u3021-\\u302F\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u3099-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA62B\\uA640-\\uA66F\\uA674-\\uA67D\\uA67F-\\uA69D\\uA69F-\\uA6F1\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA7AD\\uA7B0\\uA7B1\\uA7F7-\\uA827\\uA840-\\uA873\\uA880-\\uA8C4\\uA8D0-\\uA8D9\\uA8E0-\\uA8F7\\uA8FB\\uA900-\\uA92D\\uA930-\\uA953\\uA960-\\uA97C\\uA980-\\uA9C0\\uA9CF-\\uA9D9\\uA9E0-\\uA9FE\\uAA00-\\uAA36\\uAA40-\\uAA4D\\uAA50-\\uAA59\\uAA60-\\uAA76\\uAA7A-\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEF\\uAAF2-\\uAAF6\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB5F\\uAB64\\uAB65\\uABC0-\\uABEA\\uABEC\\uABED\\uABF0-\\uABF9\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE00-\\uFE0F\\uFE20-\\uFE2D\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF10-\\uFF19\\uFF21-\\uFF3A\\uFF3F\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]|\\uD800[\\uDC00-\\uDC0B\\uDC0D-\\uDC26\\uDC28-\\uDC3A\\uDC3C\\uDC3D\\uDC3F-\\uDC4D\\uDC50-\\uDC5D\\uDC80-\\uDCFA\\uDD40-\\uDD74\\uDDFD\\uDE80-\\uDE9C\\uDEA0-\\uDED0\\uDEE0\\uDF00-\\uDF1F\\uDF30-\\uDF4A\\uDF50-\\uDF7A\\uDF80-\\uDF9D\\uDFA0-\\uDFC3\\uDFC8-\\uDFCF\\uDFD1-\\uDFD5]|\\uD801[\\uDC00-\\uDC9D\\uDCA0-\\uDCA9\\uDD00-\\uDD27\\uDD30-\\uDD63\\uDE00-\\uDF36\\uDF40-\\uDF55\\uDF60-\\uDF67]|\\uD802[\\uDC00-\\uDC05\\uDC08\\uDC0A-\\uDC35\\uDC37\\uDC38\\uDC3C\\uDC3F-\\uDC55\\uDC60-\\uDC76\\uDC80-\\uDC9E\\uDD00-\\uDD15\\uDD20-\\uDD39\\uDD80-\\uDDB7\\uDDBE\\uDDBF\\uDE00-\\uDE03\\uDE05\\uDE06\\uDE0C-\\uDE13\\uDE15-\\uDE17\\uDE19-\\uDE33\\uDE38-\\uDE3A\\uDE3F\\uDE60-\\uDE7C\\uDE80-\\uDE9C\\uDEC0-\\uDEC7\\uDEC9-\\uDEE6\\uDF00-\\uDF35\\uDF40-\\uDF55\\uDF60-\\uDF72\\uDF80-\\uDF91]|\\uD803[\\uDC00-\\uDC48]|\\uD804[\\uDC00-\\uDC46\\uDC66-\\uDC6F\\uDC7F-\\uDCBA\\uDCD0-\\uDCE8\\uDCF0-\\uDCF9\\uDD00-\\uDD34\\uDD36-\\uDD3F\\uDD50-\\uDD73\\uDD76\\uDD80-\\uDDC4\\uDDD0-\\uDDDA\\uDE00-\\uDE11\\uDE13-\\uDE37\\uDEB0-\\uDEEA\\uDEF0-\\uDEF9\\uDF01-\\uDF03\\uDF05-\\uDF0C\\uDF0F\\uDF10\\uDF13-\\uDF28\\uDF2A-\\uDF30\\uDF32\\uDF33\\uDF35-\\uDF39\\uDF3C-\\uDF44\\uDF47\\uDF48\\uDF4B-\\uDF4D\\uDF57\\uDF5D-\\uDF63\\uDF66-\\uDF6C\\uDF70-\\uDF74]|\\uD805[\\uDC80-\\uDCC5\\uDCC7\\uDCD0-\\uDCD9\\uDD80-\\uDDB5\\uDDB8-\\uDDC0\\uDE00-\\uDE40\\uDE44\\uDE50-\\uDE59\\uDE80-\\uDEB7\\uDEC0-\\uDEC9]|\\uD806[\\uDCA0-\\uDCE9\\uDCFF\\uDEC0-\\uDEF8]|\\uD808[\\uDC00-\\uDF98]|\\uD809[\\uDC00-\\uDC6E]|[\\uD80C\\uD840-\\uD868\\uD86A-\\uD86C][\\uDC00-\\uDFFF]|\\uD80D[\\uDC00-\\uDC2E]|\\uD81A[\\uDC00-\\uDE38\\uDE40-\\uDE5E\\uDE60-\\uDE69\\uDED0-\\uDEED\\uDEF0-\\uDEF4\\uDF00-\\uDF36\\uDF40-\\uDF43\\uDF50-\\uDF59\\uDF63-\\uDF77\\uDF7D-\\uDF8F]|\\uD81B[\\uDF00-\\uDF44\\uDF50-\\uDF7E\\uDF8F-\\uDF9F]|\\uD82C[\\uDC00\\uDC01]|\\uD82F[\\uDC00-\\uDC6A\\uDC70-\\uDC7C\\uDC80-\\uDC88\\uDC90-\\uDC99\\uDC9D\\uDC9E]|\\uD834[\\uDD65-\\uDD69\\uDD6D-\\uDD72\\uDD7B-\\uDD82\\uDD85-\\uDD8B\\uDDAA-\\uDDAD\\uDE42-\\uDE44]|\\uD835[\\uDC00-\\uDC54\\uDC56-\\uDC9C\\uDC9E\\uDC9F\\uDCA2\\uDCA5\\uDCA6\\uDCA9-\\uDCAC\\uDCAE-\\uDCB9\\uDCBB\\uDCBD-\\uDCC3\\uDCC5-\\uDD05\\uDD07-\\uDD0A\\uDD0D-\\uDD14\\uDD16-\\uDD1C\\uDD1E-\\uDD39\\uDD3B-\\uDD3E\\uDD40-\\uDD44\\uDD46\\uDD4A-\\uDD50\\uDD52-\\uDEA5\\uDEA8-\\uDEC0\\uDEC2-\\uDEDA\\uDEDC-\\uDEFA\\uDEFC-\\uDF14\\uDF16-\\uDF34\\uDF36-\\uDF4E\\uDF50-\\uDF6E\\uDF70-\\uDF88\\uDF8A-\\uDFA8\\uDFAA-\\uDFC2\\uDFC4-\\uDFCB\\uDFCE-\\uDFFF]|\\uD83A[\\uDC00-\\uDCC4\\uDCD0-\\uDCD6]|\\uD83B[\\uDE00-\\uDE03\\uDE05-\\uDE1F\\uDE21\\uDE22\\uDE24\\uDE27\\uDE29-\\uDE32\\uDE34-\\uDE37\\uDE39\\uDE3B\\uDE42\\uDE47\\uDE49\\uDE4B\\uDE4D-\\uDE4F\\uDE51\\uDE52\\uDE54\\uDE57\\uDE59\\uDE5B\\uDE5D\\uDE5F\\uDE61\\uDE62\\uDE64\\uDE67-\\uDE6A\\uDE6C-\\uDE72\\uDE74-\\uDE77\\uDE79-\\uDE7C\\uDE7E\\uDE80-\\uDE89\\uDE8B-\\uDE9B\\uDEA1-\\uDEA3\\uDEA5-\\uDEA9\\uDEAB-\\uDEBB]|\\uD869[\\uDC00-\\uDED6\\uDF00-\\uDFFF]|\\uD86D[\\uDC00-\\uDF34\\uDF40-\\uDFFF]|\\uD86E[\\uDC00-\\uDC1D]|\\uD87E[\\uDC00-\\uDE1D]|\\uDB40[\\uDD00-\\uDDEF]/\n    };\n\n    // Ensure the condition is true, otherwise throw an error.\n    // This is only to have a better contract semantic, i.e. another safety net\n    // to catch a logic error. The condition shall be fulfilled in normal case.\n    // Do NOT use this to enforce a certain condition on any user input.\n\n    function assert(condition, message) {\n        /* istanbul ignore if */\n        if (!condition) {\n            throw new Error('ASSERT: ' + message);\n        }\n    }\n\n    function isDecimalDigit(ch) {\n        return (ch >= 0x30 && ch <= 0x39);   // 0..9\n    }\n\n    function isHexDigit(ch) {\n        return '0123456789abcdefABCDEF'.indexOf(ch) >= 0;\n    }\n\n    function isOctalDigit(ch) {\n        return '01234567'.indexOf(ch) >= 0;\n    }\n\n    function octalToDecimal(ch) {\n        // \\0 is not octal escape sequence\n        var octal = (ch !== '0'), code = '01234567'.indexOf(ch);\n\n        if (index < length && isOctalDigit(source[index])) {\n            octal = true;\n            code = code * 8 + '01234567'.indexOf(source[index++]);\n\n            // 3 digits are only allowed when string starts\n            // with 0, 1, 2, 3\n            if ('0123'.indexOf(ch) >= 0 &&\n                    index < length &&\n                    isOctalDigit(source[index])) {\n                code = code * 8 + '01234567'.indexOf(source[index++]);\n            }\n        }\n\n        return {\n            code: code,\n            octal: octal\n        };\n    }\n\n    // ECMA-262 11.2 White Space\n\n    function isWhiteSpace(ch) {\n        return (ch === 0x20) || (ch === 0x09) || (ch === 0x0B) || (ch === 0x0C) || (ch === 0xA0) ||\n            (ch >= 0x1680 && [0x1680, 0x180E, 0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200A, 0x202F, 0x205F, 0x3000, 0xFEFF].indexOf(ch) >= 0);\n    }\n\n    // ECMA-262 11.3 Line Terminators\n\n    function isLineTerminator(ch) {\n        return (ch === 0x0A) || (ch === 0x0D) || (ch === 0x2028) || (ch === 0x2029);\n    }\n\n    // ECMA-262 11.6 Identifier Names and Identifiers\n\n    function fromCodePoint(cp) {\n        return (cp < 0x10000) ? String.fromCharCode(cp) :\n            String.fromCharCode(0xD800 + ((cp - 0x10000) >> 10)) +\n            String.fromCharCode(0xDC00 + ((cp - 0x10000) & 1023));\n    }\n\n    function isIdentifierStart(ch) {\n        return (ch === 0x24) || (ch === 0x5F) ||  // $ (dollar) and _ (underscore)\n            (ch >= 0x41 && ch <= 0x5A) ||         // A..Z\n            (ch >= 0x61 && ch <= 0x7A) ||         // a..z\n            (ch === 0x5C) ||                      // \\ (backslash)\n            ((ch >= 0x80) && Regex.NonAsciiIdentifierStart.test(fromCodePoint(ch)));\n    }\n\n    function isIdentifierPart(ch) {\n        return (ch === 0x24) || (ch === 0x5F) ||  // $ (dollar) and _ (underscore)\n            (ch >= 0x41 && ch <= 0x5A) ||         // A..Z\n            (ch >= 0x61 && ch <= 0x7A) ||         // a..z\n            (ch >= 0x30 && ch <= 0x39) ||         // 0..9\n            (ch === 0x5C) ||                      // \\ (backslash)\n            ((ch >= 0x80) && Regex.NonAsciiIdentifierPart.test(fromCodePoint(ch)));\n    }\n\n    // ECMA-262 11.6.2.2 Future Reserved Words\n\n    function isFutureReservedWord(id) {\n        switch (id) {\n        case 'enum':\n        case 'export':\n        case 'import':\n        case 'super':\n            return true;\n        default:\n            return false;\n        }\n    }\n\n    function isStrictModeReservedWord(id) {\n        switch (id) {\n        case 'implements':\n        case 'interface':\n        case 'package':\n        case 'private':\n        case 'protected':\n        case 'public':\n        case 'static':\n        case 'yield':\n        case 'let':\n            return true;\n        default:\n            return false;\n        }\n    }\n\n    function isRestrictedWord(id) {\n        return id === 'eval' || id === 'arguments';\n    }\n\n    // ECMA-262 11.6.2.1 Keywords\n\n    function isKeyword(id) {\n        switch (id.length) {\n        case 2:\n            return (id === 'if') || (id === 'in') || (id === 'do');\n        case 3:\n            return (id === 'var') || (id === 'for') || (id === 'new') ||\n                (id === 'try') || (id === 'let');\n        case 4:\n            return (id === 'this') || (id === 'else') || (id === 'case') ||\n                (id === 'void') || (id === 'with') || (id === 'enum');\n        case 5:\n            return (id === 'while') || (id === 'break') || (id === 'catch') ||\n                (id === 'throw') || (id === 'const') || (id === 'yield') ||\n                (id === 'class') || (id === 'super');\n        case 6:\n            return (id === 'return') || (id === 'typeof') || (id === 'delete') ||\n                (id === 'switch') || (id === 'export') || (id === 'import');\n        case 7:\n            return (id === 'default') || (id === 'finally') || (id === 'extends');\n        case 8:\n            return (id === 'function') || (id === 'continue') || (id === 'debugger');\n        case 10:\n            return (id === 'instanceof');\n        default:\n            return false;\n        }\n    }\n\n    // ECMA-262 11.4 Comments\n\n    function addComment(type, value, start, end, loc) {\n        var comment;\n\n        assert(typeof start === 'number', 'Comment must have valid position');\n\n        state.lastCommentStart = start;\n\n        comment = {\n            type: type,\n            value: value\n        };\n        if (extra.range) {\n            comment.range = [start, end];\n        }\n        if (extra.loc) {\n            comment.loc = loc;\n        }\n        extra.comments.push(comment);\n        if (extra.attachComment) {\n            extra.leadingComments.push(comment);\n            extra.trailingComments.push(comment);\n        }\n        if (extra.tokenize) {\n            comment.type = comment.type + 'Comment';\n            if (extra.delegate) {\n                comment = extra.delegate(comment);\n            }\n            extra.tokens.push(comment);\n        }\n    }\n\n    function skipSingleLineComment(offset) {\n        var start, loc, ch, comment;\n\n        start = index - offset;\n        loc = {\n            start: {\n                line: lineNumber,\n                column: index - lineStart - offset\n            }\n        };\n\n        while (index < length) {\n            ch = source.charCodeAt(index);\n            ++index;\n            if (isLineTerminator(ch)) {\n                hasLineTerminator = true;\n                if (extra.comments) {\n                    comment = source.slice(start + offset, index - 1);\n                    loc.end = {\n                        line: lineNumber,\n                        column: index - lineStart - 1\n                    };\n                    addComment('Line', comment, start, index - 1, loc);\n                }\n                if (ch === 13 && source.charCodeAt(index) === 10) {\n                    ++index;\n                }\n                ++lineNumber;\n                lineStart = index;\n                return;\n            }\n        }\n\n        if (extra.comments) {\n            comment = source.slice(start + offset, index);\n            loc.end = {\n                line: lineNumber,\n                column: index - lineStart\n            };\n            addComment('Line', comment, start, index, loc);\n        }\n    }\n\n    function skipMultiLineComment() {\n        var start, loc, ch, comment;\n\n        if (extra.comments) {\n            start = index - 2;\n            loc = {\n                start: {\n                    line: lineNumber,\n                    column: index - lineStart - 2\n                }\n            };\n        }\n\n        while (index < length) {\n            ch = source.charCodeAt(index);\n            if (isLineTerminator(ch)) {\n                if (ch === 0x0D && source.charCodeAt(index + 1) === 0x0A) {\n                    ++index;\n                }\n                hasLineTerminator = true;\n                ++lineNumber;\n                ++index;\n                lineStart = index;\n            } else if (ch === 0x2A) {\n                // Block comment ends with '*/'.\n                if (source.charCodeAt(index + 1) === 0x2F) {\n                    ++index;\n                    ++index;\n                    if (extra.comments) {\n                        comment = source.slice(start + 2, index - 2);\n                        loc.end = {\n                            line: lineNumber,\n                            column: index - lineStart\n                        };\n                        addComment('Block', comment, start, index, loc);\n                    }\n                    return;\n                }\n                ++index;\n            } else {\n                ++index;\n            }\n        }\n\n        // Ran off the end of the file - the whole thing is a comment\n        if (extra.comments) {\n            loc.end = {\n                line: lineNumber,\n                column: index - lineStart\n            };\n            comment = source.slice(start + 2, index);\n            addComment('Block', comment, start, index, loc);\n        }\n        tolerateUnexpectedToken();\n    }\n\n    function skipComment() {\n        var ch, start;\n        hasLineTerminator = false;\n\n        start = (index === 0);\n        while (index < length) {\n            ch = source.charCodeAt(index);\n\n            if (isWhiteSpace(ch)) {\n                ++index;\n            } else if (isLineTerminator(ch)) {\n                hasLineTerminator = true;\n                ++index;\n                if (ch === 0x0D && source.charCodeAt(index) === 0x0A) {\n                    ++index;\n                }\n                ++lineNumber;\n                lineStart = index;\n                start = true;\n            } else if (ch === 0x2F) { // U+002F is '/'\n                ch = source.charCodeAt(index + 1);\n                if (ch === 0x2F) {\n                    ++index;\n                    ++index;\n                    skipSingleLineComment(2);\n                    start = true;\n                } else if (ch === 0x2A) {  // U+002A is '*'\n                    ++index;\n                    ++index;\n                    skipMultiLineComment();\n                } else {\n                    break;\n                }\n            } else if (start && ch === 0x2D) { // U+002D is '-'\n                // U+003E is '>'\n                if ((source.charCodeAt(index + 1) === 0x2D) && (source.charCodeAt(index + 2) === 0x3E)) {\n                    // '-->' is a single-line comment\n                    index += 3;\n                    skipSingleLineComment(3);\n                } else {\n                    break;\n                }\n            } else if (ch === 0x3C) { // U+003C is '<'\n                if (source.slice(index + 1, index + 4) === '!--') {\n                    ++index; // `<`\n                    ++index; // `!`\n                    ++index; // `-`\n                    ++index; // `-`\n                    skipSingleLineComment(4);\n                } else {\n                    break;\n                }\n            } else {\n                break;\n            }\n        }\n    }\n\n    function scanHexEscape(prefix) {\n        var i, len, ch, code = 0;\n\n        len = (prefix === 'u') ? 4 : 2;\n        for (i = 0; i < len; ++i) {\n            if (index < length && isHexDigit(source[index])) {\n                ch = source[index++];\n                code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());\n            } else {\n                return '';\n            }\n        }\n        return String.fromCharCode(code);\n    }\n\n    function scanUnicodeCodePointEscape() {\n        var ch, code;\n\n        ch = source[index];\n        code = 0;\n\n        // At least, one hex digit is required.\n        if (ch === '}') {\n            throwUnexpectedToken();\n        }\n\n        while (index < length) {\n            ch = source[index++];\n            if (!isHexDigit(ch)) {\n                break;\n            }\n            code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());\n        }\n\n        if (code > 0x10FFFF || ch !== '}') {\n            throwUnexpectedToken();\n        }\n\n        return fromCodePoint(code);\n    }\n\n    function codePointAt(i) {\n        var cp, first, second;\n\n        cp = source.charCodeAt(i);\n        if (cp >= 0xD800 && cp <= 0xDBFF) {\n            second = source.charCodeAt(i + 1);\n            if (second >= 0xDC00 && second <= 0xDFFF) {\n                first = cp;\n                cp = (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;\n            }\n        }\n\n        return cp;\n    }\n\n    function getComplexIdentifier() {\n        var cp, ch, id;\n\n        cp = codePointAt(index);\n        id = fromCodePoint(cp);\n        index += id.length;\n\n        // '\\u' (U+005C, U+0075) denotes an escaped character.\n        if (cp === 0x5C) {\n            if (source.charCodeAt(index) !== 0x75) {\n                throwUnexpectedToken();\n            }\n            ++index;\n            if (source[index] === '{') {\n                ++index;\n                ch = scanUnicodeCodePointEscape();\n            } else {\n                ch = scanHexEscape('u');\n                cp = ch.charCodeAt(0);\n                if (!ch || ch === '\\\\' || !isIdentifierStart(cp)) {\n                    throwUnexpectedToken();\n                }\n            }\n            id = ch;\n        }\n\n        while (index < length) {\n            cp = codePointAt(index);\n            if (!isIdentifierPart(cp)) {\n                break;\n            }\n            ch = fromCodePoint(cp);\n            id += ch;\n            index += ch.length;\n\n            // '\\u' (U+005C, U+0075) denotes an escaped character.\n            if (cp === 0x5C) {\n                id = id.substr(0, id.length - 1);\n                if (source.charCodeAt(index) !== 0x75) {\n                    throwUnexpectedToken();\n                }\n                ++index;\n                if (source[index] === '{') {\n                    ++index;\n                    ch = scanUnicodeCodePointEscape();\n                } else {\n                    ch = scanHexEscape('u');\n                    cp = ch.charCodeAt(0);\n                    if (!ch || ch === '\\\\' || !isIdentifierPart(cp)) {\n                        throwUnexpectedToken();\n                    }\n                }\n                id += ch;\n            }\n        }\n\n        return id;\n    }\n\n    function getIdentifier() {\n        var start, ch;\n\n        start = index++;\n        while (index < length) {\n            ch = source.charCodeAt(index);\n            if (ch === 0x5C) {\n                // Blackslash (U+005C) marks Unicode escape sequence.\n                index = start;\n                return getComplexIdentifier();\n            } else if (ch >= 0xD800 && ch < 0xDFFF) {\n                // Need to handle surrogate pairs.\n                index = start;\n                return getComplexIdentifier();\n            }\n            if (isIdentifierPart(ch)) {\n                ++index;\n            } else {\n                break;\n            }\n        }\n\n        return source.slice(start, index);\n    }\n\n    function scanIdentifier() {\n        var start, id, type;\n\n        start = index;\n\n        // Backslash (U+005C) starts an escaped character.\n        id = (source.charCodeAt(index) === 0x5C) ? getComplexIdentifier() : getIdentifier();\n\n        // There is no keyword or literal with only one character.\n        // Thus, it must be an identifier.\n        if (id.length === 1) {\n            type = Token.Identifier;\n        } else if (isKeyword(id)) {\n            type = Token.Keyword;\n        } else if (id === 'null') {\n            type = Token.NullLiteral;\n        } else if (id === 'true' || id === 'false') {\n            type = Token.BooleanLiteral;\n        } else {\n            type = Token.Identifier;\n        }\n\n        return {\n            type: type,\n            value: id,\n            lineNumber: lineNumber,\n            lineStart: lineStart,\n            start: start,\n            end: index\n        };\n    }\n\n\n    // ECMA-262 11.7 Punctuators\n\n    function scanPunctuator() {\n        var token, str;\n\n        token = {\n            type: Token.Punctuator,\n            value: '',\n            lineNumber: lineNumber,\n            lineStart: lineStart,\n            start: index,\n            end: index\n        };\n\n        // Check for most common single-character punctuators.\n        str = source[index];\n        switch (str) {\n\n        case '(':\n            if (extra.tokenize) {\n                extra.openParenToken = extra.tokenValues.length;\n            }\n            ++index;\n            break;\n\n        case '{':\n            if (extra.tokenize) {\n                extra.openCurlyToken = extra.tokenValues.length;\n            }\n            state.curlyStack.push('{');\n            ++index;\n            break;\n\n        case '.':\n            ++index;\n            if (source[index] === '.' && source[index + 1] === '.') {\n                // Spread operator: ...\n                index += 2;\n                str = '...';\n            }\n            break;\n\n        case '}':\n            ++index;\n            state.curlyStack.pop();\n            break;\n        case ')':\n        case ';':\n        case ',':\n        case '[':\n        case ']':\n        case ':':\n        case '?':\n        case '~':\n            ++index;\n            break;\n\n        default:\n            // 4-character punctuator.\n            str = source.substr(index, 4);\n            if (str === '>>>=') {\n                index += 4;\n            } else {\n\n                // 3-character punctuators.\n                str = str.substr(0, 3);\n                if (str === '===' || str === '!==' || str === '>>>' ||\n                    str === '<<=' || str === '>>=') {\n                    index += 3;\n                } else {\n\n                    // 2-character punctuators.\n                    str = str.substr(0, 2);\n                    if (str === '&&' || str === '||' || str === '==' || str === '!=' ||\n                        str === '+=' || str === '-=' || str === '*=' || str === '/=' ||\n                        str === '++' || str === '--' || str === '<<' || str === '>>' ||\n                        str === '&=' || str === '|=' || str === '^=' || str === '%=' ||\n                        str === '<=' || str === '>=' || str === '=>') {\n                        index += 2;\n                    } else {\n\n                        // 1-character punctuators.\n                        str = source[index];\n                        if ('<>=!+-*%&|^/'.indexOf(str) >= 0) {\n                            ++index;\n                        }\n                    }\n                }\n            }\n        }\n\n        if (index === token.start) {\n            throwUnexpectedToken();\n        }\n\n        token.end = index;\n        token.value = str;\n        return token;\n    }\n\n    // ECMA-262 11.8.3 Numeric Literals\n\n    function scanHexLiteral(start) {\n        var number = '';\n\n        while (index < length) {\n            if (!isHexDigit(source[index])) {\n                break;\n            }\n            number += source[index++];\n        }\n\n        if (number.length === 0) {\n            throwUnexpectedToken();\n        }\n\n        if (isIdentifierStart(source.charCodeAt(index))) {\n            throwUnexpectedToken();\n        }\n\n        return {\n            type: Token.NumericLiteral,\n            value: parseInt('0x' + number, 16),\n            lineNumber: lineNumber,\n            lineStart: lineStart,\n            start: start,\n            end: index\n        };\n    }\n\n    function scanBinaryLiteral(start) {\n        var ch, number;\n\n        number = '';\n\n        while (index < length) {\n            ch = source[index];\n            if (ch !== '0' && ch !== '1') {\n                break;\n            }\n            number += source[index++];\n        }\n\n        if (number.length === 0) {\n            // only 0b or 0B\n            throwUnexpectedToken();\n        }\n\n        if (index < length) {\n            ch = source.charCodeAt(index);\n            /* istanbul ignore else */\n            if (isIdentifierStart(ch) || isDecimalDigit(ch)) {\n                throwUnexpectedToken();\n            }\n        }\n\n        return {\n            type: Token.NumericLiteral,\n            value: parseInt(number, 2),\n            lineNumber: lineNumber,\n            lineStart: lineStart,\n            start: start,\n            end: index\n        };\n    }\n\n    function scanOctalLiteral(prefix, start) {\n        var number, octal;\n\n        if (isOctalDigit(prefix)) {\n            octal = true;\n            number = '0' + source[index++];\n        } else {\n            octal = false;\n            ++index;\n            number = '';\n        }\n\n        while (index < length) {\n            if (!isOctalDigit(source[index])) {\n                break;\n            }\n            number += source[index++];\n        }\n\n        if (!octal && number.length === 0) {\n            // only 0o or 0O\n            throwUnexpectedToken();\n        }\n\n        if (isIdentifierStart(source.charCodeAt(index)) || isDecimalDigit(source.charCodeAt(index))) {\n            throwUnexpectedToken();\n        }\n\n        return {\n            type: Token.NumericLiteral,\n            value: parseInt(number, 8),\n            octal: octal,\n            lineNumber: lineNumber,\n            lineStart: lineStart,\n            start: start,\n            end: index\n        };\n    }\n\n    function isImplicitOctalLiteral() {\n        var i, ch;\n\n        // Implicit octal, unless there is a non-octal digit.\n        // (Annex B.1.1 on Numeric Literals)\n        for (i = index + 1; i < length; ++i) {\n            ch = source[i];\n            if (ch === '8' || ch === '9') {\n                return false;\n            }\n            if (!isOctalDigit(ch)) {\n                return true;\n            }\n        }\n\n        return true;\n    }\n\n    function scanNumericLiteral() {\n        var number, start, ch;\n\n        ch = source[index];\n        assert(isDecimalDigit(ch.charCodeAt(0)) || (ch === '.'),\n            'Numeric literal must start with a decimal digit or a decimal point');\n\n        start = index;\n        number = '';\n        if (ch !== '.') {\n            number = source[index++];\n            ch = source[index];\n\n            // Hex number starts with '0x'.\n            // Octal number starts with '0'.\n            // Octal number in ES6 starts with '0o'.\n            // Binary number in ES6 starts with '0b'.\n            if (number === '0') {\n                if (ch === 'x' || ch === 'X') {\n                    ++index;\n                    return scanHexLiteral(start);\n                }\n                if (ch === 'b' || ch === 'B') {\n                    ++index;\n                    return scanBinaryLiteral(start);\n                }\n                if (ch === 'o' || ch === 'O') {\n                    return scanOctalLiteral(ch, start);\n                }\n\n                if (isOctalDigit(ch)) {\n                    if (isImplicitOctalLiteral()) {\n                        return scanOctalLiteral(ch, start);\n                    }\n                }\n            }\n\n            while (isDecimalDigit(source.charCodeAt(index))) {\n                number += source[index++];\n            }\n            ch = source[index];\n        }\n\n        if (ch === '.') {\n            number += source[index++];\n            while (isDecimalDigit(source.charCodeAt(index))) {\n                number += source[index++];\n            }\n            ch = source[index];\n        }\n\n        if (ch === 'e' || ch === 'E') {\n            number += source[index++];\n\n            ch = source[index];\n            if (ch === '+' || ch === '-') {\n                number += source[index++];\n            }\n            if (isDecimalDigit(source.charCodeAt(index))) {\n                while (isDecimalDigit(source.charCodeAt(index))) {\n                    number += source[index++];\n                }\n            } else {\n                throwUnexpectedToken();\n            }\n        }\n\n        if (isIdentifierStart(source.charCodeAt(index))) {\n            throwUnexpectedToken();\n        }\n\n        return {\n            type: Token.NumericLiteral,\n            value: parseFloat(number),\n            lineNumber: lineNumber,\n            lineStart: lineStart,\n            start: start,\n            end: index\n        };\n    }\n\n    // ECMA-262 11.8.4 String Literals\n\n    function scanStringLiteral() {\n        var str = '', quote, start, ch, unescaped, octToDec, octal = false;\n\n        quote = source[index];\n        assert((quote === '\\'' || quote === '\"'),\n            'String literal must starts with a quote');\n\n        start = index;\n        ++index;\n\n        while (index < length) {\n            ch = source[index++];\n\n            if (ch === quote) {\n                quote = '';\n                break;\n            } else if (ch === '\\\\') {\n                ch = source[index++];\n                if (!ch || !isLineTerminator(ch.charCodeAt(0))) {\n                    switch (ch) {\n                    case 'u':\n                    case 'x':\n                        if (source[index] === '{') {\n                            ++index;\n                            str += scanUnicodeCodePointEscape();\n                        } else {\n                            unescaped = scanHexEscape(ch);\n                            if (!unescaped) {\n                                throw throwUnexpectedToken();\n                            }\n                            str += unescaped;\n                        }\n                        break;\n                    case 'n':\n                        str += '\\n';\n                        break;\n                    case 'r':\n                        str += '\\r';\n                        break;\n                    case 't':\n                        str += '\\t';\n                        break;\n                    case 'b':\n                        str += '\\b';\n                        break;\n                    case 'f':\n                        str += '\\f';\n                        break;\n                    case 'v':\n                        str += '\\x0B';\n                        break;\n                    case '8':\n                    case '9':\n                        str += ch;\n                        tolerateUnexpectedToken();\n                        break;\n\n                    default:\n                        if (isOctalDigit(ch)) {\n                            octToDec = octalToDecimal(ch);\n\n                            octal = octToDec.octal || octal;\n                            str += String.fromCharCode(octToDec.code);\n                        } else {\n                            str += ch;\n                        }\n                        break;\n                    }\n                } else {\n                    ++lineNumber;\n                    if (ch === '\\r' && source[index] === '\\n') {\n                        ++index;\n                    }\n                    lineStart = index;\n                }\n            } else if (isLineTerminator(ch.charCodeAt(0))) {\n                break;\n            } else {\n                str += ch;\n            }\n        }\n\n        if (quote !== '') {\n            index = start;\n            throwUnexpectedToken();\n        }\n\n        return {\n            type: Token.StringLiteral,\n            value: str,\n            octal: octal,\n            lineNumber: startLineNumber,\n            lineStart: startLineStart,\n            start: start,\n            end: index\n        };\n    }\n\n    // ECMA-262 11.8.6 Template Literal Lexical Components\n\n    function scanTemplate() {\n        var cooked = '', ch, start, rawOffset, terminated, head, tail, restore, unescaped;\n\n        terminated = false;\n        tail = false;\n        start = index;\n        head = (source[index] === '`');\n        rawOffset = 2;\n\n        ++index;\n\n        while (index < length) {\n            ch = source[index++];\n            if (ch === '`') {\n                rawOffset = 1;\n                tail = true;\n                terminated = true;\n                break;\n            } else if (ch === '$') {\n                if (source[index] === '{') {\n                    state.curlyStack.push('${');\n                    ++index;\n                    terminated = true;\n                    break;\n                }\n                cooked += ch;\n            } else if (ch === '\\\\') {\n                ch = source[index++];\n                if (!isLineTerminator(ch.charCodeAt(0))) {\n                    switch (ch) {\n                    case 'n':\n                        cooked += '\\n';\n                        break;\n                    case 'r':\n                        cooked += '\\r';\n                        break;\n                    case 't':\n                        cooked += '\\t';\n                        break;\n                    case 'u':\n                    case 'x':\n                        if (source[index] === '{') {\n                            ++index;\n                            cooked += scanUnicodeCodePointEscape();\n                        } else {\n                            restore = index;\n                            unescaped = scanHexEscape(ch);\n                            if (unescaped) {\n                                cooked += unescaped;\n                            } else {\n                                index = restore;\n                                cooked += ch;\n                            }\n                        }\n                        break;\n                    case 'b':\n                        cooked += '\\b';\n                        break;\n                    case 'f':\n                        cooked += '\\f';\n                        break;\n                    case 'v':\n                        cooked += '\\v';\n                        break;\n\n                    default:\n                        if (ch === '0') {\n                            if (isDecimalDigit(source.charCodeAt(index))) {\n                                // Illegal: \\01 \\02 and so on\n                                throwError(Messages.TemplateOctalLiteral);\n                            }\n                            cooked += '\\0';\n                        } else if (isOctalDigit(ch)) {\n                            // Illegal: \\1 \\2\n                            throwError(Messages.TemplateOctalLiteral);\n                        } else {\n                            cooked += ch;\n                        }\n                        break;\n                    }\n                } else {\n                    ++lineNumber;\n                    if (ch === '\\r' && source[index] === '\\n') {\n                        ++index;\n                    }\n                    lineStart = index;\n                }\n            } else if (isLineTerminator(ch.charCodeAt(0))) {\n                ++lineNumber;\n                if (ch === '\\r' && source[index] === '\\n') {\n                    ++index;\n                }\n                lineStart = index;\n                cooked += '\\n';\n            } else {\n                cooked += ch;\n            }\n        }\n\n        if (!terminated) {\n            throwUnexpectedToken();\n        }\n\n        if (!head) {\n            state.curlyStack.pop();\n        }\n\n        return {\n            type: Token.Template,\n            value: {\n                cooked: cooked,\n                raw: source.slice(start + 1, index - rawOffset)\n            },\n            head: head,\n            tail: tail,\n            lineNumber: lineNumber,\n            lineStart: lineStart,\n            start: start,\n            end: index\n        };\n    }\n\n    // ECMA-262 11.8.5 Regular Expression Literals\n\n    function testRegExp(pattern, flags) {\n        // The BMP character to use as a replacement for astral symbols when\n        // translating an ES6 \"u\"-flagged pattern to an ES5-compatible\n        // approximation.\n        // Note: replacing with '\\uFFFF' enables false positives in unlikely\n        // scenarios. For example, `[\\u{1044f}-\\u{10440}]` is an invalid\n        // pattern that would not be detected by this substitution.\n        var astralSubstitute = '\\uFFFF',\n            tmp = pattern;\n\n        if (flags.indexOf('u') >= 0) {\n            tmp = tmp\n                // Replace every Unicode escape sequence with the equivalent\n                // BMP character or a constant ASCII code point in the case of\n                // astral symbols. (See the above note on `astralSubstitute`\n                // for more information.)\n                .replace(/\\\\u\\{([0-9a-fA-F]+)\\}|\\\\u([a-fA-F0-9]{4})/g, function ($0, $1, $2) {\n                    var codePoint = parseInt($1 || $2, 16);\n                    if (codePoint > 0x10FFFF) {\n                        throwUnexpectedToken(null, Messages.InvalidRegExp);\n                    }\n                    if (codePoint <= 0xFFFF) {\n                        return String.fromCharCode(codePoint);\n                    }\n                    return astralSubstitute;\n                })\n                // Replace each paired surrogate with a single ASCII symbol to\n                // avoid throwing on regular expressions that are only valid in\n                // combination with the \"u\" flag.\n                .replace(\n                    /[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g,\n                    astralSubstitute\n                );\n        }\n\n        // First, detect invalid regular expressions.\n        try {\n            RegExp(tmp);\n        } catch (e) {\n            throwUnexpectedToken(null, Messages.InvalidRegExp);\n        }\n\n        // Return a regular expression object for this pattern-flag pair, or\n        // `null` in case the current environment doesn't support the flags it\n        // uses.\n        try {\n            return new RegExp(pattern, flags);\n        } catch (exception) {\n            return null;\n        }\n    }\n\n    function scanRegExpBody() {\n        var ch, str, classMarker, terminated, body;\n\n        ch = source[index];\n        assert(ch === '/', 'Regular expression literal must start with a slash');\n        str = source[index++];\n\n        classMarker = false;\n        terminated = false;\n        while (index < length) {\n            ch = source[index++];\n            str += ch;\n            if (ch === '\\\\') {\n                ch = source[index++];\n                // ECMA-262 7.8.5\n                if (isLineTerminator(ch.charCodeAt(0))) {\n                    throwUnexpectedToken(null, Messages.UnterminatedRegExp);\n                }\n                str += ch;\n            } else if (isLineTerminator(ch.charCodeAt(0))) {\n                throwUnexpectedToken(null, Messages.UnterminatedRegExp);\n            } else if (classMarker) {\n                if (ch === ']') {\n                    classMarker = false;\n                }\n            } else {\n                if (ch === '/') {\n                    terminated = true;\n                    break;\n                } else if (ch === '[') {\n                    classMarker = true;\n                }\n            }\n        }\n\n        if (!terminated) {\n            throwUnexpectedToken(null, Messages.UnterminatedRegExp);\n        }\n\n        // Exclude leading and trailing slash.\n        body = str.substr(1, str.length - 2);\n        return {\n            value: body,\n            literal: str\n        };\n    }\n\n    function scanRegExpFlags() {\n        var ch, str, flags, restore;\n\n        str = '';\n        flags = '';\n        while (index < length) {\n            ch = source[index];\n            if (!isIdentifierPart(ch.charCodeAt(0))) {\n                break;\n            }\n\n            ++index;\n            if (ch === '\\\\' && index < length) {\n                ch = source[index];\n                if (ch === 'u') {\n                    ++index;\n                    restore = index;\n                    ch = scanHexEscape('u');\n                    if (ch) {\n                        flags += ch;\n                        for (str += '\\\\u'; restore < index; ++restore) {\n                            str += source[restore];\n                        }\n                    } else {\n                        index = restore;\n                        flags += 'u';\n                        str += '\\\\u';\n                    }\n                    tolerateUnexpectedToken();\n                } else {\n                    str += '\\\\';\n                    tolerateUnexpectedToken();\n                }\n            } else {\n                flags += ch;\n                str += ch;\n            }\n        }\n\n        return {\n            value: flags,\n            literal: str\n        };\n    }\n\n    function scanRegExp() {\n        var start, body, flags, value;\n        scanning = true;\n\n        lookahead = null;\n        skipComment();\n        start = index;\n\n        body = scanRegExpBody();\n        flags = scanRegExpFlags();\n        value = testRegExp(body.value, flags.value);\n        scanning = false;\n        if (extra.tokenize) {\n            return {\n                type: Token.RegularExpression,\n                value: value,\n                regex: {\n                    pattern: body.value,\n                    flags: flags.value\n                },\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                start: start,\n                end: index\n            };\n        }\n\n        return {\n            literal: body.literal + flags.literal,\n            value: value,\n            regex: {\n                pattern: body.value,\n                flags: flags.value\n            },\n            start: start,\n            end: index\n        };\n    }\n\n    function collectRegex() {\n        var pos, loc, regex, token;\n\n        skipComment();\n\n        pos = index;\n        loc = {\n            start: {\n                line: lineNumber,\n                column: index - lineStart\n            }\n        };\n\n        regex = scanRegExp();\n\n        loc.end = {\n            line: lineNumber,\n            column: index - lineStart\n        };\n\n        /* istanbul ignore next */\n        if (!extra.tokenize) {\n            // Pop the previous token, which is likely '/' or '/='\n            if (extra.tokens.length > 0) {\n                token = extra.tokens[extra.tokens.length - 1];\n                if (token.range[0] === pos && token.type === 'Punctuator') {\n                    if (token.value === '/' || token.value === '/=') {\n                        extra.tokens.pop();\n                    }\n                }\n            }\n\n            extra.tokens.push({\n                type: 'RegularExpression',\n                value: regex.literal,\n                regex: regex.regex,\n                range: [pos, index],\n                loc: loc\n            });\n        }\n\n        return regex;\n    }\n\n    function isIdentifierName(token) {\n        return token.type === Token.Identifier ||\n            token.type === Token.Keyword ||\n            token.type === Token.BooleanLiteral ||\n            token.type === Token.NullLiteral;\n    }\n\n    // Using the following algorithm:\n    // https://github.com/mozilla/sweet.js/wiki/design\n\n    function advanceSlash() {\n        var regex, previous, check;\n\n        function testKeyword(value) {\n            return value && (value.length > 1) && (value[0] >= 'a') && (value[0] <= 'z');\n        }\n\n        previous = extra.tokenValues[extra.tokens.length - 1];\n        regex = (previous !== null);\n\n        switch (previous) {\n        case 'this':\n        case ']':\n            regex = false;\n            break;\n\n        case ')':\n            check = extra.tokenValues[extra.openParenToken - 1];\n            regex = (check === 'if' || check === 'while' || check === 'for' || check === 'with');\n            break;\n\n        case '}':\n            // Dividing a function by anything makes little sense,\n            // but we have to check for that.\n            regex = false;\n            if (testKeyword(extra.tokenValues[extra.openCurlyToken - 3])) {\n                // Anonymous function, e.g. function(){} /42\n                check = extra.tokenValues[extra.openCurlyToken - 4];\n                regex = check ? (FnExprTokens.indexOf(check) < 0) : false;\n            } else if (testKeyword(extra.tokenValues[extra.openCurlyToken - 4])) {\n                // Named function, e.g. function f(){} /42/\n                check = extra.tokenValues[extra.openCurlyToken - 5];\n                regex = check ? (FnExprTokens.indexOf(check) < 0) : true;\n            }\n        }\n\n        return regex ? collectRegex() : scanPunctuator();\n    }\n\n    function advance() {\n        var cp, token;\n\n        if (index >= length) {\n            return {\n                type: Token.EOF,\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                start: index,\n                end: index\n            };\n        }\n\n        cp = source.charCodeAt(index);\n\n        if (isIdentifierStart(cp)) {\n            token = scanIdentifier();\n            if (strict && isStrictModeReservedWord(token.value)) {\n                token.type = Token.Keyword;\n            }\n            return token;\n        }\n\n        // Very common: ( and ) and ;\n        if (cp === 0x28 || cp === 0x29 || cp === 0x3B) {\n            return scanPunctuator();\n        }\n\n        // String literal starts with single quote (U+0027) or double quote (U+0022).\n        if (cp === 0x27 || cp === 0x22) {\n            return scanStringLiteral();\n        }\n\n        // Dot (.) U+002E can also start a floating-point number, hence the need\n        // to check the next character.\n        if (cp === 0x2E) {\n            if (isDecimalDigit(source.charCodeAt(index + 1))) {\n                return scanNumericLiteral();\n            }\n            return scanPunctuator();\n        }\n\n        if (isDecimalDigit(cp)) {\n            return scanNumericLiteral();\n        }\n\n        // Slash (/) U+002F can also start a regex.\n        if (extra.tokenize && cp === 0x2F) {\n            return advanceSlash();\n        }\n\n        // Template literals start with ` (U+0060) for template head\n        // or } (U+007D) for template middle or template tail.\n        if (cp === 0x60 || (cp === 0x7D && state.curlyStack[state.curlyStack.length - 1] === '${')) {\n            return scanTemplate();\n        }\n\n        // Possible identifier start in a surrogate pair.\n        if (cp >= 0xD800 && cp < 0xDFFF) {\n            cp = codePointAt(index);\n            if (isIdentifierStart(cp)) {\n                return scanIdentifier();\n            }\n        }\n\n        return scanPunctuator();\n    }\n\n    function collectToken() {\n        var loc, token, value, entry;\n\n        loc = {\n            start: {\n                line: lineNumber,\n                column: index - lineStart\n            }\n        };\n\n        token = advance();\n        loc.end = {\n            line: lineNumber,\n            column: index - lineStart\n        };\n\n        if (token.type !== Token.EOF) {\n            value = source.slice(token.start, token.end);\n            entry = {\n                type: TokenName[token.type],\n                value: value,\n                range: [token.start, token.end],\n                loc: loc\n            };\n            if (token.regex) {\n                entry.regex = {\n                    pattern: token.regex.pattern,\n                    flags: token.regex.flags\n                };\n            }\n            if (extra.tokenValues) {\n                extra.tokenValues.push((entry.type === 'Punctuator' || entry.type === 'Keyword') ? entry.value : null);\n            }\n            if (extra.tokenize) {\n                if (!extra.range) {\n                    delete entry.range;\n                }\n                if (!extra.loc) {\n                    delete entry.loc;\n                }\n                if (extra.delegate) {\n                    entry = extra.delegate(entry);\n                }\n            }\n            extra.tokens.push(entry);\n        }\n\n        return token;\n    }\n\n    function lex() {\n        var token;\n        scanning = true;\n\n        lastIndex = index;\n        lastLineNumber = lineNumber;\n        lastLineStart = lineStart;\n\n        skipComment();\n\n        token = lookahead;\n\n        startIndex = index;\n        startLineNumber = lineNumber;\n        startLineStart = lineStart;\n\n        lookahead = (typeof extra.tokens !== 'undefined') ? collectToken() : advance();\n        scanning = false;\n        return token;\n    }\n\n    function peek() {\n        scanning = true;\n\n        skipComment();\n\n        lastIndex = index;\n        lastLineNumber = lineNumber;\n        lastLineStart = lineStart;\n\n        startIndex = index;\n        startLineNumber = lineNumber;\n        startLineStart = lineStart;\n\n        lookahead = (typeof extra.tokens !== 'undefined') ? collectToken() : advance();\n        scanning = false;\n    }\n\n    function Position() {\n        this.line = startLineNumber;\n        this.column = startIndex - startLineStart;\n    }\n\n    function SourceLocation() {\n        this.start = new Position();\n        this.end = null;\n    }\n\n    function WrappingSourceLocation(startToken) {\n        this.start = {\n            line: startToken.lineNumber,\n            column: startToken.start - startToken.lineStart\n        };\n        this.end = null;\n    }\n\n    function Node() {\n        if (extra.range) {\n            this.range = [startIndex, 0];\n        }\n        if (extra.loc) {\n            this.loc = new SourceLocation();\n        }\n    }\n\n    function WrappingNode(startToken) {\n        if (extra.range) {\n            this.range = [startToken.start, 0];\n        }\n        if (extra.loc) {\n            this.loc = new WrappingSourceLocation(startToken);\n        }\n    }\n\n    WrappingNode.prototype = Node.prototype = {\n\n        processComment: function () {\n            var lastChild,\n                innerComments,\n                leadingComments,\n                trailingComments,\n                bottomRight = extra.bottomRightStack,\n                i,\n                comment,\n                last = bottomRight[bottomRight.length - 1];\n\n            if (this.type === Syntax.Program) {\n                if (this.body.length > 0) {\n                    return;\n                }\n            }\n            /**\n             * patch innnerComments for properties empty block\n             * `function a() {/** comments **\\/}`\n             */\n\n            if (this.type === Syntax.BlockStatement && this.body.length === 0) {\n                innerComments = [];\n                for (i = extra.leadingComments.length - 1; i >= 0; --i) {\n                    comment = extra.leadingComments[i];\n                    if (this.range[1] >= comment.range[1]) {\n                        innerComments.unshift(comment);\n                        extra.leadingComments.splice(i, 1);\n                        extra.trailingComments.splice(i, 1);\n                    }\n                }\n                if (innerComments.length) {\n                    this.innerComments = innerComments;\n                    //bottomRight.push(this);\n                    return;\n                }\n            }\n\n            if (extra.trailingComments.length > 0) {\n                trailingComments = [];\n                for (i = extra.trailingComments.length - 1; i >= 0; --i) {\n                    comment = extra.trailingComments[i];\n                    if (comment.range[0] >= this.range[1]) {\n                        trailingComments.unshift(comment);\n                        extra.trailingComments.splice(i, 1);\n                    }\n                }\n                extra.trailingComments = [];\n            } else {\n                if (last && last.trailingComments && last.trailingComments[0].range[0] >= this.range[1]) {\n                    trailingComments = last.trailingComments;\n                    delete last.trailingComments;\n                }\n            }\n\n            // Eating the stack.\n            while (last && last.range[0] >= this.range[0]) {\n                lastChild = bottomRight.pop();\n                last = bottomRight[bottomRight.length - 1];\n            }\n\n            if (lastChild) {\n                if (lastChild.leadingComments) {\n                    leadingComments = [];\n                    for (i = lastChild.leadingComments.length - 1; i >= 0; --i) {\n                        comment = lastChild.leadingComments[i];\n                        if (comment.range[1] <= this.range[0]) {\n                            leadingComments.unshift(comment);\n                            lastChild.leadingComments.splice(i, 1);\n                        }\n                    }\n\n                    if (!lastChild.leadingComments.length) {\n                        lastChild.leadingComments = undefined;\n                    }\n                }\n            } else if (extra.leadingComments.length > 0) {\n                leadingComments = [];\n                for (i = extra.leadingComments.length - 1; i >= 0; --i) {\n                    comment = extra.leadingComments[i];\n                    if (comment.range[1] <= this.range[0]) {\n                        leadingComments.unshift(comment);\n                        extra.leadingComments.splice(i, 1);\n                    }\n                }\n            }\n\n\n            if (leadingComments && leadingComments.length > 0) {\n                this.leadingComments = leadingComments;\n            }\n            if (trailingComments && trailingComments.length > 0) {\n                this.trailingComments = trailingComments;\n            }\n\n            bottomRight.push(this);\n        },\n\n        finish: function () {\n            if (extra.range) {\n                this.range[1] = lastIndex;\n            }\n            if (extra.loc) {\n                this.loc.end = {\n                    line: lastLineNumber,\n                    column: lastIndex - lastLineStart\n                };\n                if (extra.source) {\n                    this.loc.source = extra.source;\n                }\n            }\n\n            if (extra.attachComment) {\n                this.processComment();\n            }\n        },\n\n        finishArrayExpression: function (elements) {\n            this.type = Syntax.ArrayExpression;\n            this.elements = elements;\n            this.finish();\n            return this;\n        },\n\n        finishArrayPattern: function (elements) {\n            this.type = Syntax.ArrayPattern;\n            this.elements = elements;\n            this.finish();\n            return this;\n        },\n\n        finishArrowFunctionExpression: function (params, defaults, body, expression) {\n            this.type = Syntax.ArrowFunctionExpression;\n            this.id = null;\n            this.params = params;\n            this.defaults = defaults;\n            this.body = body;\n            this.generator = false;\n            this.expression = expression;\n            this.finish();\n            return this;\n        },\n\n        finishAssignmentExpression: function (operator, left, right) {\n            this.type = Syntax.AssignmentExpression;\n            this.operator = operator;\n            this.left = left;\n            this.right = right;\n            this.finish();\n            return this;\n        },\n\n        finishAssignmentPattern: function (left, right) {\n            this.type = Syntax.AssignmentPattern;\n            this.left = left;\n            this.right = right;\n            this.finish();\n            return this;\n        },\n\n        finishBinaryExpression: function (operator, left, right) {\n            this.type = (operator === '||' || operator === '&&') ? Syntax.LogicalExpression : Syntax.BinaryExpression;\n            this.operator = operator;\n            this.left = left;\n            this.right = right;\n            this.finish();\n            return this;\n        },\n\n        finishBlockStatement: function (body) {\n            this.type = Syntax.BlockStatement;\n            this.body = body;\n            this.finish();\n            return this;\n        },\n\n        finishBreakStatement: function (label) {\n            this.type = Syntax.BreakStatement;\n            this.label = label;\n            this.finish();\n            return this;\n        },\n\n        finishCallExpression: function (callee, args) {\n            this.type = Syntax.CallExpression;\n            this.callee = callee;\n            this.arguments = args;\n            this.finish();\n            return this;\n        },\n\n        finishCatchClause: function (param, body) {\n            this.type = Syntax.CatchClause;\n            this.param = param;\n            this.body = body;\n            this.finish();\n            return this;\n        },\n\n        finishClassBody: function (body) {\n            this.type = Syntax.ClassBody;\n            this.body = body;\n            this.finish();\n            return this;\n        },\n\n        finishClassDeclaration: function (id, superClass, body) {\n            this.type = Syntax.ClassDeclaration;\n            this.id = id;\n            this.superClass = superClass;\n            this.body = body;\n            this.finish();\n            return this;\n        },\n\n        finishClassExpression: function (id, superClass, body) {\n            this.type = Syntax.ClassExpression;\n            this.id = id;\n            this.superClass = superClass;\n            this.body = body;\n            this.finish();\n            return this;\n        },\n\n        finishConditionalExpression: function (test, consequent, alternate) {\n            this.type = Syntax.ConditionalExpression;\n            this.test = test;\n            this.consequent = consequent;\n            this.alternate = alternate;\n            this.finish();\n            return this;\n        },\n\n        finishContinueStatement: function (label) {\n            this.type = Syntax.ContinueStatement;\n            this.label = label;\n            this.finish();\n            return this;\n        },\n\n        finishDebuggerStatement: function () {\n            this.type = Syntax.DebuggerStatement;\n            this.finish();\n            return this;\n        },\n\n        finishDoWhileStatement: function (body, test) {\n            this.type = Syntax.DoWhileStatement;\n            this.body = body;\n            this.test = test;\n            this.finish();\n            return this;\n        },\n\n        finishEmptyStatement: function () {\n            this.type = Syntax.EmptyStatement;\n            this.finish();\n            return this;\n        },\n\n        finishExpressionStatement: function (expression) {\n            this.type = Syntax.ExpressionStatement;\n            this.expression = expression;\n            this.finish();\n            return this;\n        },\n\n        finishForStatement: function (init, test, update, body) {\n            this.type = Syntax.ForStatement;\n            this.init = init;\n            this.test = test;\n            this.update = update;\n            this.body = body;\n            this.finish();\n            return this;\n        },\n\n        finishForOfStatement: function (left, right, body) {\n            this.type = Syntax.ForOfStatement;\n            this.left = left;\n            this.right = right;\n            this.body = body;\n            this.finish();\n            return this;\n        },\n\n        finishForInStatement: function (left, right, body) {\n            this.type = Syntax.ForInStatement;\n            this.left = left;\n            this.right = right;\n            this.body = body;\n            this.each = false;\n            this.finish();\n            return this;\n        },\n\n        finishFunctionDeclaration: function (id, params, defaults, body, generator) {\n            this.type = Syntax.FunctionDeclaration;\n            this.id = id;\n            this.params = params;\n            this.defaults = defaults;\n            this.body = body;\n            this.generator = generator;\n            this.expression = false;\n            this.finish();\n            return this;\n        },\n\n        finishFunctionExpression: function (id, params, defaults, body, generator) {\n            this.type = Syntax.FunctionExpression;\n            this.id = id;\n            this.params = params;\n            this.defaults = defaults;\n            this.body = body;\n            this.generator = generator;\n            this.expression = false;\n            this.finish();\n            return this;\n        },\n\n        finishIdentifier: function (name) {\n            this.type = Syntax.Identifier;\n            this.name = name;\n            this.finish();\n            return this;\n        },\n\n        finishIfStatement: function (test, consequent, alternate) {\n            this.type = Syntax.IfStatement;\n            this.test = test;\n            this.consequent = consequent;\n            this.alternate = alternate;\n            this.finish();\n            return this;\n        },\n\n        finishLabeledStatement: function (label, body) {\n            this.type = Syntax.LabeledStatement;\n            this.label = label;\n            this.body = body;\n            this.finish();\n            return this;\n        },\n\n        finishLiteral: function (token) {\n            this.type = Syntax.Literal;\n            this.value = token.value;\n            this.raw = source.slice(token.start, token.end);\n            if (token.regex) {\n                this.regex = token.regex;\n            }\n            this.finish();\n            return this;\n        },\n\n        finishMemberExpression: function (accessor, object, property) {\n            this.type = Syntax.MemberExpression;\n            this.computed = accessor === '[';\n            this.object = object;\n            this.property = property;\n            this.finish();\n            return this;\n        },\n\n        finishMetaProperty: function (meta, property) {\n            this.type = Syntax.MetaProperty;\n            this.meta = meta;\n            this.property = property;\n            this.finish();\n            return this;\n        },\n\n        finishNewExpression: function (callee, args) {\n            this.type = Syntax.NewExpression;\n            this.callee = callee;\n            this.arguments = args;\n            this.finish();\n            return this;\n        },\n\n        finishObjectExpression: function (properties) {\n            this.type = Syntax.ObjectExpression;\n            this.properties = properties;\n            this.finish();\n            return this;\n        },\n\n        finishObjectPattern: function (properties) {\n            this.type = Syntax.ObjectPattern;\n            this.properties = properties;\n            this.finish();\n            return this;\n        },\n\n        finishPostfixExpression: function (operator, argument) {\n            this.type = Syntax.UpdateExpression;\n            this.operator = operator;\n            this.argument = argument;\n            this.prefix = false;\n            this.finish();\n            return this;\n        },\n\n        finishProgram: function (body, sourceType) {\n            this.type = Syntax.Program;\n            this.body = body;\n            this.sourceType = sourceType;\n            this.finish();\n            return this;\n        },\n\n        finishProperty: function (kind, key, computed, value, method, shorthand) {\n            this.type = Syntax.Property;\n            this.key = key;\n            this.computed = computed;\n            this.value = value;\n            this.kind = kind;\n            this.method = method;\n            this.shorthand = shorthand;\n            this.finish();\n            return this;\n        },\n\n        finishRestElement: function (argument) {\n            this.type = Syntax.RestElement;\n            this.argument = argument;\n            this.finish();\n            return this;\n        },\n\n        finishReturnStatement: function (argument) {\n            this.type = Syntax.ReturnStatement;\n            this.argument = argument;\n            this.finish();\n            return this;\n        },\n\n        finishSequenceExpression: function (expressions) {\n            this.type = Syntax.SequenceExpression;\n            this.expressions = expressions;\n            this.finish();\n            return this;\n        },\n\n        finishSpreadElement: function (argument) {\n            this.type = Syntax.SpreadElement;\n            this.argument = argument;\n            this.finish();\n            return this;\n        },\n\n        finishSwitchCase: function (test, consequent) {\n            this.type = Syntax.SwitchCase;\n            this.test = test;\n            this.consequent = consequent;\n            this.finish();\n            return this;\n        },\n\n        finishSuper: function () {\n            this.type = Syntax.Super;\n            this.finish();\n            return this;\n        },\n\n        finishSwitchStatement: function (discriminant, cases) {\n            this.type = Syntax.SwitchStatement;\n            this.discriminant = discriminant;\n            this.cases = cases;\n            this.finish();\n            return this;\n        },\n\n        finishTaggedTemplateExpression: function (tag, quasi) {\n            this.type = Syntax.TaggedTemplateExpression;\n            this.tag = tag;\n            this.quasi = quasi;\n            this.finish();\n            return this;\n        },\n\n        finishTemplateElement: function (value, tail) {\n            this.type = Syntax.TemplateElement;\n            this.value = value;\n            this.tail = tail;\n            this.finish();\n            return this;\n        },\n\n        finishTemplateLiteral: function (quasis, expressions) {\n            this.type = Syntax.TemplateLiteral;\n            this.quasis = quasis;\n            this.expressions = expressions;\n            this.finish();\n            return this;\n        },\n\n        finishThisExpression: function () {\n            this.type = Syntax.ThisExpression;\n            this.finish();\n            return this;\n        },\n\n        finishThrowStatement: function (argument) {\n            this.type = Syntax.ThrowStatement;\n            this.argument = argument;\n            this.finish();\n            return this;\n        },\n\n        finishTryStatement: function (block, handler, finalizer) {\n            this.type = Syntax.TryStatement;\n            this.block = block;\n            this.guardedHandlers = [];\n            this.handlers = handler ? [handler] : [];\n            this.handler = handler;\n            this.finalizer = finalizer;\n            this.finish();\n            return this;\n        },\n\n        finishUnaryExpression: function (operator, argument) {\n            this.type = (operator === '++' || operator === '--') ? Syntax.UpdateExpression : Syntax.UnaryExpression;\n            this.operator = operator;\n            this.argument = argument;\n            this.prefix = true;\n            this.finish();\n            return this;\n        },\n\n        finishVariableDeclaration: function (declarations) {\n            this.type = Syntax.VariableDeclaration;\n            this.declarations = declarations;\n            this.kind = 'var';\n            this.finish();\n            return this;\n        },\n\n        finishLexicalDeclaration: function (declarations, kind) {\n            this.type = Syntax.VariableDeclaration;\n            this.declarations = declarations;\n            this.kind = kind;\n            this.finish();\n            return this;\n        },\n\n        finishVariableDeclarator: function (id, init) {\n            this.type = Syntax.VariableDeclarator;\n            this.id = id;\n            this.init = init;\n            this.finish();\n            return this;\n        },\n\n        finishWhileStatement: function (test, body) {\n            this.type = Syntax.WhileStatement;\n            this.test = test;\n            this.body = body;\n            this.finish();\n            return this;\n        },\n\n        finishWithStatement: function (object, body) {\n            this.type = Syntax.WithStatement;\n            this.object = object;\n            this.body = body;\n            this.finish();\n            return this;\n        },\n\n        finishExportSpecifier: function (local, exported) {\n            this.type = Syntax.ExportSpecifier;\n            this.exported = exported || local;\n            this.local = local;\n            this.finish();\n            return this;\n        },\n\n        finishImportDefaultSpecifier: function (local) {\n            this.type = Syntax.ImportDefaultSpecifier;\n            this.local = local;\n            this.finish();\n            return this;\n        },\n\n        finishImportNamespaceSpecifier: function (local) {\n            this.type = Syntax.ImportNamespaceSpecifier;\n            this.local = local;\n            this.finish();\n            return this;\n        },\n\n        finishExportNamedDeclaration: function (declaration, specifiers, src) {\n            this.type = Syntax.ExportNamedDeclaration;\n            this.declaration = declaration;\n            this.specifiers = specifiers;\n            this.source = src;\n            this.finish();\n            return this;\n        },\n\n        finishExportDefaultDeclaration: function (declaration) {\n            this.type = Syntax.ExportDefaultDeclaration;\n            this.declaration = declaration;\n            this.finish();\n            return this;\n        },\n\n        finishExportAllDeclaration: function (src) {\n            this.type = Syntax.ExportAllDeclaration;\n            this.source = src;\n            this.finish();\n            return this;\n        },\n\n        finishImportSpecifier: function (local, imported) {\n            this.type = Syntax.ImportSpecifier;\n            this.local = local || imported;\n            this.imported = imported;\n            this.finish();\n            return this;\n        },\n\n        finishImportDeclaration: function (specifiers, src) {\n            this.type = Syntax.ImportDeclaration;\n            this.specifiers = specifiers;\n            this.source = src;\n            this.finish();\n            return this;\n        },\n\n        finishYieldExpression: function (argument, delegate) {\n            this.type = Syntax.YieldExpression;\n            this.argument = argument;\n            this.delegate = delegate;\n            this.finish();\n            return this;\n        }\n    };\n\n\n    function recordError(error) {\n        var e, existing;\n\n        for (e = 0; e < extra.errors.length; e++) {\n            existing = extra.errors[e];\n            // Prevent duplicated error.\n            /* istanbul ignore next */\n            if (existing.index === error.index && existing.message === error.message) {\n                return;\n            }\n        }\n\n        extra.errors.push(error);\n    }\n\n    function constructError(msg, column) {\n        var error = new Error(msg);\n        try {\n            throw error;\n        } catch (base) {\n            /* istanbul ignore else */\n            if (Object.create && Object.defineProperty) {\n                error = Object.create(base);\n                Object.defineProperty(error, 'column', { value: column });\n            }\n        } finally {\n            return error;\n        }\n    }\n\n    function createError(line, pos, description) {\n        var msg, column, error;\n\n        msg = 'Line ' + line + ': ' + description;\n        column = pos - (scanning ? lineStart : lastLineStart) + 1;\n        error = constructError(msg, column);\n        error.lineNumber = line;\n        error.description = description;\n        error.index = pos;\n        return error;\n    }\n\n    // Throw an exception\n\n    function throwError(messageFormat) {\n        var args, msg;\n\n        args = Array.prototype.slice.call(arguments, 1);\n        msg = messageFormat.replace(/%(\\d)/g,\n            function (whole, idx) {\n                assert(idx < args.length, 'Message reference must be in range');\n                return args[idx];\n            }\n        );\n\n        throw createError(lastLineNumber, lastIndex, msg);\n    }\n\n    function tolerateError(messageFormat) {\n        var args, msg, error;\n\n        args = Array.prototype.slice.call(arguments, 1);\n        /* istanbul ignore next */\n        msg = messageFormat.replace(/%(\\d)/g,\n            function (whole, idx) {\n                assert(idx < args.length, 'Message reference must be in range');\n                return args[idx];\n            }\n        );\n\n        error = createError(lineNumber, lastIndex, msg);\n        if (extra.errors) {\n            recordError(error);\n        } else {\n            throw error;\n        }\n    }\n\n    // Throw an exception because of the token.\n\n    function unexpectedTokenError(token, message) {\n        var value, msg = message || Messages.UnexpectedToken;\n\n        if (token) {\n            if (!message) {\n                msg = (token.type === Token.EOF) ? Messages.UnexpectedEOS :\n                    (token.type === Token.Identifier) ? Messages.UnexpectedIdentifier :\n                    (token.type === Token.NumericLiteral) ? Messages.UnexpectedNumber :\n                    (token.type === Token.StringLiteral) ? Messages.UnexpectedString :\n                    (token.type === Token.Template) ? Messages.UnexpectedTemplate :\n                    Messages.UnexpectedToken;\n\n                if (token.type === Token.Keyword) {\n                    if (isFutureReservedWord(token.value)) {\n                        msg = Messages.UnexpectedReserved;\n                    } else if (strict && isStrictModeReservedWord(token.value)) {\n                        msg = Messages.StrictReservedWord;\n                    }\n                }\n            }\n\n            value = (token.type === Token.Template) ? token.value.raw : token.value;\n        } else {\n            value = 'ILLEGAL';\n        }\n\n        msg = msg.replace('%0', value);\n\n        return (token && typeof token.lineNumber === 'number') ?\n            createError(token.lineNumber, token.start, msg) :\n            createError(scanning ? lineNumber : lastLineNumber, scanning ? index : lastIndex, msg);\n    }\n\n    function throwUnexpectedToken(token, message) {\n        throw unexpectedTokenError(token, message);\n    }\n\n    function tolerateUnexpectedToken(token, message) {\n        var error = unexpectedTokenError(token, message);\n        if (extra.errors) {\n            recordError(error);\n        } else {\n            throw error;\n        }\n    }\n\n    // Expect the next token to match the specified punctuator.\n    // If not, an exception will be thrown.\n\n    function expect(value) {\n        var token = lex();\n        if (token.type !== Token.Punctuator || token.value !== value) {\n            throwUnexpectedToken(token);\n        }\n    }\n\n    /**\n     * @name expectCommaSeparator\n     * @description Quietly expect a comma when in tolerant mode, otherwise delegates\n     * to <code>expect(value)</code>\n     * @since 2.0\n     */\n    function expectCommaSeparator() {\n        var token;\n\n        if (extra.errors) {\n            token = lookahead;\n            if (token.type === Token.Punctuator && token.value === ',') {\n                lex();\n            } else if (token.type === Token.Punctuator && token.value === ';') {\n                lex();\n                tolerateUnexpectedToken(token);\n            } else {\n                tolerateUnexpectedToken(token, Messages.UnexpectedToken);\n            }\n        } else {\n            expect(',');\n        }\n    }\n\n    // Expect the next token to match the specified keyword.\n    // If not, an exception will be thrown.\n\n    function expectKeyword(keyword) {\n        var token = lex();\n        if (token.type !== Token.Keyword || token.value !== keyword) {\n            throwUnexpectedToken(token);\n        }\n    }\n\n    // Return true if the next token matches the specified punctuator.\n\n    function match(value) {\n        return lookahead.type === Token.Punctuator && lookahead.value === value;\n    }\n\n    // Return true if the next token matches the specified keyword\n\n    function matchKeyword(keyword) {\n        return lookahead.type === Token.Keyword && lookahead.value === keyword;\n    }\n\n    // Return true if the next token matches the specified contextual keyword\n    // (where an identifier is sometimes a keyword depending on the context)\n\n    function matchContextualKeyword(keyword) {\n        return lookahead.type === Token.Identifier && lookahead.value === keyword;\n    }\n\n    // Return true if the next token is an assignment operator\n\n    function matchAssign() {\n        var op;\n\n        if (lookahead.type !== Token.Punctuator) {\n            return false;\n        }\n        op = lookahead.value;\n        return op === '=' ||\n            op === '*=' ||\n            op === '/=' ||\n            op === '%=' ||\n            op === '+=' ||\n            op === '-=' ||\n            op === '<<=' ||\n            op === '>>=' ||\n            op === '>>>=' ||\n            op === '&=' ||\n            op === '^=' ||\n            op === '|=';\n    }\n\n    function consumeSemicolon() {\n        // Catch the very common case first: immediately a semicolon (U+003B).\n        if (source.charCodeAt(startIndex) === 0x3B || match(';')) {\n            lex();\n            return;\n        }\n\n        if (hasLineTerminator) {\n            return;\n        }\n\n        // FIXME(ikarienator): this is seemingly an issue in the previous location info convention.\n        lastIndex = startIndex;\n        lastLineNumber = startLineNumber;\n        lastLineStart = startLineStart;\n\n        if (lookahead.type !== Token.EOF && !match('}')) {\n            throwUnexpectedToken(lookahead);\n        }\n    }\n\n    // Cover grammar support.\n    //\n    // When an assignment expression position starts with an left parenthesis, the determination of the type\n    // of the syntax is to be deferred arbitrarily long until the end of the parentheses pair (plus a lookahead)\n    // or the first comma. This situation also defers the determination of all the expressions nested in the pair.\n    //\n    // There are three productions that can be parsed in a parentheses pair that needs to be determined\n    // after the outermost pair is closed. They are:\n    //\n    //   1. AssignmentExpression\n    //   2. BindingElements\n    //   3. AssignmentTargets\n    //\n    // In order to avoid exponential backtracking, we use two flags to denote if the production can be\n    // binding element or assignment target.\n    //\n    // The three productions have the relationship:\n    //\n    //   BindingElements  AssignmentTargets  AssignmentExpression\n    //\n    // with a single exception that CoverInitializedName when used directly in an Expression, generates\n    // an early error. Therefore, we need the third state, firstCoverInitializedNameError, to track the\n    // first usage of CoverInitializedName and report it when we reached the end of the parentheses pair.\n    //\n    // isolateCoverGrammar function runs the given parser function with a new cover grammar context, and it does not\n    // effect the current flags. This means the production the parser parses is only used as an expression. Therefore\n    // the CoverInitializedName check is conducted.\n    //\n    // inheritCoverGrammar function runs the given parse function with a new cover grammar context, and it propagates\n    // the flags outside of the parser. This means the production the parser parses is used as a part of a potential\n    // pattern. The CoverInitializedName check is deferred.\n    function isolateCoverGrammar(parser) {\n        var oldIsBindingElement = isBindingElement,\n            oldIsAssignmentTarget = isAssignmentTarget,\n            oldFirstCoverInitializedNameError = firstCoverInitializedNameError,\n            result;\n        isBindingElement = true;\n        isAssignmentTarget = true;\n        firstCoverInitializedNameError = null;\n        result = parser();\n        if (firstCoverInitializedNameError !== null) {\n            throwUnexpectedToken(firstCoverInitializedNameError);\n        }\n        isBindingElement = oldIsBindingElement;\n        isAssignmentTarget = oldIsAssignmentTarget;\n        firstCoverInitializedNameError = oldFirstCoverInitializedNameError;\n        return result;\n    }\n\n    function inheritCoverGrammar(parser) {\n        var oldIsBindingElement = isBindingElement,\n            oldIsAssignmentTarget = isAssignmentTarget,\n            oldFirstCoverInitializedNameError = firstCoverInitializedNameError,\n            result;\n        isBindingElement = true;\n        isAssignmentTarget = true;\n        firstCoverInitializedNameError = null;\n        result = parser();\n        isBindingElement = isBindingElement && oldIsBindingElement;\n        isAssignmentTarget = isAssignmentTarget && oldIsAssignmentTarget;\n        firstCoverInitializedNameError = oldFirstCoverInitializedNameError || firstCoverInitializedNameError;\n        return result;\n    }\n\n    // ECMA-262 13.3.3 Destructuring Binding Patterns\n\n    function parseArrayPattern(params, kind) {\n        var node = new Node(), elements = [], rest, restNode;\n        expect('[');\n\n        while (!match(']')) {\n            if (match(',')) {\n                lex();\n                elements.push(null);\n            } else {\n                if (match('...')) {\n                    restNode = new Node();\n                    lex();\n                    params.push(lookahead);\n                    rest = parseVariableIdentifier(kind);\n                    elements.push(restNode.finishRestElement(rest));\n                    break;\n                } else {\n                    elements.push(parsePatternWithDefault(params, kind));\n                }\n                if (!match(']')) {\n                    expect(',');\n                }\n            }\n\n        }\n\n        expect(']');\n\n        return node.finishArrayPattern(elements);\n    }\n\n    function parsePropertyPattern(params, kind) {\n        var node = new Node(), key, keyToken, computed = match('['), init;\n        if (lookahead.type === Token.Identifier) {\n            keyToken = lookahead;\n            key = parseVariableIdentifier();\n            if (match('=')) {\n                params.push(keyToken);\n                lex();\n                init = parseAssignmentExpression();\n\n                return node.finishProperty(\n                    'init', key, false,\n                    new WrappingNode(keyToken).finishAssignmentPattern(key, init), false, true);\n            } else if (!match(':')) {\n                params.push(keyToken);\n                return node.finishProperty('init', key, false, key, false, true);\n            }\n        } else {\n            key = parseObjectPropertyKey();\n        }\n        expect(':');\n        init = parsePatternWithDefault(params, kind);\n        return node.finishProperty('init', key, computed, init, false, false);\n    }\n\n    function parseObjectPattern(params, kind) {\n        var node = new Node(), properties = [];\n\n        expect('{');\n\n        while (!match('}')) {\n            properties.push(parsePropertyPattern(params, kind));\n            if (!match('}')) {\n                expect(',');\n            }\n        }\n\n        lex();\n\n        return node.finishObjectPattern(properties);\n    }\n\n    function parsePattern(params, kind) {\n        if (match('[')) {\n            return parseArrayPattern(params, kind);\n        } else if (match('{')) {\n            return parseObjectPattern(params, kind);\n        } else if (matchKeyword('let')) {\n            if (kind === 'const' || kind === 'let') {\n                tolerateUnexpectedToken(lookahead, Messages.UnexpectedToken);\n            }\n        }\n\n        params.push(lookahead);\n        return parseVariableIdentifier(kind);\n    }\n\n    function parsePatternWithDefault(params, kind) {\n        var startToken = lookahead, pattern, previousAllowYield, right;\n        pattern = parsePattern(params, kind);\n        if (match('=')) {\n            lex();\n            previousAllowYield = state.allowYield;\n            state.allowYield = true;\n            right = isolateCoverGrammar(parseAssignmentExpression);\n            state.allowYield = previousAllowYield;\n            pattern = new WrappingNode(startToken).finishAssignmentPattern(pattern, right);\n        }\n        return pattern;\n    }\n\n    // ECMA-262 12.2.5 Array Initializer\n\n    function parseArrayInitializer() {\n        var elements = [], node = new Node(), restSpread;\n\n        expect('[');\n\n        while (!match(']')) {\n            if (match(',')) {\n                lex();\n                elements.push(null);\n            } else if (match('...')) {\n                restSpread = new Node();\n                lex();\n                restSpread.finishSpreadElement(inheritCoverGrammar(parseAssignmentExpression));\n\n                if (!match(']')) {\n                    isAssignmentTarget = isBindingElement = false;\n                    expect(',');\n                }\n                elements.push(restSpread);\n            } else {\n                elements.push(inheritCoverGrammar(parseAssignmentExpression));\n\n                if (!match(']')) {\n                    expect(',');\n                }\n            }\n        }\n\n        lex();\n\n        return node.finishArrayExpression(elements);\n    }\n\n    // ECMA-262 12.2.6 Object Initializer\n\n    function parsePropertyFunction(node, paramInfo, isGenerator) {\n        var previousStrict, body;\n\n        isAssignmentTarget = isBindingElement = false;\n\n        previousStrict = strict;\n        body = isolateCoverGrammar(parseFunctionSourceElements);\n\n        if (strict && paramInfo.firstRestricted) {\n            tolerateUnexpectedToken(paramInfo.firstRestricted, paramInfo.message);\n        }\n        if (strict && paramInfo.stricted) {\n            tolerateUnexpectedToken(paramInfo.stricted, paramInfo.message);\n        }\n\n        strict = previousStrict;\n        return node.finishFunctionExpression(null, paramInfo.params, paramInfo.defaults, body, isGenerator);\n    }\n\n    function parsePropertyMethodFunction() {\n        var params, method, node = new Node(),\n            previousAllowYield = state.allowYield;\n\n        state.allowYield = false;\n        params = parseParams();\n        state.allowYield = previousAllowYield;\n\n        state.allowYield = false;\n        method = parsePropertyFunction(node, params, false);\n        state.allowYield = previousAllowYield;\n\n        return method;\n    }\n\n    function parseObjectPropertyKey() {\n        var token, node = new Node(), expr;\n\n        token = lex();\n\n        // Note: This function is called only from parseObjectProperty(), where\n        // EOF and Punctuator tokens are already filtered out.\n\n        switch (token.type) {\n        case Token.StringLiteral:\n        case Token.NumericLiteral:\n            if (strict && token.octal) {\n                tolerateUnexpectedToken(token, Messages.StrictOctalLiteral);\n            }\n            return node.finishLiteral(token);\n        case Token.Identifier:\n        case Token.BooleanLiteral:\n        case Token.NullLiteral:\n        case Token.Keyword:\n            return node.finishIdentifier(token.value);\n        case Token.Punctuator:\n            if (token.value === '[') {\n                expr = isolateCoverGrammar(parseAssignmentExpression);\n                expect(']');\n                return expr;\n            }\n            break;\n        }\n        throwUnexpectedToken(token);\n    }\n\n    function lookaheadPropertyName() {\n        switch (lookahead.type) {\n        case Token.Identifier:\n        case Token.StringLiteral:\n        case Token.BooleanLiteral:\n        case Token.NullLiteral:\n        case Token.NumericLiteral:\n        case Token.Keyword:\n            return true;\n        case Token.Punctuator:\n            return lookahead.value === '[';\n        }\n        return false;\n    }\n\n    // This function is to try to parse a MethodDefinition as defined in 14.3. But in the case of object literals,\n    // it might be called at a position where there is in fact a short hand identifier pattern or a data property.\n    // This can only be determined after we consumed up to the left parentheses.\n    //\n    // In order to avoid back tracking, it returns `null` if the position is not a MethodDefinition and the caller\n    // is responsible to visit other options.\n    function tryParseMethodDefinition(token, key, computed, node) {\n        var value, options, methodNode, params,\n            previousAllowYield = state.allowYield;\n\n        if (token.type === Token.Identifier) {\n            // check for `get` and `set`;\n\n            if (token.value === 'get' && lookaheadPropertyName()) {\n                computed = match('[');\n                key = parseObjectPropertyKey();\n                methodNode = new Node();\n                expect('(');\n                expect(')');\n\n                state.allowYield = false;\n                value = parsePropertyFunction(methodNode, {\n                    params: [],\n                    defaults: [],\n                    stricted: null,\n                    firstRestricted: null,\n                    message: null\n                }, false);\n                state.allowYield = previousAllowYield;\n\n                return node.finishProperty('get', key, computed, value, false, false);\n            } else if (token.value === 'set' && lookaheadPropertyName()) {\n                computed = match('[');\n                key = parseObjectPropertyKey();\n                methodNode = new Node();\n                expect('(');\n\n                options = {\n                    params: [],\n                    defaultCount: 0,\n                    defaults: [],\n                    firstRestricted: null,\n                    paramSet: {}\n                };\n                if (match(')')) {\n                    tolerateUnexpectedToken(lookahead);\n                } else {\n                    state.allowYield = false;\n                    parseParam(options);\n                    state.allowYield = previousAllowYield;\n                    if (options.defaultCount === 0) {\n                        options.defaults = [];\n                    }\n                }\n                expect(')');\n\n                state.allowYield = false;\n                value = parsePropertyFunction(methodNode, options, false);\n                state.allowYield = previousAllowYield;\n\n                return node.finishProperty('set', key, computed, value, false, false);\n            }\n        } else if (token.type === Token.Punctuator && token.value === '*' && lookaheadPropertyName()) {\n            computed = match('[');\n            key = parseObjectPropertyKey();\n            methodNode = new Node();\n\n            state.allowYield = true;\n            params = parseParams();\n            state.allowYield = previousAllowYield;\n\n            state.allowYield = false;\n            value = parsePropertyFunction(methodNode, params, true);\n            state.allowYield = previousAllowYield;\n\n            return node.finishProperty('init', key, computed, value, true, false);\n        }\n\n        if (key && match('(')) {\n            value = parsePropertyMethodFunction();\n            return node.finishProperty('init', key, computed, value, true, false);\n        }\n\n        // Not a MethodDefinition.\n        return null;\n    }\n\n    function parseObjectProperty(hasProto) {\n        var token = lookahead, node = new Node(), computed, key, maybeMethod, proto, value;\n\n        computed = match('[');\n        if (match('*')) {\n            lex();\n        } else {\n            key = parseObjectPropertyKey();\n        }\n        maybeMethod = tryParseMethodDefinition(token, key, computed, node);\n        if (maybeMethod) {\n            return maybeMethod;\n        }\n\n        if (!key) {\n            throwUnexpectedToken(lookahead);\n        }\n\n        // Check for duplicated __proto__\n        if (!computed) {\n            proto = (key.type === Syntax.Identifier && key.name === '__proto__') ||\n                (key.type === Syntax.Literal && key.value === '__proto__');\n            if (hasProto.value && proto) {\n                tolerateError(Messages.DuplicateProtoProperty);\n            }\n            hasProto.value |= proto;\n        }\n\n        if (match(':')) {\n            lex();\n            value = inheritCoverGrammar(parseAssignmentExpression);\n            return node.finishProperty('init', key, computed, value, false, false);\n        }\n\n        if (token.type === Token.Identifier) {\n            if (match('=')) {\n                firstCoverInitializedNameError = lookahead;\n                lex();\n                value = isolateCoverGrammar(parseAssignmentExpression);\n                return node.finishProperty('init', key, computed,\n                    new WrappingNode(token).finishAssignmentPattern(key, value), false, true);\n            }\n            return node.finishProperty('init', key, computed, key, false, true);\n        }\n\n        throwUnexpectedToken(lookahead);\n    }\n\n    function parseObjectInitializer() {\n        var properties = [], hasProto = {value: false}, node = new Node();\n\n        expect('{');\n\n        while (!match('}')) {\n            properties.push(parseObjectProperty(hasProto));\n\n            if (!match('}')) {\n                expectCommaSeparator();\n            }\n        }\n\n        expect('}');\n\n        return node.finishObjectExpression(properties);\n    }\n\n    function reinterpretExpressionAsPattern(expr) {\n        var i;\n        switch (expr.type) {\n        case Syntax.Identifier:\n        case Syntax.MemberExpression:\n        case Syntax.RestElement:\n        case Syntax.AssignmentPattern:\n            break;\n        case Syntax.SpreadElement:\n            expr.type = Syntax.RestElement;\n            reinterpretExpressionAsPattern(expr.argument);\n            break;\n        case Syntax.ArrayExpression:\n            expr.type = Syntax.ArrayPattern;\n            for (i = 0; i < expr.elements.length; i++) {\n                if (expr.elements[i] !== null) {\n                    reinterpretExpressionAsPattern(expr.elements[i]);\n                }\n            }\n            break;\n        case Syntax.ObjectExpression:\n            expr.type = Syntax.ObjectPattern;\n            for (i = 0; i < expr.properties.length; i++) {\n                reinterpretExpressionAsPattern(expr.properties[i].value);\n            }\n            break;\n        case Syntax.AssignmentExpression:\n            expr.type = Syntax.AssignmentPattern;\n            reinterpretExpressionAsPattern(expr.left);\n            break;\n        default:\n            // Allow other node type for tolerant parsing.\n            break;\n        }\n    }\n\n    // ECMA-262 12.2.9 Template Literals\n\n    function parseTemplateElement(option) {\n        var node, token;\n\n        if (lookahead.type !== Token.Template || (option.head && !lookahead.head)) {\n            throwUnexpectedToken();\n        }\n\n        node = new Node();\n        token = lex();\n\n        return node.finishTemplateElement({ raw: token.value.raw, cooked: token.value.cooked }, token.tail);\n    }\n\n    function parseTemplateLiteral() {\n        var quasi, quasis, expressions, node = new Node();\n\n        quasi = parseTemplateElement({ head: true });\n        quasis = [quasi];\n        expressions = [];\n\n        while (!quasi.tail) {\n            expressions.push(parseExpression());\n            quasi = parseTemplateElement({ head: false });\n            quasis.push(quasi);\n        }\n\n        return node.finishTemplateLiteral(quasis, expressions);\n    }\n\n    // ECMA-262 12.2.10 The Grouping Operator\n\n    function parseGroupExpression() {\n        var expr, expressions, startToken, i, params = [];\n\n        expect('(');\n\n        if (match(')')) {\n            lex();\n            if (!match('=>')) {\n                expect('=>');\n            }\n            return {\n                type: PlaceHolders.ArrowParameterPlaceHolder,\n                params: [],\n                rawParams: []\n            };\n        }\n\n        startToken = lookahead;\n        if (match('...')) {\n            expr = parseRestElement(params);\n            expect(')');\n            if (!match('=>')) {\n                expect('=>');\n            }\n            return {\n                type: PlaceHolders.ArrowParameterPlaceHolder,\n                params: [expr]\n            };\n        }\n\n        isBindingElement = true;\n        expr = inheritCoverGrammar(parseAssignmentExpression);\n\n        if (match(',')) {\n            isAssignmentTarget = false;\n            expressions = [expr];\n\n            while (startIndex < length) {\n                if (!match(',')) {\n                    break;\n                }\n                lex();\n\n                if (match('...')) {\n                    if (!isBindingElement) {\n                        throwUnexpectedToken(lookahead);\n                    }\n                    expressions.push(parseRestElement(params));\n                    expect(')');\n                    if (!match('=>')) {\n                        expect('=>');\n                    }\n                    isBindingElement = false;\n                    for (i = 0; i < expressions.length; i++) {\n                        reinterpretExpressionAsPattern(expressions[i]);\n                    }\n                    return {\n                        type: PlaceHolders.ArrowParameterPlaceHolder,\n                        params: expressions\n                    };\n                }\n\n                expressions.push(inheritCoverGrammar(parseAssignmentExpression));\n            }\n\n            expr = new WrappingNode(startToken).finishSequenceExpression(expressions);\n        }\n\n\n        expect(')');\n\n        if (match('=>')) {\n            if (expr.type === Syntax.Identifier && expr.name === 'yield') {\n                return {\n                    type: PlaceHolders.ArrowParameterPlaceHolder,\n                    params: [expr]\n                };\n            }\n\n            if (!isBindingElement) {\n                throwUnexpectedToken(lookahead);\n            }\n\n            if (expr.type === Syntax.SequenceExpression) {\n                for (i = 0; i < expr.expressions.length; i++) {\n                    reinterpretExpressionAsPattern(expr.expressions[i]);\n                }\n            } else {\n                reinterpretExpressionAsPattern(expr);\n            }\n\n            expr = {\n                type: PlaceHolders.ArrowParameterPlaceHolder,\n                params: expr.type === Syntax.SequenceExpression ? expr.expressions : [expr]\n            };\n        }\n        isBindingElement = false;\n        return expr;\n    }\n\n\n    // ECMA-262 12.2 Primary Expressions\n\n    function parsePrimaryExpression() {\n        var type, token, expr, node;\n\n        if (match('(')) {\n            isBindingElement = false;\n            return inheritCoverGrammar(parseGroupExpression);\n        }\n\n        if (match('[')) {\n            return inheritCoverGrammar(parseArrayInitializer);\n        }\n\n        if (match('{')) {\n            return inheritCoverGrammar(parseObjectInitializer);\n        }\n\n        type = lookahead.type;\n        node = new Node();\n\n        if (type === Token.Identifier) {\n            if (state.sourceType === 'module' && lookahead.value === 'await') {\n                tolerateUnexpectedToken(lookahead);\n            }\n            expr = node.finishIdentifier(lex().value);\n        } else if (type === Token.StringLiteral || type === Token.NumericLiteral) {\n            isAssignmentTarget = isBindingElement = false;\n            if (strict && lookahead.octal) {\n                tolerateUnexpectedToken(lookahead, Messages.StrictOctalLiteral);\n            }\n            expr = node.finishLiteral(lex());\n        } else if (type === Token.Keyword) {\n            if (!strict && state.allowYield && matchKeyword('yield')) {\n                return parseNonComputedProperty();\n            }\n            if (!strict && matchKeyword('let')) {\n                return node.finishIdentifier(lex().value);\n            }\n            isAssignmentTarget = isBindingElement = false;\n            if (matchKeyword('function')) {\n                return parseFunctionExpression();\n            }\n            if (matchKeyword('this')) {\n                lex();\n                return node.finishThisExpression();\n            }\n            if (matchKeyword('class')) {\n                return parseClassExpression();\n            }\n            throwUnexpectedToken(lex());\n        } else if (type === Token.BooleanLiteral) {\n            isAssignmentTarget = isBindingElement = false;\n            token = lex();\n            token.value = (token.value === 'true');\n            expr = node.finishLiteral(token);\n        } else if (type === Token.NullLiteral) {\n            isAssignmentTarget = isBindingElement = false;\n            token = lex();\n            token.value = null;\n            expr = node.finishLiteral(token);\n        } else if (match('/') || match('/=')) {\n            isAssignmentTarget = isBindingElement = false;\n            index = startIndex;\n\n            if (typeof extra.tokens !== 'undefined') {\n                token = collectRegex();\n            } else {\n                token = scanRegExp();\n            }\n            lex();\n            expr = node.finishLiteral(token);\n        } else if (type === Token.Template) {\n            expr = parseTemplateLiteral();\n        } else {\n            throwUnexpectedToken(lex());\n        }\n\n        return expr;\n    }\n\n    // ECMA-262 12.3 Left-Hand-Side Expressions\n\n    function parseArguments() {\n        var args = [], expr;\n\n        expect('(');\n\n        if (!match(')')) {\n            while (startIndex < length) {\n                if (match('...')) {\n                    expr = new Node();\n                    lex();\n                    expr.finishSpreadElement(isolateCoverGrammar(parseAssignmentExpression));\n                } else {\n                    expr = isolateCoverGrammar(parseAssignmentExpression);\n                }\n                args.push(expr);\n                if (match(')')) {\n                    break;\n                }\n                expectCommaSeparator();\n            }\n        }\n\n        expect(')');\n\n        return args;\n    }\n\n    function parseNonComputedProperty() {\n        var token, node = new Node();\n\n        token = lex();\n\n        if (!isIdentifierName(token)) {\n            throwUnexpectedToken(token);\n        }\n\n        return node.finishIdentifier(token.value);\n    }\n\n    function parseNonComputedMember() {\n        expect('.');\n\n        return parseNonComputedProperty();\n    }\n\n    function parseComputedMember() {\n        var expr;\n\n        expect('[');\n\n        expr = isolateCoverGrammar(parseExpression);\n\n        expect(']');\n\n        return expr;\n    }\n\n    // ECMA-262 12.3.3 The new Operator\n\n    function parseNewExpression() {\n        var callee, args, node = new Node();\n\n        expectKeyword('new');\n\n        if (match('.')) {\n            lex();\n            if (lookahead.type === Token.Identifier && lookahead.value === 'target') {\n                if (state.inFunctionBody) {\n                    lex();\n                    return node.finishMetaProperty('new', 'target');\n                }\n            }\n            throwUnexpectedToken(lookahead);\n        }\n\n        callee = isolateCoverGrammar(parseLeftHandSideExpression);\n        args = match('(') ? parseArguments() : [];\n\n        isAssignmentTarget = isBindingElement = false;\n\n        return node.finishNewExpression(callee, args);\n    }\n\n    // ECMA-262 12.3.4 Function Calls\n\n    function parseLeftHandSideExpressionAllowCall() {\n        var quasi, expr, args, property, startToken, previousAllowIn = state.allowIn;\n\n        startToken = lookahead;\n        state.allowIn = true;\n\n        if (matchKeyword('super') && state.inFunctionBody) {\n            expr = new Node();\n            lex();\n            expr = expr.finishSuper();\n            if (!match('(') && !match('.') && !match('[')) {\n                throwUnexpectedToken(lookahead);\n            }\n        } else {\n            expr = inheritCoverGrammar(matchKeyword('new') ? parseNewExpression : parsePrimaryExpression);\n        }\n\n        for (;;) {\n            if (match('.')) {\n                isBindingElement = false;\n                isAssignmentTarget = true;\n                property = parseNonComputedMember();\n                expr = new WrappingNode(startToken).finishMemberExpression('.', expr, property);\n            } else if (match('(')) {\n                isBindingElement = false;\n                isAssignmentTarget = false;\n                args = parseArguments();\n                expr = new WrappingNode(startToken).finishCallExpression(expr, args);\n            } else if (match('[')) {\n                isBindingElement = false;\n                isAssignmentTarget = true;\n                property = parseComputedMember();\n                expr = new WrappingNode(startToken).finishMemberExpression('[', expr, property);\n            } else if (lookahead.type === Token.Template && lookahead.head) {\n                quasi = parseTemplateLiteral();\n                expr = new WrappingNode(startToken).finishTaggedTemplateExpression(expr, quasi);\n            } else {\n                break;\n            }\n        }\n        state.allowIn = previousAllowIn;\n\n        return expr;\n    }\n\n    // ECMA-262 12.3 Left-Hand-Side Expressions\n\n    function parseLeftHandSideExpression() {\n        var quasi, expr, property, startToken;\n        assert(state.allowIn, 'callee of new expression always allow in keyword.');\n\n        startToken = lookahead;\n\n        if (matchKeyword('super') && state.inFunctionBody) {\n            expr = new Node();\n            lex();\n            expr = expr.finishSuper();\n            if (!match('[') && !match('.')) {\n                throwUnexpectedToken(lookahead);\n            }\n        } else {\n            expr = inheritCoverGrammar(matchKeyword('new') ? parseNewExpression : parsePrimaryExpression);\n        }\n\n        for (;;) {\n            if (match('[')) {\n                isBindingElement = false;\n                isAssignmentTarget = true;\n                property = parseComputedMember();\n                expr = new WrappingNode(startToken).finishMemberExpression('[', expr, property);\n            } else if (match('.')) {\n                isBindingElement = false;\n                isAssignmentTarget = true;\n                property = parseNonComputedMember();\n                expr = new WrappingNode(startToken).finishMemberExpression('.', expr, property);\n            } else if (lookahead.type === Token.Template && lookahead.head) {\n                quasi = parseTemplateLiteral();\n                expr = new WrappingNode(startToken).finishTaggedTemplateExpression(expr, quasi);\n            } else {\n                break;\n            }\n        }\n        return expr;\n    }\n\n    // ECMA-262 12.4 Postfix Expressions\n\n    function parsePostfixExpression() {\n        var expr, token, startToken = lookahead;\n\n        expr = inheritCoverGrammar(parseLeftHandSideExpressionAllowCall);\n\n        if (!hasLineTerminator && lookahead.type === Token.Punctuator) {\n            if (match('++') || match('--')) {\n                // ECMA-262 11.3.1, 11.3.2\n                if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {\n                    tolerateError(Messages.StrictLHSPostfix);\n                }\n\n                if (!isAssignmentTarget) {\n                    tolerateError(Messages.InvalidLHSInAssignment);\n                }\n\n                isAssignmentTarget = isBindingElement = false;\n\n                token = lex();\n                expr = new WrappingNode(startToken).finishPostfixExpression(token.value, expr);\n            }\n        }\n\n        return expr;\n    }\n\n    // ECMA-262 12.5 Unary Operators\n\n    function parseUnaryExpression() {\n        var token, expr, startToken;\n\n        if (lookahead.type !== Token.Punctuator && lookahead.type !== Token.Keyword) {\n            expr = parsePostfixExpression();\n        } else if (match('++') || match('--')) {\n            startToken = lookahead;\n            token = lex();\n            expr = inheritCoverGrammar(parseUnaryExpression);\n            // ECMA-262 11.4.4, 11.4.5\n            if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {\n                tolerateError(Messages.StrictLHSPrefix);\n            }\n\n            if (!isAssignmentTarget) {\n                tolerateError(Messages.InvalidLHSInAssignment);\n            }\n            expr = new WrappingNode(startToken).finishUnaryExpression(token.value, expr);\n            isAssignmentTarget = isBindingElement = false;\n        } else if (match('+') || match('-') || match('~') || match('!')) {\n            startToken = lookahead;\n            token = lex();\n            expr = inheritCoverGrammar(parseUnaryExpression);\n            expr = new WrappingNode(startToken).finishUnaryExpression(token.value, expr);\n            isAssignmentTarget = isBindingElement = false;\n        } else if (matchKeyword('delete') || matchKeyword('void') || matchKeyword('typeof')) {\n            startToken = lookahead;\n            token = lex();\n            expr = inheritCoverGrammar(parseUnaryExpression);\n            expr = new WrappingNode(startToken).finishUnaryExpression(token.value, expr);\n            if (strict && expr.operator === 'delete' && expr.argument.type === Syntax.Identifier) {\n                tolerateError(Messages.StrictDelete);\n            }\n            isAssignmentTarget = isBindingElement = false;\n        } else {\n            expr = parsePostfixExpression();\n        }\n\n        return expr;\n    }\n\n    function binaryPrecedence(token, allowIn) {\n        var prec = 0;\n\n        if (token.type !== Token.Punctuator && token.type !== Token.Keyword) {\n            return 0;\n        }\n\n        switch (token.value) {\n        case '||':\n            prec = 1;\n            break;\n\n        case '&&':\n            prec = 2;\n            break;\n\n        case '|':\n            prec = 3;\n            break;\n\n        case '^':\n            prec = 4;\n            break;\n\n        case '&':\n            prec = 5;\n            break;\n\n        case '==':\n        case '!=':\n        case '===':\n        case '!==':\n            prec = 6;\n            break;\n\n        case '<':\n        case '>':\n        case '<=':\n        case '>=':\n        case 'instanceof':\n            prec = 7;\n            break;\n\n        case 'in':\n            prec = allowIn ? 7 : 0;\n            break;\n\n        case '<<':\n        case '>>':\n        case '>>>':\n            prec = 8;\n            break;\n\n        case '+':\n        case '-':\n            prec = 9;\n            break;\n\n        case '*':\n        case '/':\n        case '%':\n            prec = 11;\n            break;\n\n        default:\n            break;\n        }\n\n        return prec;\n    }\n\n    // ECMA-262 12.6 Multiplicative Operators\n    // ECMA-262 12.7 Additive Operators\n    // ECMA-262 12.8 Bitwise Shift Operators\n    // ECMA-262 12.9 Relational Operators\n    // ECMA-262 12.10 Equality Operators\n    // ECMA-262 12.11 Binary Bitwise Operators\n    // ECMA-262 12.12 Binary Logical Operators\n\n    function parseBinaryExpression() {\n        var marker, markers, expr, token, prec, stack, right, operator, left, i;\n\n        marker = lookahead;\n        left = inheritCoverGrammar(parseUnaryExpression);\n\n        token = lookahead;\n        prec = binaryPrecedence(token, state.allowIn);\n        if (prec === 0) {\n            return left;\n        }\n        isAssignmentTarget = isBindingElement = false;\n        token.prec = prec;\n        lex();\n\n        markers = [marker, lookahead];\n        right = isolateCoverGrammar(parseUnaryExpression);\n\n        stack = [left, token, right];\n\n        while ((prec = binaryPrecedence(lookahead, state.allowIn)) > 0) {\n\n            // Reduce: make a binary expression from the three topmost entries.\n            while ((stack.length > 2) && (prec <= stack[stack.length - 2].prec)) {\n                right = stack.pop();\n                operator = stack.pop().value;\n                left = stack.pop();\n                markers.pop();\n                expr = new WrappingNode(markers[markers.length - 1]).finishBinaryExpression(operator, left, right);\n                stack.push(expr);\n            }\n\n            // Shift.\n            token = lex();\n            token.prec = prec;\n            stack.push(token);\n            markers.push(lookahead);\n            expr = isolateCoverGrammar(parseUnaryExpression);\n            stack.push(expr);\n        }\n\n        // Final reduce to clean-up the stack.\n        i = stack.length - 1;\n        expr = stack[i];\n        markers.pop();\n        while (i > 1) {\n            expr = new WrappingNode(markers.pop()).finishBinaryExpression(stack[i - 1].value, stack[i - 2], expr);\n            i -= 2;\n        }\n\n        return expr;\n    }\n\n\n    // ECMA-262 12.13 Conditional Operator\n\n    function parseConditionalExpression() {\n        var expr, previousAllowIn, consequent, alternate, startToken;\n\n        startToken = lookahead;\n\n        expr = inheritCoverGrammar(parseBinaryExpression);\n        if (match('?')) {\n            lex();\n            previousAllowIn = state.allowIn;\n            state.allowIn = true;\n            consequent = isolateCoverGrammar(parseAssignmentExpression);\n            state.allowIn = previousAllowIn;\n            expect(':');\n            alternate = isolateCoverGrammar(parseAssignmentExpression);\n\n            expr = new WrappingNode(startToken).finishConditionalExpression(expr, consequent, alternate);\n            isAssignmentTarget = isBindingElement = false;\n        }\n\n        return expr;\n    }\n\n    // ECMA-262 14.2 Arrow Function Definitions\n\n    function parseConciseBody() {\n        if (match('{')) {\n            return parseFunctionSourceElements();\n        }\n        return isolateCoverGrammar(parseAssignmentExpression);\n    }\n\n    function checkPatternParam(options, param) {\n        var i;\n        switch (param.type) {\n        case Syntax.Identifier:\n            validateParam(options, param, param.name);\n            break;\n        case Syntax.RestElement:\n            checkPatternParam(options, param.argument);\n            break;\n        case Syntax.AssignmentPattern:\n            checkPatternParam(options, param.left);\n            break;\n        case Syntax.ArrayPattern:\n            for (i = 0; i < param.elements.length; i++) {\n                if (param.elements[i] !== null) {\n                    checkPatternParam(options, param.elements[i]);\n                }\n            }\n            break;\n        case Syntax.YieldExpression:\n            break;\n        default:\n            assert(param.type === Syntax.ObjectPattern, 'Invalid type');\n            for (i = 0; i < param.properties.length; i++) {\n                checkPatternParam(options, param.properties[i].value);\n            }\n            break;\n        }\n    }\n    function reinterpretAsCoverFormalsList(expr) {\n        var i, len, param, params, defaults, defaultCount, options, token;\n\n        defaults = [];\n        defaultCount = 0;\n        params = [expr];\n\n        switch (expr.type) {\n        case Syntax.Identifier:\n            break;\n        case PlaceHolders.ArrowParameterPlaceHolder:\n            params = expr.params;\n            break;\n        default:\n            return null;\n        }\n\n        options = {\n            paramSet: {}\n        };\n\n        for (i = 0, len = params.length; i < len; i += 1) {\n            param = params[i];\n            switch (param.type) {\n            case Syntax.AssignmentPattern:\n                params[i] = param.left;\n                if (param.right.type === Syntax.YieldExpression) {\n                    if (param.right.argument) {\n                        throwUnexpectedToken(lookahead);\n                    }\n                    param.right.type = Syntax.Identifier;\n                    param.right.name = 'yield';\n                    delete param.right.argument;\n                    delete param.right.delegate;\n                }\n                defaults.push(param.right);\n                ++defaultCount;\n                checkPatternParam(options, param.left);\n                break;\n            default:\n                checkPatternParam(options, param);\n                params[i] = param;\n                defaults.push(null);\n                break;\n            }\n        }\n\n        if (strict || !state.allowYield) {\n            for (i = 0, len = params.length; i < len; i += 1) {\n                param = params[i];\n                if (param.type === Syntax.YieldExpression) {\n                    throwUnexpectedToken(lookahead);\n                }\n            }\n        }\n\n        if (options.message === Messages.StrictParamDupe) {\n            token = strict ? options.stricted : options.firstRestricted;\n            throwUnexpectedToken(token, options.message);\n        }\n\n        if (defaultCount === 0) {\n            defaults = [];\n        }\n\n        return {\n            params: params,\n            defaults: defaults,\n            stricted: options.stricted,\n            firstRestricted: options.firstRestricted,\n            message: options.message\n        };\n    }\n\n    function parseArrowFunctionExpression(options, node) {\n        var previousStrict, previousAllowYield, body;\n\n        if (hasLineTerminator) {\n            tolerateUnexpectedToken(lookahead);\n        }\n        expect('=>');\n\n        previousStrict = strict;\n        previousAllowYield = state.allowYield;\n        state.allowYield = true;\n\n        body = parseConciseBody();\n\n        if (strict && options.firstRestricted) {\n            throwUnexpectedToken(options.firstRestricted, options.message);\n        }\n        if (strict && options.stricted) {\n            tolerateUnexpectedToken(options.stricted, options.message);\n        }\n\n        strict = previousStrict;\n        state.allowYield = previousAllowYield;\n\n        return node.finishArrowFunctionExpression(options.params, options.defaults, body, body.type !== Syntax.BlockStatement);\n    }\n\n    // ECMA-262 14.4 Yield expression\n\n    function parseYieldExpression() {\n        var argument, expr, delegate, previousAllowYield;\n\n        argument = null;\n        expr = new Node();\n        delegate = false;\n\n        expectKeyword('yield');\n\n        if (!hasLineTerminator) {\n            previousAllowYield = state.allowYield;\n            state.allowYield = false;\n            delegate = match('*');\n            if (delegate) {\n                lex();\n                argument = parseAssignmentExpression();\n            } else {\n                if (!match(';') && !match('}') && !match(')') && lookahead.type !== Token.EOF) {\n                    argument = parseAssignmentExpression();\n                }\n            }\n            state.allowYield = previousAllowYield;\n        }\n\n        return expr.finishYieldExpression(argument, delegate);\n    }\n\n    // ECMA-262 12.14 Assignment Operators\n\n    function parseAssignmentExpression() {\n        var token, expr, right, list, startToken;\n\n        startToken = lookahead;\n        token = lookahead;\n\n        if (!state.allowYield && matchKeyword('yield')) {\n            return parseYieldExpression();\n        }\n\n        expr = parseConditionalExpression();\n\n        if (expr.type === PlaceHolders.ArrowParameterPlaceHolder || match('=>')) {\n            isAssignmentTarget = isBindingElement = false;\n            list = reinterpretAsCoverFormalsList(expr);\n\n            if (list) {\n                firstCoverInitializedNameError = null;\n                return parseArrowFunctionExpression(list, new WrappingNode(startToken));\n            }\n\n            return expr;\n        }\n\n        if (matchAssign()) {\n            if (!isAssignmentTarget) {\n                tolerateError(Messages.InvalidLHSInAssignment);\n            }\n\n            // ECMA-262 12.1.1\n            if (strict && expr.type === Syntax.Identifier) {\n                if (isRestrictedWord(expr.name)) {\n                    tolerateUnexpectedToken(token, Messages.StrictLHSAssignment);\n                }\n                if (isStrictModeReservedWord(expr.name)) {\n                    tolerateUnexpectedToken(token, Messages.StrictReservedWord);\n                }\n            }\n\n            if (!match('=')) {\n                isAssignmentTarget = isBindingElement = false;\n            } else {\n                reinterpretExpressionAsPattern(expr);\n            }\n\n            token = lex();\n            right = isolateCoverGrammar(parseAssignmentExpression);\n            expr = new WrappingNode(startToken).finishAssignmentExpression(token.value, expr, right);\n            firstCoverInitializedNameError = null;\n        }\n\n        return expr;\n    }\n\n    // ECMA-262 12.15 Comma Operator\n\n    function parseExpression() {\n        var expr, startToken = lookahead, expressions;\n\n        expr = isolateCoverGrammar(parseAssignmentExpression);\n\n        if (match(',')) {\n            expressions = [expr];\n\n            while (startIndex < length) {\n                if (!match(',')) {\n                    break;\n                }\n                lex();\n                expressions.push(isolateCoverGrammar(parseAssignmentExpression));\n            }\n\n            expr = new WrappingNode(startToken).finishSequenceExpression(expressions);\n        }\n\n        return expr;\n    }\n\n    // ECMA-262 13.2 Block\n\n    function parseStatementListItem() {\n        if (lookahead.type === Token.Keyword) {\n            switch (lookahead.value) {\n            case 'export':\n                if (state.sourceType !== 'module') {\n                    tolerateUnexpectedToken(lookahead, Messages.IllegalExportDeclaration);\n                }\n                return parseExportDeclaration();\n            case 'import':\n                if (state.sourceType !== 'module') {\n                    tolerateUnexpectedToken(lookahead, Messages.IllegalImportDeclaration);\n                }\n                return parseImportDeclaration();\n            case 'const':\n                return parseLexicalDeclaration({inFor: false});\n            case 'function':\n                return parseFunctionDeclaration(new Node());\n            case 'class':\n                return parseClassDeclaration();\n            }\n        }\n\n        if (matchKeyword('let') && isLexicalDeclaration()) {\n            return parseLexicalDeclaration({inFor: false});\n        }\n\n        return parseStatement();\n    }\n\n    function parseStatementList() {\n        var list = [];\n        while (startIndex < length) {\n            if (match('}')) {\n                break;\n            }\n            list.push(parseStatementListItem());\n        }\n\n        return list;\n    }\n\n    function parseBlock() {\n        var block, node = new Node();\n\n        expect('{');\n\n        block = parseStatementList();\n\n        expect('}');\n\n        return node.finishBlockStatement(block);\n    }\n\n    // ECMA-262 13.3.2 Variable Statement\n\n    function parseVariableIdentifier(kind) {\n        var token, node = new Node();\n\n        token = lex();\n\n        if (token.type === Token.Keyword && token.value === 'yield') {\n            if (strict) {\n                tolerateUnexpectedToken(token, Messages.StrictReservedWord);\n            } if (!state.allowYield) {\n                throwUnexpectedToken(token);\n            }\n        } else if (token.type !== Token.Identifier) {\n            if (strict && token.type === Token.Keyword && isStrictModeReservedWord(token.value)) {\n                tolerateUnexpectedToken(token, Messages.StrictReservedWord);\n            } else {\n                if (strict || token.value !== 'let' || kind !== 'var') {\n                    throwUnexpectedToken(token);\n                }\n            }\n        } else if (state.sourceType === 'module' && token.type === Token.Identifier && token.value === 'await') {\n            tolerateUnexpectedToken(token);\n        }\n\n        return node.finishIdentifier(token.value);\n    }\n\n    function parseVariableDeclaration(options) {\n        var init = null, id, node = new Node(), params = [];\n\n        id = parsePattern(params, 'var');\n\n        // ECMA-262 12.2.1\n        if (strict && isRestrictedWord(id.name)) {\n            tolerateError(Messages.StrictVarName);\n        }\n\n        if (match('=')) {\n            lex();\n            init = isolateCoverGrammar(parseAssignmentExpression);\n        } else if (id.type !== Syntax.Identifier && !options.inFor) {\n            expect('=');\n        }\n\n        return node.finishVariableDeclarator(id, init);\n    }\n\n    function parseVariableDeclarationList(options) {\n        var opt, list;\n\n        opt = { inFor: options.inFor };\n        list = [parseVariableDeclaration(opt)];\n\n        while (match(',')) {\n            lex();\n            list.push(parseVariableDeclaration(opt));\n        }\n\n        return list;\n    }\n\n    function parseVariableStatement(node) {\n        var declarations;\n\n        expectKeyword('var');\n\n        declarations = parseVariableDeclarationList({ inFor: false });\n\n        consumeSemicolon();\n\n        return node.finishVariableDeclaration(declarations);\n    }\n\n    // ECMA-262 13.3.1 Let and Const Declarations\n\n    function parseLexicalBinding(kind, options) {\n        var init = null, id, node = new Node(), params = [];\n\n        id = parsePattern(params, kind);\n\n        // ECMA-262 12.2.1\n        if (strict && id.type === Syntax.Identifier && isRestrictedWord(id.name)) {\n            tolerateError(Messages.StrictVarName);\n        }\n\n        if (kind === 'const') {\n            if (!matchKeyword('in') && !matchContextualKeyword('of')) {\n                expect('=');\n                init = isolateCoverGrammar(parseAssignmentExpression);\n            }\n        } else if ((!options.inFor && id.type !== Syntax.Identifier) || match('=')) {\n            expect('=');\n            init = isolateCoverGrammar(parseAssignmentExpression);\n        }\n\n        return node.finishVariableDeclarator(id, init);\n    }\n\n    function parseBindingList(kind, options) {\n        var list = [parseLexicalBinding(kind, options)];\n\n        while (match(',')) {\n            lex();\n            list.push(parseLexicalBinding(kind, options));\n        }\n\n        return list;\n    }\n\n\n    function tokenizerState() {\n        return {\n            index: index,\n            lineNumber: lineNumber,\n            lineStart: lineStart,\n            hasLineTerminator: hasLineTerminator,\n            lastIndex: lastIndex,\n            lastLineNumber: lastLineNumber,\n            lastLineStart: lastLineStart,\n            startIndex: startIndex,\n            startLineNumber: startLineNumber,\n            startLineStart: startLineStart,\n            lookahead: lookahead,\n            tokenCount: extra.tokens ? extra.tokens.length : 0\n        };\n    }\n\n    function resetTokenizerState(ts) {\n        index = ts.index;\n        lineNumber = ts.lineNumber;\n        lineStart = ts.lineStart;\n        hasLineTerminator = ts.hasLineTerminator;\n        lastIndex = ts.lastIndex;\n        lastLineNumber = ts.lastLineNumber;\n        lastLineStart = ts.lastLineStart;\n        startIndex = ts.startIndex;\n        startLineNumber = ts.startLineNumber;\n        startLineStart = ts.startLineStart;\n        lookahead = ts.lookahead;\n        if (extra.tokens) {\n            extra.tokens.splice(ts.tokenCount, extra.tokens.length);\n        }\n    }\n\n    function isLexicalDeclaration() {\n        var lexical, ts;\n\n        ts = tokenizerState();\n\n        lex();\n        lexical = (lookahead.type === Token.Identifier) || match('[') || match('{') ||\n            matchKeyword('let') || matchKeyword('yield');\n\n        resetTokenizerState(ts);\n\n        return lexical;\n    }\n\n    function parseLexicalDeclaration(options) {\n        var kind, declarations, node = new Node();\n\n        kind = lex().value;\n        assert(kind === 'let' || kind === 'const', 'Lexical declaration must be either let or const');\n\n        declarations = parseBindingList(kind, options);\n\n        consumeSemicolon();\n\n        return node.finishLexicalDeclaration(declarations, kind);\n    }\n\n    function parseRestElement(params) {\n        var param, node = new Node();\n\n        lex();\n\n        if (match('{')) {\n            throwError(Messages.ObjectPatternAsRestParameter);\n        }\n\n        params.push(lookahead);\n\n        param = parseVariableIdentifier();\n\n        if (match('=')) {\n            throwError(Messages.DefaultRestParameter);\n        }\n\n        if (!match(')')) {\n            throwError(Messages.ParameterAfterRestParameter);\n        }\n\n        return node.finishRestElement(param);\n    }\n\n    // ECMA-262 13.4 Empty Statement\n\n    function parseEmptyStatement(node) {\n        expect(';');\n        return node.finishEmptyStatement();\n    }\n\n    // ECMA-262 12.4 Expression Statement\n\n    function parseExpressionStatement(node) {\n        var expr = parseExpression();\n        consumeSemicolon();\n        return node.finishExpressionStatement(expr);\n    }\n\n    // ECMA-262 13.6 If statement\n\n    function parseIfStatement(node) {\n        var test, consequent, alternate;\n\n        expectKeyword('if');\n\n        expect('(');\n\n        test = parseExpression();\n\n        expect(')');\n\n        consequent = parseStatement();\n\n        if (matchKeyword('else')) {\n            lex();\n            alternate = parseStatement();\n        } else {\n            alternate = null;\n        }\n\n        return node.finishIfStatement(test, consequent, alternate);\n    }\n\n    // ECMA-262 13.7 Iteration Statements\n\n    function parseDoWhileStatement(node) {\n        var body, test, oldInIteration;\n\n        expectKeyword('do');\n\n        oldInIteration = state.inIteration;\n        state.inIteration = true;\n\n        body = parseStatement();\n\n        state.inIteration = oldInIteration;\n\n        expectKeyword('while');\n\n        expect('(');\n\n        test = parseExpression();\n\n        expect(')');\n\n        if (match(';')) {\n            lex();\n        }\n\n        return node.finishDoWhileStatement(body, test);\n    }\n\n    function parseWhileStatement(node) {\n        var test, body, oldInIteration;\n\n        expectKeyword('while');\n\n        expect('(');\n\n        test = parseExpression();\n\n        expect(')');\n\n        oldInIteration = state.inIteration;\n        state.inIteration = true;\n\n        body = parseStatement();\n\n        state.inIteration = oldInIteration;\n\n        return node.finishWhileStatement(test, body);\n    }\n\n    function parseForStatement(node) {\n        var init, forIn, initSeq, initStartToken, test, update, left, right, kind, declarations,\n            body, oldInIteration, previousAllowIn = state.allowIn;\n\n        init = test = update = null;\n        forIn = true;\n\n        expectKeyword('for');\n\n        expect('(');\n\n        if (match(';')) {\n            lex();\n        } else {\n            if (matchKeyword('var')) {\n                init = new Node();\n                lex();\n\n                state.allowIn = false;\n                declarations = parseVariableDeclarationList({ inFor: true });\n                state.allowIn = previousAllowIn;\n\n                if (declarations.length === 1 && matchKeyword('in')) {\n                    init = init.finishVariableDeclaration(declarations);\n                    lex();\n                    left = init;\n                    right = parseExpression();\n                    init = null;\n                } else if (declarations.length === 1 && declarations[0].init === null && matchContextualKeyword('of')) {\n                    init = init.finishVariableDeclaration(declarations);\n                    lex();\n                    left = init;\n                    right = parseAssignmentExpression();\n                    init = null;\n                    forIn = false;\n                } else {\n                    init = init.finishVariableDeclaration(declarations);\n                    expect(';');\n                }\n            } else if (matchKeyword('const') || matchKeyword('let')) {\n                init = new Node();\n                kind = lex().value;\n\n                if (!strict && lookahead.value === 'in') {\n                    init = init.finishIdentifier(kind);\n                    lex();\n                    left = init;\n                    right = parseExpression();\n                    init = null;\n                } else {\n                    state.allowIn = false;\n                    declarations = parseBindingList(kind, {inFor: true});\n                    state.allowIn = previousAllowIn;\n\n                    if (declarations.length === 1 && declarations[0].init === null && matchKeyword('in')) {\n                        init = init.finishLexicalDeclaration(declarations, kind);\n                        lex();\n                        left = init;\n                        right = parseExpression();\n                        init = null;\n                    } else if (declarations.length === 1 && declarations[0].init === null && matchContextualKeyword('of')) {\n                        init = init.finishLexicalDeclaration(declarations, kind);\n                        lex();\n                        left = init;\n                        right = parseAssignmentExpression();\n                        init = null;\n                        forIn = false;\n                    } else {\n                        consumeSemicolon();\n                        init = init.finishLexicalDeclaration(declarations, kind);\n                    }\n                }\n            } else {\n                initStartToken = lookahead;\n                state.allowIn = false;\n                init = inheritCoverGrammar(parseAssignmentExpression);\n                state.allowIn = previousAllowIn;\n\n                if (matchKeyword('in')) {\n                    if (!isAssignmentTarget) {\n                        tolerateError(Messages.InvalidLHSInForIn);\n                    }\n\n                    lex();\n                    reinterpretExpressionAsPattern(init);\n                    left = init;\n                    right = parseExpression();\n                    init = null;\n                } else if (matchContextualKeyword('of')) {\n                    if (!isAssignmentTarget) {\n                        tolerateError(Messages.InvalidLHSInForLoop);\n                    }\n\n                    lex();\n                    reinterpretExpressionAsPattern(init);\n                    left = init;\n                    right = parseAssignmentExpression();\n                    init = null;\n                    forIn = false;\n                } else {\n                    if (match(',')) {\n                        initSeq = [init];\n                        while (match(',')) {\n                            lex();\n                            initSeq.push(isolateCoverGrammar(parseAssignmentExpression));\n                        }\n                        init = new WrappingNode(initStartToken).finishSequenceExpression(initSeq);\n                    }\n                    expect(';');\n                }\n            }\n        }\n\n        if (typeof left === 'undefined') {\n\n            if (!match(';')) {\n                test = parseExpression();\n            }\n            expect(';');\n\n            if (!match(')')) {\n                update = parseExpression();\n            }\n        }\n\n        expect(')');\n\n        oldInIteration = state.inIteration;\n        state.inIteration = true;\n\n        body = isolateCoverGrammar(parseStatement);\n\n        state.inIteration = oldInIteration;\n\n        return (typeof left === 'undefined') ?\n                node.finishForStatement(init, test, update, body) :\n                forIn ? node.finishForInStatement(left, right, body) :\n                    node.finishForOfStatement(left, right, body);\n    }\n\n    // ECMA-262 13.8 The continue statement\n\n    function parseContinueStatement(node) {\n        var label = null, key;\n\n        expectKeyword('continue');\n\n        // Optimize the most common form: 'continue;'.\n        if (source.charCodeAt(startIndex) === 0x3B) {\n            lex();\n\n            if (!state.inIteration) {\n                throwError(Messages.IllegalContinue);\n            }\n\n            return node.finishContinueStatement(null);\n        }\n\n        if (hasLineTerminator) {\n            if (!state.inIteration) {\n                throwError(Messages.IllegalContinue);\n            }\n\n            return node.finishContinueStatement(null);\n        }\n\n        if (lookahead.type === Token.Identifier) {\n            label = parseVariableIdentifier();\n\n            key = '$' + label.name;\n            if (!Object.prototype.hasOwnProperty.call(state.labelSet, key)) {\n                throwError(Messages.UnknownLabel, label.name);\n            }\n        }\n\n        consumeSemicolon();\n\n        if (label === null && !state.inIteration) {\n            throwError(Messages.IllegalContinue);\n        }\n\n        return node.finishContinueStatement(label);\n    }\n\n    // ECMA-262 13.9 The break statement\n\n    function parseBreakStatement(node) {\n        var label = null, key;\n\n        expectKeyword('break');\n\n        // Catch the very common case first: immediately a semicolon (U+003B).\n        if (source.charCodeAt(lastIndex) === 0x3B) {\n            lex();\n\n            if (!(state.inIteration || state.inSwitch)) {\n                throwError(Messages.IllegalBreak);\n            }\n\n            return node.finishBreakStatement(null);\n        }\n\n        if (hasLineTerminator) {\n            if (!(state.inIteration || state.inSwitch)) {\n                throwError(Messages.IllegalBreak);\n            }\n        } else if (lookahead.type === Token.Identifier) {\n            label = parseVariableIdentifier();\n\n            key = '$' + label.name;\n            if (!Object.prototype.hasOwnProperty.call(state.labelSet, key)) {\n                throwError(Messages.UnknownLabel, label.name);\n            }\n        }\n\n        consumeSemicolon();\n\n        if (label === null && !(state.inIteration || state.inSwitch)) {\n            throwError(Messages.IllegalBreak);\n        }\n\n        return node.finishBreakStatement(label);\n    }\n\n    // ECMA-262 13.10 The return statement\n\n    function parseReturnStatement(node) {\n        var argument = null;\n\n        expectKeyword('return');\n\n        if (!state.inFunctionBody) {\n            tolerateError(Messages.IllegalReturn);\n        }\n\n        // 'return' followed by a space and an identifier is very common.\n        if (source.charCodeAt(lastIndex) === 0x20) {\n            if (isIdentifierStart(source.charCodeAt(lastIndex + 1))) {\n                argument = parseExpression();\n                consumeSemicolon();\n                return node.finishReturnStatement(argument);\n            }\n        }\n\n        if (hasLineTerminator) {\n            // HACK\n            return node.finishReturnStatement(null);\n        }\n\n        if (!match(';')) {\n            if (!match('}') && lookahead.type !== Token.EOF) {\n                argument = parseExpression();\n            }\n        }\n\n        consumeSemicolon();\n\n        return node.finishReturnStatement(argument);\n    }\n\n    // ECMA-262 13.11 The with statement\n\n    function parseWithStatement(node) {\n        var object, body;\n\n        if (strict) {\n            tolerateError(Messages.StrictModeWith);\n        }\n\n        expectKeyword('with');\n\n        expect('(');\n\n        object = parseExpression();\n\n        expect(')');\n\n        body = parseStatement();\n\n        return node.finishWithStatement(object, body);\n    }\n\n    // ECMA-262 13.12 The switch statement\n\n    function parseSwitchCase() {\n        var test, consequent = [], statement, node = new Node();\n\n        if (matchKeyword('default')) {\n            lex();\n            test = null;\n        } else {\n            expectKeyword('case');\n            test = parseExpression();\n        }\n        expect(':');\n\n        while (startIndex < length) {\n            if (match('}') || matchKeyword('default') || matchKeyword('case')) {\n                break;\n            }\n            statement = parseStatementListItem();\n            consequent.push(statement);\n        }\n\n        return node.finishSwitchCase(test, consequent);\n    }\n\n    function parseSwitchStatement(node) {\n        var discriminant, cases, clause, oldInSwitch, defaultFound;\n\n        expectKeyword('switch');\n\n        expect('(');\n\n        discriminant = parseExpression();\n\n        expect(')');\n\n        expect('{');\n\n        cases = [];\n\n        if (match('}')) {\n            lex();\n            return node.finishSwitchStatement(discriminant, cases);\n        }\n\n        oldInSwitch = state.inSwitch;\n        state.inSwitch = true;\n        defaultFound = false;\n\n        while (startIndex < length) {\n            if (match('}')) {\n                break;\n            }\n            clause = parseSwitchCase();\n            if (clause.test === null) {\n                if (defaultFound) {\n                    throwError(Messages.MultipleDefaultsInSwitch);\n                }\n                defaultFound = true;\n            }\n            cases.push(clause);\n        }\n\n        state.inSwitch = oldInSwitch;\n\n        expect('}');\n\n        return node.finishSwitchStatement(discriminant, cases);\n    }\n\n    // ECMA-262 13.14 The throw statement\n\n    function parseThrowStatement(node) {\n        var argument;\n\n        expectKeyword('throw');\n\n        if (hasLineTerminator) {\n            throwError(Messages.NewlineAfterThrow);\n        }\n\n        argument = parseExpression();\n\n        consumeSemicolon();\n\n        return node.finishThrowStatement(argument);\n    }\n\n    // ECMA-262 13.15 The try statement\n\n    function parseCatchClause() {\n        var param, params = [], paramMap = {}, key, i, body, node = new Node();\n\n        expectKeyword('catch');\n\n        expect('(');\n        if (match(')')) {\n            throwUnexpectedToken(lookahead);\n        }\n\n        param = parsePattern(params);\n        for (i = 0; i < params.length; i++) {\n            key = '$' + params[i].value;\n            if (Object.prototype.hasOwnProperty.call(paramMap, key)) {\n                tolerateError(Messages.DuplicateBinding, params[i].value);\n            }\n            paramMap[key] = true;\n        }\n\n        // ECMA-262 12.14.1\n        if (strict && isRestrictedWord(param.name)) {\n            tolerateError(Messages.StrictCatchVariable);\n        }\n\n        expect(')');\n        body = parseBlock();\n        return node.finishCatchClause(param, body);\n    }\n\n    function parseTryStatement(node) {\n        var block, handler = null, finalizer = null;\n\n        expectKeyword('try');\n\n        block = parseBlock();\n\n        if (matchKeyword('catch')) {\n            handler = parseCatchClause();\n        }\n\n        if (matchKeyword('finally')) {\n            lex();\n            finalizer = parseBlock();\n        }\n\n        if (!handler && !finalizer) {\n            throwError(Messages.NoCatchOrFinally);\n        }\n\n        return node.finishTryStatement(block, handler, finalizer);\n    }\n\n    // ECMA-262 13.16 The debugger statement\n\n    function parseDebuggerStatement(node) {\n        expectKeyword('debugger');\n\n        consumeSemicolon();\n\n        return node.finishDebuggerStatement();\n    }\n\n    // 13 Statements\n\n    function parseStatement() {\n        var type = lookahead.type,\n            expr,\n            labeledBody,\n            key,\n            node;\n\n        if (type === Token.EOF) {\n            throwUnexpectedToken(lookahead);\n        }\n\n        if (type === Token.Punctuator && lookahead.value === '{') {\n            return parseBlock();\n        }\n        isAssignmentTarget = isBindingElement = true;\n        node = new Node();\n\n        if (type === Token.Punctuator) {\n            switch (lookahead.value) {\n            case ';':\n                return parseEmptyStatement(node);\n            case '(':\n                return parseExpressionStatement(node);\n            default:\n                break;\n            }\n        } else if (type === Token.Keyword) {\n            switch (lookahead.value) {\n            case 'break':\n                return parseBreakStatement(node);\n            case 'continue':\n                return parseContinueStatement(node);\n            case 'debugger':\n                return parseDebuggerStatement(node);\n            case 'do':\n                return parseDoWhileStatement(node);\n            case 'for':\n                return parseForStatement(node);\n            case 'function':\n                return parseFunctionDeclaration(node);\n            case 'if':\n                return parseIfStatement(node);\n            case 'return':\n                return parseReturnStatement(node);\n            case 'switch':\n                return parseSwitchStatement(node);\n            case 'throw':\n                return parseThrowStatement(node);\n            case 'try':\n                return parseTryStatement(node);\n            case 'var':\n                return parseVariableStatement(node);\n            case 'while':\n                return parseWhileStatement(node);\n            case 'with':\n                return parseWithStatement(node);\n            default:\n                break;\n            }\n        }\n\n        expr = parseExpression();\n\n        // ECMA-262 12.12 Labelled Statements\n        if ((expr.type === Syntax.Identifier) && match(':')) {\n            lex();\n\n            key = '$' + expr.name;\n            if (Object.prototype.hasOwnProperty.call(state.labelSet, key)) {\n                throwError(Messages.Redeclaration, 'Label', expr.name);\n            }\n\n            state.labelSet[key] = true;\n            labeledBody = parseStatement();\n            delete state.labelSet[key];\n            return node.finishLabeledStatement(expr, labeledBody);\n        }\n\n        consumeSemicolon();\n\n        return node.finishExpressionStatement(expr);\n    }\n\n    // ECMA-262 14.1 Function Definition\n\n    function parseFunctionSourceElements() {\n        var statement, body = [], token, directive, firstRestricted,\n            oldLabelSet, oldInIteration, oldInSwitch, oldInFunctionBody,\n            node = new Node();\n\n        expect('{');\n\n        while (startIndex < length) {\n            if (lookahead.type !== Token.StringLiteral) {\n                break;\n            }\n            token = lookahead;\n\n            statement = parseStatementListItem();\n            body.push(statement);\n            if (statement.expression.type !== Syntax.Literal) {\n                // this is not directive\n                break;\n            }\n            directive = source.slice(token.start + 1, token.end - 1);\n            if (directive === 'use strict') {\n                strict = true;\n                if (firstRestricted) {\n                    tolerateUnexpectedToken(firstRestricted, Messages.StrictOctalLiteral);\n                }\n            } else {\n                if (!firstRestricted && token.octal) {\n                    firstRestricted = token;\n                }\n            }\n        }\n\n        oldLabelSet = state.labelSet;\n        oldInIteration = state.inIteration;\n        oldInSwitch = state.inSwitch;\n        oldInFunctionBody = state.inFunctionBody;\n\n        state.labelSet = {};\n        state.inIteration = false;\n        state.inSwitch = false;\n        state.inFunctionBody = true;\n\n        while (startIndex < length) {\n            if (match('}')) {\n                break;\n            }\n            body.push(parseStatementListItem());\n        }\n\n        expect('}');\n\n        state.labelSet = oldLabelSet;\n        state.inIteration = oldInIteration;\n        state.inSwitch = oldInSwitch;\n        state.inFunctionBody = oldInFunctionBody;\n\n        return node.finishBlockStatement(body);\n    }\n\n    function validateParam(options, param, name) {\n        var key = '$' + name;\n        if (strict) {\n            if (isRestrictedWord(name)) {\n                options.stricted = param;\n                options.message = Messages.StrictParamName;\n            }\n            if (Object.prototype.hasOwnProperty.call(options.paramSet, key)) {\n                options.stricted = param;\n                options.message = Messages.StrictParamDupe;\n            }\n        } else if (!options.firstRestricted) {\n            if (isRestrictedWord(name)) {\n                options.firstRestricted = param;\n                options.message = Messages.StrictParamName;\n            } else if (isStrictModeReservedWord(name)) {\n                options.firstRestricted = param;\n                options.message = Messages.StrictReservedWord;\n            } else if (Object.prototype.hasOwnProperty.call(options.paramSet, key)) {\n                options.stricted = param;\n                options.message = Messages.StrictParamDupe;\n            }\n        }\n        options.paramSet[key] = true;\n    }\n\n    function parseParam(options) {\n        var token, param, params = [], i, def;\n\n        token = lookahead;\n        if (token.value === '...') {\n            param = parseRestElement(params);\n            validateParam(options, param.argument, param.argument.name);\n            options.params.push(param);\n            options.defaults.push(null);\n            return false;\n        }\n\n        param = parsePatternWithDefault(params);\n        for (i = 0; i < params.length; i++) {\n            validateParam(options, params[i], params[i].value);\n        }\n\n        if (param.type === Syntax.AssignmentPattern) {\n            def = param.right;\n            param = param.left;\n            ++options.defaultCount;\n        }\n\n        options.params.push(param);\n        options.defaults.push(def);\n\n        return !match(')');\n    }\n\n    function parseParams(firstRestricted) {\n        var options;\n\n        options = {\n            params: [],\n            defaultCount: 0,\n            defaults: [],\n            firstRestricted: firstRestricted\n        };\n\n        expect('(');\n\n        if (!match(')')) {\n            options.paramSet = {};\n            while (startIndex < length) {\n                if (!parseParam(options)) {\n                    break;\n                }\n                expect(',');\n            }\n        }\n\n        expect(')');\n\n        if (options.defaultCount === 0) {\n            options.defaults = [];\n        }\n\n        return {\n            params: options.params,\n            defaults: options.defaults,\n            stricted: options.stricted,\n            firstRestricted: options.firstRestricted,\n            message: options.message\n        };\n    }\n\n    function parseFunctionDeclaration(node, identifierIsOptional) {\n        var id = null, params = [], defaults = [], body, token, stricted, tmp, firstRestricted, message, previousStrict,\n            isGenerator, previousAllowYield;\n\n        previousAllowYield = state.allowYield;\n\n        expectKeyword('function');\n\n        isGenerator = match('*');\n        if (isGenerator) {\n            lex();\n        }\n\n        if (!identifierIsOptional || !match('(')) {\n            token = lookahead;\n            id = parseVariableIdentifier();\n            if (strict) {\n                if (isRestrictedWord(token.value)) {\n                    tolerateUnexpectedToken(token, Messages.StrictFunctionName);\n                }\n            } else {\n                if (isRestrictedWord(token.value)) {\n                    firstRestricted = token;\n                    message = Messages.StrictFunctionName;\n                } else if (isStrictModeReservedWord(token.value)) {\n                    firstRestricted = token;\n                    message = Messages.StrictReservedWord;\n                }\n            }\n        }\n\n        state.allowYield = !isGenerator;\n        tmp = parseParams(firstRestricted);\n        params = tmp.params;\n        defaults = tmp.defaults;\n        stricted = tmp.stricted;\n        firstRestricted = tmp.firstRestricted;\n        if (tmp.message) {\n            message = tmp.message;\n        }\n\n\n        previousStrict = strict;\n        body = parseFunctionSourceElements();\n        if (strict && firstRestricted) {\n            throwUnexpectedToken(firstRestricted, message);\n        }\n        if (strict && stricted) {\n            tolerateUnexpectedToken(stricted, message);\n        }\n\n        strict = previousStrict;\n        state.allowYield = previousAllowYield;\n\n        return node.finishFunctionDeclaration(id, params, defaults, body, isGenerator);\n    }\n\n    function parseFunctionExpression() {\n        var token, id = null, stricted, firstRestricted, message, tmp,\n            params = [], defaults = [], body, previousStrict, node = new Node(),\n            isGenerator, previousAllowYield;\n\n        previousAllowYield = state.allowYield;\n\n        expectKeyword('function');\n\n        isGenerator = match('*');\n        if (isGenerator) {\n            lex();\n        }\n\n        state.allowYield = !isGenerator;\n        if (!match('(')) {\n            token = lookahead;\n            id = (!strict && !isGenerator && matchKeyword('yield')) ? parseNonComputedProperty() : parseVariableIdentifier();\n            if (strict) {\n                if (isRestrictedWord(token.value)) {\n                    tolerateUnexpectedToken(token, Messages.StrictFunctionName);\n                }\n            } else {\n                if (isRestrictedWord(token.value)) {\n                    firstRestricted = token;\n                    message = Messages.StrictFunctionName;\n                } else if (isStrictModeReservedWord(token.value)) {\n                    firstRestricted = token;\n                    message = Messages.StrictReservedWord;\n                }\n            }\n        }\n\n        tmp = parseParams(firstRestricted);\n        params = tmp.params;\n        defaults = tmp.defaults;\n        stricted = tmp.stricted;\n        firstRestricted = tmp.firstRestricted;\n        if (tmp.message) {\n            message = tmp.message;\n        }\n\n        previousStrict = strict;\n        body = parseFunctionSourceElements();\n        if (strict && firstRestricted) {\n            throwUnexpectedToken(firstRestricted, message);\n        }\n        if (strict && stricted) {\n            tolerateUnexpectedToken(stricted, message);\n        }\n        strict = previousStrict;\n        state.allowYield = previousAllowYield;\n\n        return node.finishFunctionExpression(id, params, defaults, body, isGenerator);\n    }\n\n    // ECMA-262 14.5 Class Definitions\n\n    function parseClassBody() {\n        var classBody, token, isStatic, hasConstructor = false, body, method, computed, key;\n\n        classBody = new Node();\n\n        expect('{');\n        body = [];\n        while (!match('}')) {\n            if (match(';')) {\n                lex();\n            } else {\n                method = new Node();\n                token = lookahead;\n                isStatic = false;\n                computed = match('[');\n                if (match('*')) {\n                    lex();\n                } else {\n                    key = parseObjectPropertyKey();\n                    if (key.name === 'static' && (lookaheadPropertyName() || match('*'))) {\n                        token = lookahead;\n                        isStatic = true;\n                        computed = match('[');\n                        if (match('*')) {\n                            lex();\n                        } else {\n                            key = parseObjectPropertyKey();\n                        }\n                    }\n                }\n                method = tryParseMethodDefinition(token, key, computed, method);\n                if (method) {\n                    method['static'] = isStatic; // jscs:ignore requireDotNotation\n                    if (method.kind === 'init') {\n                        method.kind = 'method';\n                    }\n                    if (!isStatic) {\n                        if (!method.computed && (method.key.name || method.key.value.toString()) === 'constructor') {\n                            if (method.kind !== 'method' || !method.method || method.value.generator) {\n                                throwUnexpectedToken(token, Messages.ConstructorSpecialMethod);\n                            }\n                            if (hasConstructor) {\n                                throwUnexpectedToken(token, Messages.DuplicateConstructor);\n                            } else {\n                                hasConstructor = true;\n                            }\n                            method.kind = 'constructor';\n                        }\n                    } else {\n                        if (!method.computed && (method.key.name || method.key.value.toString()) === 'prototype') {\n                            throwUnexpectedToken(token, Messages.StaticPrototype);\n                        }\n                    }\n                    method.type = Syntax.MethodDefinition;\n                    delete method.method;\n                    delete method.shorthand;\n                    body.push(method);\n                } else {\n                    throwUnexpectedToken(lookahead);\n                }\n            }\n        }\n        lex();\n        return classBody.finishClassBody(body);\n    }\n\n    function parseClassDeclaration(identifierIsOptional) {\n        var id = null, superClass = null, classNode = new Node(), classBody, previousStrict = strict;\n        strict = true;\n\n        expectKeyword('class');\n\n        if (!identifierIsOptional || lookahead.type === Token.Identifier) {\n            id = parseVariableIdentifier();\n        }\n\n        if (matchKeyword('extends')) {\n            lex();\n            superClass = isolateCoverGrammar(parseLeftHandSideExpressionAllowCall);\n        }\n        classBody = parseClassBody();\n        strict = previousStrict;\n\n        return classNode.finishClassDeclaration(id, superClass, classBody);\n    }\n\n    function parseClassExpression() {\n        var id = null, superClass = null, classNode = new Node(), classBody, previousStrict = strict;\n        strict = true;\n\n        expectKeyword('class');\n\n        if (lookahead.type === Token.Identifier) {\n            id = parseVariableIdentifier();\n        }\n\n        if (matchKeyword('extends')) {\n            lex();\n            superClass = isolateCoverGrammar(parseLeftHandSideExpressionAllowCall);\n        }\n        classBody = parseClassBody();\n        strict = previousStrict;\n\n        return classNode.finishClassExpression(id, superClass, classBody);\n    }\n\n    // ECMA-262 15.2 Modules\n\n    function parseModuleSpecifier() {\n        var node = new Node();\n\n        if (lookahead.type !== Token.StringLiteral) {\n            throwError(Messages.InvalidModuleSpecifier);\n        }\n        return node.finishLiteral(lex());\n    }\n\n    // ECMA-262 15.2.3 Exports\n\n    function parseExportSpecifier() {\n        var exported, local, node = new Node(), def;\n        if (matchKeyword('default')) {\n            // export {default} from 'something';\n            def = new Node();\n            lex();\n            local = def.finishIdentifier('default');\n        } else {\n            local = parseVariableIdentifier();\n        }\n        if (matchContextualKeyword('as')) {\n            lex();\n            exported = parseNonComputedProperty();\n        }\n        return node.finishExportSpecifier(local, exported);\n    }\n\n    function parseExportNamedDeclaration(node) {\n        var declaration = null,\n            isExportFromIdentifier,\n            src = null, specifiers = [];\n\n        // non-default export\n        if (lookahead.type === Token.Keyword) {\n            // covers:\n            // export var f = 1;\n            switch (lookahead.value) {\n                case 'let':\n                case 'const':\n                    declaration = parseLexicalDeclaration({inFor: false});\n                    return node.finishExportNamedDeclaration(declaration, specifiers, null);\n                case 'var':\n                case 'class':\n                case 'function':\n                    declaration = parseStatementListItem();\n                    return node.finishExportNamedDeclaration(declaration, specifiers, null);\n            }\n        }\n\n        expect('{');\n        while (!match('}')) {\n            isExportFromIdentifier = isExportFromIdentifier || matchKeyword('default');\n            specifiers.push(parseExportSpecifier());\n            if (!match('}')) {\n                expect(',');\n                if (match('}')) {\n                    break;\n                }\n            }\n        }\n        expect('}');\n\n        if (matchContextualKeyword('from')) {\n            // covering:\n            // export {default} from 'foo';\n            // export {foo} from 'foo';\n            lex();\n            src = parseModuleSpecifier();\n            consumeSemicolon();\n        } else if (isExportFromIdentifier) {\n            // covering:\n            // export {default}; // missing fromClause\n            throwError(lookahead.value ?\n                    Messages.UnexpectedToken : Messages.MissingFromClause, lookahead.value);\n        } else {\n            // cover\n            // export {foo};\n            consumeSemicolon();\n        }\n        return node.finishExportNamedDeclaration(declaration, specifiers, src);\n    }\n\n    function parseExportDefaultDeclaration(node) {\n        var declaration = null,\n            expression = null;\n\n        // covers:\n        // export default ...\n        expectKeyword('default');\n\n        if (matchKeyword('function')) {\n            // covers:\n            // export default function foo () {}\n            // export default function () {}\n            declaration = parseFunctionDeclaration(new Node(), true);\n            return node.finishExportDefaultDeclaration(declaration);\n        }\n        if (matchKeyword('class')) {\n            declaration = parseClassDeclaration(true);\n            return node.finishExportDefaultDeclaration(declaration);\n        }\n\n        if (matchContextualKeyword('from')) {\n            throwError(Messages.UnexpectedToken, lookahead.value);\n        }\n\n        // covers:\n        // export default {};\n        // export default [];\n        // export default (1 + 2);\n        if (match('{')) {\n            expression = parseObjectInitializer();\n        } else if (match('[')) {\n            expression = parseArrayInitializer();\n        } else {\n            expression = parseAssignmentExpression();\n        }\n        consumeSemicolon();\n        return node.finishExportDefaultDeclaration(expression);\n    }\n\n    function parseExportAllDeclaration(node) {\n        var src;\n\n        // covers:\n        // export * from 'foo';\n        expect('*');\n        if (!matchContextualKeyword('from')) {\n            throwError(lookahead.value ?\n                    Messages.UnexpectedToken : Messages.MissingFromClause, lookahead.value);\n        }\n        lex();\n        src = parseModuleSpecifier();\n        consumeSemicolon();\n\n        return node.finishExportAllDeclaration(src);\n    }\n\n    function parseExportDeclaration() {\n        var node = new Node();\n        if (state.inFunctionBody) {\n            throwError(Messages.IllegalExportDeclaration);\n        }\n\n        expectKeyword('export');\n\n        if (matchKeyword('default')) {\n            return parseExportDefaultDeclaration(node);\n        }\n        if (match('*')) {\n            return parseExportAllDeclaration(node);\n        }\n        return parseExportNamedDeclaration(node);\n    }\n\n    // ECMA-262 15.2.2 Imports\n\n    function parseImportSpecifier() {\n        // import {<foo as bar>} ...;\n        var local, imported, node = new Node();\n\n        imported = parseNonComputedProperty();\n        if (matchContextualKeyword('as')) {\n            lex();\n            local = parseVariableIdentifier();\n        }\n\n        return node.finishImportSpecifier(local, imported);\n    }\n\n    function parseNamedImports() {\n        var specifiers = [];\n        // {foo, bar as bas}\n        expect('{');\n        while (!match('}')) {\n            specifiers.push(parseImportSpecifier());\n            if (!match('}')) {\n                expect(',');\n                if (match('}')) {\n                    break;\n                }\n            }\n        }\n        expect('}');\n        return specifiers;\n    }\n\n    function parseImportDefaultSpecifier() {\n        // import <foo> ...;\n        var local, node = new Node();\n\n        local = parseNonComputedProperty();\n\n        return node.finishImportDefaultSpecifier(local);\n    }\n\n    function parseImportNamespaceSpecifier() {\n        // import <* as foo> ...;\n        var local, node = new Node();\n\n        expect('*');\n        if (!matchContextualKeyword('as')) {\n            throwError(Messages.NoAsAfterImportNamespace);\n        }\n        lex();\n        local = parseNonComputedProperty();\n\n        return node.finishImportNamespaceSpecifier(local);\n    }\n\n    function parseImportDeclaration() {\n        var specifiers = [], src, node = new Node();\n\n        if (state.inFunctionBody) {\n            throwError(Messages.IllegalImportDeclaration);\n        }\n\n        expectKeyword('import');\n\n        if (lookahead.type === Token.StringLiteral) {\n            // import 'foo';\n            src = parseModuleSpecifier();\n        } else {\n\n            if (match('{')) {\n                // import {bar}\n                specifiers = specifiers.concat(parseNamedImports());\n            } else if (match('*')) {\n                // import * as foo\n                specifiers.push(parseImportNamespaceSpecifier());\n            } else if (isIdentifierName(lookahead) && !matchKeyword('default')) {\n                // import foo\n                specifiers.push(parseImportDefaultSpecifier());\n                if (match(',')) {\n                    lex();\n                    if (match('*')) {\n                        // import foo, * as foo\n                        specifiers.push(parseImportNamespaceSpecifier());\n                    } else if (match('{')) {\n                        // import foo, {bar}\n                        specifiers = specifiers.concat(parseNamedImports());\n                    } else {\n                        throwUnexpectedToken(lookahead);\n                    }\n                }\n            } else {\n                throwUnexpectedToken(lex());\n            }\n\n            if (!matchContextualKeyword('from')) {\n                throwError(lookahead.value ?\n                        Messages.UnexpectedToken : Messages.MissingFromClause, lookahead.value);\n            }\n            lex();\n            src = parseModuleSpecifier();\n        }\n\n        consumeSemicolon();\n        return node.finishImportDeclaration(specifiers, src);\n    }\n\n    // ECMA-262 15.1 Scripts\n\n    function parseScriptBody() {\n        var statement, body = [], token, directive, firstRestricted;\n\n        while (startIndex < length) {\n            token = lookahead;\n            if (token.type !== Token.StringLiteral) {\n                break;\n            }\n\n            statement = parseStatementListItem();\n            body.push(statement);\n            if (statement.expression.type !== Syntax.Literal) {\n                // this is not directive\n                break;\n            }\n            directive = source.slice(token.start + 1, token.end - 1);\n            if (directive === 'use strict') {\n                strict = true;\n                if (firstRestricted) {\n                    tolerateUnexpectedToken(firstRestricted, Messages.StrictOctalLiteral);\n                }\n            } else {\n                if (!firstRestricted && token.octal) {\n                    firstRestricted = token;\n                }\n            }\n        }\n\n        while (startIndex < length) {\n            statement = parseStatementListItem();\n            /* istanbul ignore if */\n            if (typeof statement === 'undefined') {\n                break;\n            }\n            body.push(statement);\n        }\n        return body;\n    }\n\n    function parseProgram() {\n        var body, node;\n\n        peek();\n        node = new Node();\n\n        body = parseScriptBody();\n        return node.finishProgram(body, state.sourceType);\n    }\n\n    function filterTokenLocation() {\n        var i, entry, token, tokens = [];\n\n        for (i = 0; i < extra.tokens.length; ++i) {\n            entry = extra.tokens[i];\n            token = {\n                type: entry.type,\n                value: entry.value\n            };\n            if (entry.regex) {\n                token.regex = {\n                    pattern: entry.regex.pattern,\n                    flags: entry.regex.flags\n                };\n            }\n            if (extra.range) {\n                token.range = entry.range;\n            }\n            if (extra.loc) {\n                token.loc = entry.loc;\n            }\n            tokens.push(token);\n        }\n\n        extra.tokens = tokens;\n    }\n\n    function tokenize(code, options, delegate) {\n        var toString,\n            tokens;\n\n        toString = String;\n        if (typeof code !== 'string' && !(code instanceof String)) {\n            code = toString(code);\n        }\n\n        source = code;\n        index = 0;\n        lineNumber = (source.length > 0) ? 1 : 0;\n        lineStart = 0;\n        startIndex = index;\n        startLineNumber = lineNumber;\n        startLineStart = lineStart;\n        length = source.length;\n        lookahead = null;\n        state = {\n            allowIn: true,\n            allowYield: true,\n            labelSet: {},\n            inFunctionBody: false,\n            inIteration: false,\n            inSwitch: false,\n            lastCommentStart: -1,\n            curlyStack: []\n        };\n\n        extra = {};\n\n        // Options matching.\n        options = options || {};\n\n        // Of course we collect tokens here.\n        options.tokens = true;\n        extra.tokens = [];\n        extra.tokenValues = [];\n        extra.tokenize = true;\n        extra.delegate = delegate;\n\n        // The following two fields are necessary to compute the Regex tokens.\n        extra.openParenToken = -1;\n        extra.openCurlyToken = -1;\n\n        extra.range = (typeof options.range === 'boolean') && options.range;\n        extra.loc = (typeof options.loc === 'boolean') && options.loc;\n\n        if (typeof options.comment === 'boolean' && options.comment) {\n            extra.comments = [];\n        }\n        if (typeof options.tolerant === 'boolean' && options.tolerant) {\n            extra.errors = [];\n        }\n\n        try {\n            peek();\n            if (lookahead.type === Token.EOF) {\n                return extra.tokens;\n            }\n\n            lex();\n            while (lookahead.type !== Token.EOF) {\n                try {\n                    lex();\n                } catch (lexError) {\n                    if (extra.errors) {\n                        recordError(lexError);\n                        // We have to break on the first error\n                        // to avoid infinite loops.\n                        break;\n                    } else {\n                        throw lexError;\n                    }\n                }\n            }\n\n            tokens = extra.tokens;\n            if (typeof extra.errors !== 'undefined') {\n                tokens.errors = extra.errors;\n            }\n        } catch (e) {\n            throw e;\n        } finally {\n            extra = {};\n        }\n        return tokens;\n    }\n\n    function parse(code, options) {\n        var program, toString;\n\n        toString = String;\n        if (typeof code !== 'string' && !(code instanceof String)) {\n            code = toString(code);\n        }\n\n        source = code;\n        index = 0;\n        lineNumber = (source.length > 0) ? 1 : 0;\n        lineStart = 0;\n        startIndex = index;\n        startLineNumber = lineNumber;\n        startLineStart = lineStart;\n        length = source.length;\n        lookahead = null;\n        state = {\n            allowIn: true,\n            allowYield: true,\n            labelSet: {},\n            inFunctionBody: false,\n            inIteration: false,\n            inSwitch: false,\n            lastCommentStart: -1,\n            curlyStack: [],\n            sourceType: 'script'\n        };\n        strict = false;\n\n        extra = {};\n        if (typeof options !== 'undefined') {\n            extra.range = (typeof options.range === 'boolean') && options.range;\n            extra.loc = (typeof options.loc === 'boolean') && options.loc;\n            extra.attachComment = (typeof options.attachComment === 'boolean') && options.attachComment;\n\n            if (extra.loc && options.source !== null && options.source !== undefined) {\n                extra.source = toString(options.source);\n            }\n\n            if (typeof options.tokens === 'boolean' && options.tokens) {\n                extra.tokens = [];\n            }\n            if (typeof options.comment === 'boolean' && options.comment) {\n                extra.comments = [];\n            }\n            if (typeof options.tolerant === 'boolean' && options.tolerant) {\n                extra.errors = [];\n            }\n            if (extra.attachComment) {\n                extra.range = true;\n                extra.comments = [];\n                extra.bottomRightStack = [];\n                extra.trailingComments = [];\n                extra.leadingComments = [];\n            }\n            if (options.sourceType === 'module') {\n                // very restrictive condition for now\n                state.sourceType = options.sourceType;\n                strict = true;\n            }\n        }\n\n        try {\n            program = parseProgram();\n            if (typeof extra.comments !== 'undefined') {\n                program.comments = extra.comments;\n            }\n            if (typeof extra.tokens !== 'undefined') {\n                filterTokenLocation();\n                program.tokens = extra.tokens;\n            }\n            if (typeof extra.errors !== 'undefined') {\n                program.errors = extra.errors;\n            }\n        } catch (e) {\n            throw e;\n        } finally {\n            extra = {};\n        }\n\n        return program;\n    }\n\n    // Sync with *.json manifests.\n    exports.version = '2.7.2';\n\n    exports.tokenize = tokenize;\n\n    exports.parse = parse;\n\n    // Deep copy.\n    /* istanbul ignore next */\n    exports.Syntax = (function () {\n        var name, types = {};\n\n        if (typeof Object.create === 'function') {\n            types = Object.create(null);\n        }\n\n        for (name in Syntax) {\n            if (Syntax.hasOwnProperty(name)) {\n                types[name] = Syntax[name];\n            }\n        }\n\n        if (typeof Object.freeze === 'function') {\n            Object.freeze(types);\n        }\n\n        return types;\n    }());\n\n}));\n/* vim: set sw=4 ts=4 et tw=80 : */\n","/home/travis/build/npmtest/node-npmtest-aurelia-cli/node_modules/aurelia-cli/lib/build/amodro-trace/read/cjs.js":"/**\n * @license Copyright (c) 2010-2015, The Dojo Foundation All Rights Reserved.\n * Available via the MIT or new BSD license.\n */\n'use strict';\n\nvar parse = require('../lib/parse');\n\nmodule.exports = function cjs(fileName, fileContents) {\n  // Strip out comments.\n  try {\n    var preamble = '',\n    commonJsProps = parse.usesCommonJs(fileName, fileContents);\n\n    // First see if the module is not already RequireJS-formatted.\n    if (parse.usesAmdOrRequireJs(fileName, fileContents) || !commonJsProps) {\n    return fileContents;\n    }\n\n    if (commonJsProps.dirname || commonJsProps.filename) {\n    preamble = 'var __filename = module.uri || \\'\\', ' +\n      '__dirname = ' +\n      '__filename.substring(0, __filename.lastIndexOf(\\'/\\') + 1); ';\n    }\n\n    // Construct the wrapper boilerplate.\n    fileContents = 'define(function (require, exports, module) {' +\n    preamble +\n    fileContents +\n    '\\n});\\n';\n\n  } catch (e) {\n    console.log('commonJs.convert: COULD NOT CONVERT: ' + fileName +\n          ', so skipping it. Error was: ' + e);\n    return fileContents;\n  }\n\n  return fileContents;\n};\n","/home/travis/build/npmtest/node-npmtest-aurelia-cli/node_modules/aurelia-cli/lib/build/amodro-trace/write/all.js":"'use strict';\n\n// The order of these transforms is informed by how they were done in the\n// requirejs optimizer.\nvar transforms = [\n  require('./plugins'),\n  require('./stubs'),\n  require('./defines'),\n  require('./packages')\n];\n\n/**\n * Chains all the default set of transforms to return one function to be used\n * for transform operations on traced module content.\n * @param  {Object} options object for holding options. The same options object\n * is used and passed to all transforms. See individual transforms for their\n * options.\n * @return {Function} A function that can be used for multiple content transform\n * calls.\n */\nmodule.exports = function all(options) {\n  options = options || {};\n\n  var transformFns = transforms.map(function(transform) {\n    return transform(options);\n  });\n\n  return function(context, moduleName, filePath, contents) {\n    contents = transformFns.reduce(function(contents, transformFn) {\n      return transformFn(context, moduleName, filePath, contents);\n    }, contents);\n\n    return contents;\n  };\n\n};\n","/home/travis/build/npmtest/node-npmtest-aurelia-cli/node_modules/aurelia-cli/lib/build/amodro-trace/write/plugins.js":"'use strict';\nvar lang = require('../lib/lang'),\n    defines = require('./defines');\n\n/**\n * For plugin loader resources, asks the plugins loaded in the context to write\n * out content for those values. Some plugins do not have any serialized forms\n * for their resource IDs, so the contents could still end up as an empty\n * string.\n * @param  {Object} options object for holding options. Supported options:\n * @return {Function} A function that can be used for multiple content transform\n * calls.\n */\nmodule.exports = function plugins(options) {\n  options = options || {};\n\n  return function(context, moduleName, filePath, contents) {\n    var parts = context.makeModuleMap(moduleName),\n        builder = parts.prefix && lang.getOwn(context.defined, parts.prefix);\n\n    if (builder) {\n      if (builder.write) {\n        var writeApi = function (input) {\n          contents = input;\n        };\n        writeApi.asModule = function (moduleName, input) {\n          contents = defines.toTransport(context, moduleName,\n                                         filePath, input, options);\n        };\n\n        builder.write(parts.prefix, parts.name, writeApi);\n      }\n    }\n\n    return contents;\n  };\n};\n\n","/home/travis/build/npmtest/node-npmtest-aurelia-cli/node_modules/aurelia-cli/lib/build/amodro-trace/write/defines.js":"'use strict';\nvar lang = require('../lib/lang'),\n    transform = require('../lib/transform'),\n    falseProp = lang.falseProp,\n    getOwn = lang.getOwn,\n    makeJsArrayString = lang.makeJsArrayString;\n\n// options should include skipModuleInsertion and tracing for transform?\n\n/**\n * For modules that are inside a package config, this transform will write out\n * adapter define() entries for the package manin value, so that package config\n * is not needed to map 'packageName' to 'packageName/mainModuleId'.\n * @param  {Object} options object for holding options. Supported options:\n * - wrapShim: if shim config is used for the module ID, then wrap it in a\n * function closure. This can be hazardous if the scripts assumes acces to\n * other variables at the top level. However, wrapping can be useful for shimmed\n * IDs that have dependencies, and where those dependencies may not be\n * immediately available or inlined with this shimmed script.\n * @return {Function} A function that can be used for multiple content transform\n * calls.\n */\nfunction defines(options) {\n  options = options || {};\n\n  return function(context, moduleName, filePath, contents) {\n    var config = context.config,\n        packageName = require('./packages').getPackageName(context, moduleName);\n\n    contents = defines.toTransport(context, moduleName,\n                                   filePath, contents, options);\n\n    //Some files may not have declared a require module, and if so,\n    //put in a placeholder call so the require does not try to load them\n    //after the module is processed.\n    //If we have a name, but no defined module, then add in the placeholder.\n    if (moduleName && falseProp(context._layer.modulesWithNames, moduleName)) {\n      var shim = config.shim && (getOwn(config.shim, moduleName) ||\n                 (packageName && getOwn(config.shim, packageName)));\n      if (shim) {\n        if (options.wrapShim) {\n          contents = '(function(root) {\\n' +\n                         'define(\"' + moduleName + '\", ' +\n                         (shim.deps && shim.deps.length ?\n                                makeJsArrayString(shim.deps) + ', ' : '[], ') +\n                        'function() {\\n' +\n                        '  return (function() {\\n' +\n                             contents +\n                             // Start with a \\n in case last line is a comment\n                             // in the contents, like a sourceURL comment.\n                             '\\n' + (shim.exportsFn ? shim.exportsFn() : '') +\n                             '\\n' +\n                        '  }).apply(root, arguments);\\n' +\n                        '});\\n' +\n                        '}(this));\\n';\n        } else {\n          contents += '\\n' + 'define(\"' + moduleName + '\", ' +\n                         (shim.deps && shim.deps.length ?\n                                makeJsArrayString(shim.deps) + ', ' : '') +\n                         (shim.exportsFn ? shim.exportsFn() : 'function(){}') +\n                         ');\\n';\n        }\n      } else {\n        contents += '\\n' + 'define(\"' + moduleName + '\", function(){});\\n';\n      }\n    }\n\n    return contents;\n  };\n}\n\n/**\n * Modifies a define() call to make sure it has a module ID as the first\n * argument and to make sure the sugared define(function(require), {}) syntax\n * has an array of dependencies extracted and explicitly passed in, so that the\n * define() call works in JS environments that do not give the full function\n * bodies for Function.protototype.toString calls.\n * @param  {Object} context    loader context\n * @param  {String} moduleName module ID\n * @param  {String} filePath   file path\n * @param  {String} contents   contents of the file for the given module ID.\n * @param  {Object} options    object for holding options. Supported options:\n * - logger: Object of logging functions. Currently only logger.warn is used\n * if a module output for an ID cannot be properly normalized for string\n * transport.\n * @return {String}            transformed content. May not be different from\n * the input contents string.\n */\ndefines.toTransport = function(context, moduleName,\n                               filePath, contents, options) {\n  options = options || {};\n  if (!options.logger) {\n    options.logger = context.config._options.logger;\n  }\n\n  function onFound(info) {\n    //Only mark this module as having a name if not a named module,\n    //or if a named module and the name matches expectations.\n    if (context && (info.needsId || info.foundId === moduleName)) {\n      context._layer.modulesWithNames[moduleName] = true;\n    }\n  }\n\n  return transform.toTransport('', moduleName, filePath,\n                               contents, onFound, options);\n};\n\nmodule.exports = defines;\n","/home/travis/build/npmtest/node-npmtest-aurelia-cli/node_modules/aurelia-cli/lib/build/amodro-trace/lib/transform.js":"// Taken from r.js, preserving its style for now to easily port changes in the\n// near term.\nvar define = function(ary, fn) {\n    module.exports = fn.apply(undefined,\n                              (ary.map(function(id) { return require(id); })));\n};\n\n/**\n * @license Copyright (c) 2012-2015, The Dojo Foundation All Rights Reserved.\n * Available via the MIT or new BSD license.\n * see: http://github.com/jrburke/requirejs for details\n */\n\n/*global define */\n\ndefine([ 'esprima', './parse', './lang'],\nfunction (esprima, parse, lang) {\n    'use strict';\n    var transform,\n        jsExtRegExp = /\\.js$/g,\n        baseIndentRegExp = /^([ \\t]+)/,\n        indentRegExp = /\\{[\\r\\n]+([ \\t]+)/,\n        keyRegExp = /^[_A-Za-z]([A-Za-z\\d_]*)$/,\n        bulkIndentRegExps = {\n            '\\n': /\\n/g,\n            '\\r\\n': /\\r\\n/g\n        };\n\n    function applyIndent(str, indent, lineReturn) {\n        var regExp = bulkIndentRegExps[lineReturn];\n        return str.replace(regExp, '$&' + indent);\n    }\n\n    transform = {\n        toTransport: function (namespace, moduleName, path, contents, onFound, options) {\n            options = options || {};\n\n            var astRoot, contentLines, modLine,\n                foundAnon,\n                scanCount = 0,\n                scanReset = false,\n                defineInfos = [],\n                applySourceUrl = function (contents) {\n                    if (options.useSourceUrl) {\n                        contents = 'eval(\"' + lang.jsEscape(contents) +\n                            '\\\\n//# sourceURL=' + (path.indexOf('/') === 0 ? '' : '/') +\n                            path +\n                            '\");\\n';\n                    }\n                    return contents;\n                };\n\n            try {\n                astRoot = esprima.parse(contents, {\n                    loc: true\n                });\n            } catch (e) {\n                var logger = options.logger;\n                if (logger && logger.warn) {\n                    if (jsExtRegExp.test(path)) {\n                        logger.warn('toTransport skipping ' + path +\n                                    ': ' + e.toString());\n                    }\n                }\n                return contents;\n            }\n\n            //Find the define calls and their position in the files.\n            parse.traverse(astRoot, function (node) {\n                var args, firstArg, firstArgLoc, factoryNode,\n                    needsId, depAction, foundId, init,\n                    sourceUrlData, range,\n                    namespaceExists = false;\n\n                // If a bundle script with a define declaration, do not\n                // parse any further at this level. Likely a built layer\n                // by some other tool.\n                if (node.type === 'VariableDeclarator' &&\n                    node.id && node.id.name === 'define' &&\n                    node.id.type === 'Identifier') {\n                    init = node.init;\n                    if (init && init.callee &&\n                        init.callee.type === 'CallExpression' &&\n                        init.callee.callee &&\n                        init.callee.callee.type === 'Identifier' &&\n                        init.callee.callee.name === 'require' &&\n                        init.callee.arguments && init.callee.arguments.length === 1 &&\n                        init.callee.arguments[0].type === 'Literal' &&\n                        init.callee.arguments[0].value &&\n                        init.callee.arguments[0].value.indexOf('amdefine') !== -1) {\n                        // the var define = require('amdefine')(module) case,\n                        // keep going in that case.\n                    } else {\n                        return false;\n                    }\n                }\n\n                namespaceExists = namespace &&\n                                node.type === 'CallExpression' &&\n                                node.callee  && node.callee.object &&\n                                node.callee.object.type === 'Identifier' &&\n                                node.callee.object.name === namespace &&\n                                node.callee.property.type === 'Identifier' &&\n                                node.callee.property.name === 'define';\n\n                if (namespaceExists || parse.isDefineNodeWithArgs(node)) {\n                    //The arguments are where its at.\n                    args = node.arguments;\n                    if (!args || !args.length) {\n                        return;\n                    }\n\n                    firstArg = args[0];\n                    firstArgLoc = firstArg.loc;\n\n                    if (args.length === 1) {\n                        if (firstArg.type === 'Identifier') {\n                            //The define(factory) case, but\n                            //only allow it if one Identifier arg,\n                            //to limit impact of false positives.\n                            needsId = true;\n                            depAction = 'empty';\n                        } else if (parse.isFnExpression(firstArg)) {\n                            //define(function(){})\n                            factoryNode = firstArg;\n                            needsId = true;\n                            depAction = 'scan';\n                        } else if (firstArg.type === 'ObjectExpression') {\n                            //define({});\n                            needsId = true;\n                            depAction = 'skip';\n                        } else if (firstArg.type === 'Literal' &&\n                                   typeof firstArg.value === 'number') {\n                            //define('12345');\n                            needsId = true;\n                            depAction = 'skip';\n                        } else if (firstArg.type === 'UnaryExpression' &&\n                                   firstArg.operator === '-' &&\n                                   firstArg.argument &&\n                                   firstArg.argument.type === 'Literal' &&\n                                   typeof firstArg.argument.value === 'number') {\n                            //define('-12345');\n                            needsId = true;\n                            depAction = 'skip';\n                        } else if (firstArg.type === 'MemberExpression' &&\n                                   firstArg.object &&\n                                   firstArg.property &&\n                                   firstArg.property.type === 'Identifier') {\n                            //define(this.key);\n                            needsId = true;\n                            depAction = 'empty';\n                        }\n                    } else if (firstArg.type === 'ArrayExpression') {\n                        //define([], ...);\n                        needsId = true;\n                        depAction = 'skip';\n                    } else if (firstArg.type === 'Literal' &&\n                               typeof firstArg.value === 'string') {\n                        //define('string', ....)\n                        //Already has an ID.\n                        needsId = false;\n                        if (args.length === 2 &&\n                            parse.isFnExpression(args[1])) {\n                            //Needs dependency scanning.\n                            factoryNode = args[1];\n                            depAction = 'scan';\n                        } else {\n                            depAction = 'skip';\n                        }\n                    } else {\n                        //Unknown define entity, keep looking, even\n                        //in the subtree for this node.\n                        return;\n                    }\n\n                    range = {\n                        foundId: foundId,\n                        needsId: needsId,\n                        depAction: depAction,\n                        namespaceExists: namespaceExists,\n                        node: node,\n                        defineLoc: node.loc,\n                        firstArgLoc: firstArgLoc,\n                        factoryNode: factoryNode,\n                        sourceUrlData: sourceUrlData\n                    };\n\n                    //Only transform ones that do not have IDs. If it has an\n                    //ID but no dependency array, assume it is something like\n                    //a phonegap implementation, that has its own internal\n                    //define that cannot handle dependency array constructs,\n                    //and if it is a named module, then it means it has been\n                    //set for transport form.\n                    if (range.needsId) {\n                        if (foundAnon) {\n                            var logger = options.logger;\n                            if (logger && logger.warn) {\n                               logger.warn(path + ' has more than one anonymous ' +\n                                'define. May be a built file from another ' +\n                                'build system like, Ender. Skipping normalization.');\n                            }\n                            defineInfos = [];\n                            return false;\n                        } else {\n                            foundAnon = range;\n                            defineInfos.push(range);\n                        }\n                    } else if (depAction === 'scan') {\n                        scanCount += 1;\n                        if (scanCount > 1) {\n                            //Just go back to an array that just has the\n                            //anon one, since this is an already optimized\n                            //file like the phonegap one.\n                            if (!scanReset) {\n                                defineInfos =  foundAnon ? [foundAnon] : [];\n                                scanReset = true;\n                            }\n                        } else {\n                            defineInfos.push(range);\n                        }\n                    }\n                }\n            });\n\n\n            if (!defineInfos.length) {\n                return applySourceUrl(contents);\n            }\n\n            //Reverse the matches, need to start from the bottom of\n            //the file to modify it, so that the ranges are still true\n            //further up.\n            defineInfos.reverse();\n\n            contentLines = contents.split('\\n');\n\n            modLine = function (loc, contentInsertion) {\n                var startIndex = loc.start.column,\n                //start.line is 1-based, not 0 based.\n                lineIndex = loc.start.line - 1,\n                line = contentLines[lineIndex];\n                contentLines[lineIndex] = line.substring(0, startIndex) +\n                                           contentInsertion +\n                                           line.substring(startIndex,\n                                                              line.length);\n            };\n\n            defineInfos.forEach(function (info) {\n                var deps,\n                    contentInsertion = '',\n                    depString = '';\n\n                //Do the modifications \"backwards\", in other words, start with the\n                //one that is farthest down and work up, so that the ranges in the\n                //defineInfos still apply. So that means deps, id, then namespace.\n                if (info.needsId && moduleName) {\n                    contentInsertion += \"'\" + moduleName + \"',\";\n                }\n\n                if (info.depAction === 'scan') {\n                    deps = parse.getAnonDepsFromNode(info.factoryNode);\n\n                    if (deps.length) {\n                        depString = '[' + deps.map(function (dep) {\n                            return \"'\" + dep + \"'\";\n                        }) + ']';\n                    } else {\n                        depString = '[]';\n                    }\n                    depString +=  ',';\n\n                    if (info.factoryNode) {\n                        //Already have a named module, need to insert the\n                        //dependencies after the name.\n                        modLine(info.factoryNode.loc, depString);\n                    } else {\n                        contentInsertion += depString;\n                    }\n                }\n\n                if (contentInsertion) {\n                    modLine(info.firstArgLoc, contentInsertion);\n                }\n\n                //Do namespace last so that ui does not mess upthe parenRange\n                //used above.\n                if (namespace && !info.namespaceExists) {\n                    modLine(info.defineLoc, namespace + '.');\n                }\n\n                //Notify any listener for the found info\n                if (onFound) {\n                    onFound(info);\n                }\n            });\n\n            contents = contentLines.join('\\n');\n\n            return applySourceUrl(contents);\n        },\n\n        /**\n         * Modify the contents of a require.config/requirejs.config call. This\n         * call will LOSE any existing comments that are in the config string.\n         *\n         * @param  {String} fileContents String that may contain a config call\n         * @param  {Function} onConfig Function called when the first config\n         * call is found. It will be passed an Object which is the current\n         * config, and the onConfig function should return an Object to use\n         * as the config.\n         * @return {String} the fileContents with the config changes applied.\n         */\n        modifyConfig: function (fileContents, onConfig) {\n            var details = parse.findConfig(fileContents),\n                config = details.config;\n\n            if (config) {\n                config = onConfig(config);\n                if (config) {\n                    return transform.serializeConfig(config,\n                                              fileContents,\n                                              details.range[0],\n                                              details.range[1],\n                                              {\n                                                quote: details.quote\n                                              });\n                }\n            }\n\n            return fileContents;\n        },\n\n        serializeConfig: function (config, fileContents, start, end, options) {\n            //Calculate base level of indent\n            var indent, match, configString, outDentRegExp,\n                baseIndent = '',\n                startString = fileContents.substring(0, start),\n                existingConfigString = fileContents.substring(start, end),\n                lineReturn = existingConfigString.indexOf('\\r') === -1 ? '\\n' : '\\r\\n',\n                lastReturnIndex = startString.lastIndexOf('\\n');\n\n            //Get the basic amount of indent for the require config call.\n            if (lastReturnIndex === -1) {\n                lastReturnIndex = 0;\n            }\n\n            match = baseIndentRegExp.exec(startString.substring(lastReturnIndex + 1, start));\n            if (match && match[1]) {\n                baseIndent = match[1];\n            }\n\n            //Calculate internal indentation for config\n            match = indentRegExp.exec(existingConfigString);\n            if (match && match[1]) {\n                indent = match[1];\n            }\n\n            if (!indent || indent.length < baseIndent) {\n                indent = '  ';\n            } else {\n                indent = indent.substring(baseIndent.length);\n            }\n\n            outDentRegExp = new RegExp('(' + lineReturn + ')' + indent, 'g');\n\n            configString = transform.objectToString(config, {\n                                                    indent: indent,\n                                                    lineReturn: lineReturn,\n                                                    outDentRegExp: outDentRegExp,\n                                                    quote: options && options.quote\n                                                });\n\n            //Add in the base indenting level.\n            configString = applyIndent(configString, baseIndent, lineReturn);\n\n            return startString + configString + fileContents.substring(end);\n        },\n\n        /**\n         * Tries converting a JS object to a string. This will likely suck, and\n         * is tailored to the type of config expected in a loader config call.\n         * So, hasOwnProperty fields, strings, numbers, arrays and functions,\n         * no weird recursively referenced stuff.\n         * @param  {Object} obj        the object to convert\n         * @param  {Object} options    options object with the following values:\n         *         {String} indent     the indentation to use for each level\n         *         {String} lineReturn the type of line return to use\n         *         {outDentRegExp} outDentRegExp the regexp to use to outdent functions\n         *         {String} quote      the quote type to use, ' or \". Optional. Default is \"\n         * @param  {String} totalIndent the total indent to print for this level\n         * @return {String}            a string representation of the object.\n         */\n        objectToString: function (obj, options, totalIndent) {\n            var startBrace, endBrace, nextIndent,\n                first = true,\n                value = '',\n                lineReturn = options.lineReturn,\n                indent = options.indent,\n                outDentRegExp = options.outDentRegExp,\n                quote = options.quote || '\"';\n\n            totalIndent = totalIndent || '';\n            nextIndent = totalIndent + indent;\n\n            if (obj === null) {\n                value = 'null';\n            } else if (obj === undefined) {\n                value = 'undefined';\n            } else if (typeof obj === 'number' || typeof obj === 'boolean') {\n                value = obj;\n            } else if (typeof obj === 'string') {\n                //Use double quotes in case the config may also work as JSON.\n                value = quote + lang.jsEscape(obj) + quote;\n            } else if (lang.isArray(obj)) {\n                lang.each(obj, function (item, i) {\n                    value += (i !== 0 ? ',' + lineReturn : '' ) +\n                        nextIndent +\n                        transform.objectToString(item,\n                                                 options,\n                                                 nextIndent);\n                });\n\n                startBrace = '[';\n                endBrace = ']';\n            } else if (lang.isFunction(obj) || lang.isRegExp(obj)) {\n                //The outdent regexp just helps pretty up the conversion\n                //just in node. Rhino strips comments and does a different\n                //indent scheme for Function toString, so not really helpful\n                //there.\n                value = obj.toString().replace(outDentRegExp, '$1');\n            } else {\n                //An object\n                lang.eachProp(obj, function (v, prop) {\n                    value += (first ? '': ',' + lineReturn) +\n                        nextIndent +\n                        (keyRegExp.test(prop) ? prop : quote + lang.jsEscape(prop) + quote )+\n                        ': ' +\n                        transform.objectToString(v,\n                                                 options,\n                                                 nextIndent);\n                    first = false;\n                });\n                startBrace = '{';\n                endBrace = '}';\n            }\n\n            if (startBrace) {\n                value = startBrace +\n                        lineReturn +\n                        value +\n                        lineReturn + totalIndent +\n                        endBrace;\n            }\n\n            return value;\n        }\n    };\n\n    return transform;\n});\n","/home/travis/build/npmtest/node-npmtest-aurelia-cli/node_modules/aurelia-cli/lib/build/amodro-trace/write/stubs.js":"'use strict';\nvar lang = require('../lib/lang');\n\n/**\n * Replaces module content for a given set of module IDs with stub define calls.\n * @param  {Object} options object for holding options. Supported options:\n * - stubModules: Array of module IDs to place in stubs.\n * @return {Function} A function that can be used for multiple content transform\n * calls.\n */\nmodule.exports = function stubs(options) {\n  options = options || {};\n\n  return function(context, moduleName, filePath, contents) {\n    if (options.stubModules && options.stubModules.indexOf(moduleName) !== -1) {\n      //Just want to insert a simple module definition instead\n      //of the source module. Useful for plugins that inline\n      //all their resources.\n      if (lang.hasProp(context.plugins, moduleName)) {\n        //Slightly different content for plugins, to indicate\n        //that dynamic loading will not work.\n        return 'define({load: function(id){' +\n               'throw new Error(\"Dynamic load not allowed: \" + id);}});';\n      } else {\n        return 'define({});';\n      }\n    } else {\n      return contents;\n    }\n  };\n\n};\n","/home/travis/build/npmtest/node-npmtest-aurelia-cli/node_modules/aurelia-cli/lib/build/amodro-trace/write/packages.js":"'use strict';\nvar defines = require('./defines'),\n    lang = require('../lib/lang'),\n    parse = require('../lib/parse');\n\n/**\n * For modules that are inside a package config, this transform will write out\n * adapter define() entries for the package manin value, so that package config\n * is not needed to map 'packageName' to 'packageName/mainModuleId'.\n * @param  {Object} options object for holding options. Supported options:\n * @return {Function} A function that can be used for multiple content transform\n * calls.\n */\nfunction packages(options) {\n  options = options || {};\n\n  return function(context, moduleName, filePath, contents) {\n    var hasPackageName;\n\n    //If the moduleName is a package main, then hold on to the\n    //packageName in case an adapter needs to be written.\n    var packageName = packages.getPackageName(context, moduleName);\n\n    if (packageName) {\n      hasPackageName = (packageName === parse.getNamedDefine(contents));\n    }\n\n    contents = defines.toTransport(context, moduleName,\n                                   filePath, contents, options);\n\n    if (packageName && !hasPackageName) {\n      contents += ';define(\\'' + packageName + '\\', [\\'' + moduleName +\n                  '\\'], function (main) { return main; });\\n';\n    }\n\n    return contents;\n  };\n\n}\n\n/**\n * If the moduleName maps to a package config's main module, return the package\n * name.\n * @param  {Object} context loader context.\n * @param  {String} moduleName module ID\n * @return {String} the package name, or null if one is not found.\n */\npackages.getPackageName = function(context, moduleName) {\n  var config = context.config,\n      pkgsMainMap = config.pkgsMainMap;\n\n  if (!pkgsMainMap) {\n    config.pkgsMainMap = pkgsMainMap = {};\n    //Create a reverse lookup for packages main module IDs to their package\n    //names, useful for knowing when to write out define() package main ID\n    //adapters.\n    lang.eachProp(context.config.pkgs, function(value, prop) {\n        pkgsMainMap[value] = prop;\n    });\n  }\n\n  return lang.getOwn(pkgsMainMap, moduleName) || null;\n};\n\nmodule.exports = packages;\n","/home/travis/build/npmtest/node-npmtest-aurelia-cli/node_modules/aurelia-cli/lib/build/loader-plugin.js":"'use strict';\nconst path = require('path');\n\nexports.LoaderPlugin = class {\n  constructor(bundler, config) {\n    this.bundler = bundler;\n    this.config = config;\n    this.name = config.name;\n    this.stub = config.stub;\n    this.test = config.test ? new RegExp(config.test) : regExpFromExtensions(config.extensions);\n  }\n\n  matches(filePath) {\n    return this.test.test(filePath);\n  }\n\n  transform(moduleId, filePath, contents) {\n    contents = `define(\\'${this.createModuleId(moduleId, filePath)}\\', [\\'module\\'], function(module) { module.exports = \"` +\n      contents\n        .replace(/([\"\\\\])/g, '\\\\$1')\n        .replace(/[\\f]/g, '\\\\f')\n        .replace(/[\\b]/g, '\\\\b')\n        .replace(/[\\n]/g, '\\\\n')\n        .replace(/[\\t]/g, '\\\\t')\n        .replace(/[\\r]/g, '\\\\r')\n        .replace(/[\\u2028]/g, '\\\\u2028')\n        .replace(/[\\u2029]/g, '\\\\u2029') +\n      '\"; });';\n\n    return Promise.resolve(contents);\n  }\n\n  createModuleId(moduleId, filePath) {\n    let loderConfigType = this.bundler.loaderOptions.type;\n\n    switch (loderConfigType) {\n    case 'require':\n      return 'text!' + moduleId + path.extname(filePath);\n    case 'system':\n      throw new Error('SystemJS is not yet supported');\n    default:\n      throw new Error(`Loader configuration style ${loderConfigType} is not supported.`);\n    }\n  }\n};\n\nfunction regExpFromExtensions(extensions) {\n  return new RegExp('^.*(' + extensions.map(x => '\\\\' + x).join('|') + ')$');\n}\n","/home/travis/build/npmtest/node-npmtest-aurelia-cli/node_modules/aurelia-cli/lib/build/package-analyzer.js":"'use strict';\nconst fs = require('../file-system');\nconst path = require('path');\nconst DependencyDescription = require('./dependency-description').DependencyDescription;\n\nexports.PackageAnalyzer = class {\n  constructor(project) {\n    this.project = project;\n  }\n\n  analyze(packageName, packageSource) {\n    let description = new DependencyDescription(packageName, packageSource || 'npm');\n\n    return loadPackageMetadata(this.project, description)\n      .then(() => determineLoaderConfig(this.project, description))\n      .then(() => description);\n  }\n\n  reverseEngineer(loaderConfig) {\n    let description = new DependencyDescription(loaderConfig.name);\n\n    if (loaderConfig.path.indexOf('node_modules') !== -1) {\n      description.loaderConfig = loaderConfig;\n      description.source = 'npm';\n      return loadPackageMetadata(this.project, description).then(() => description);\n    }\n\n    description.source = 'custom';\n    description.loaderConfig = loaderConfig;\n\n    return Promise.resolve(description);\n  }\n};\n\nfunction loadPackageMetadata(project, description) {\n  return setLocation(project, description)\n    .then(() => fs.readFile(description.metadataLocation))\n    .then(data => {\n      description.metadata = JSON.parse(data.toString());\n    });\n}\n\nfunction determineLoaderConfig(project, description) {\n  let metadata = description.metadata;\n  let location = path.resolve(description.location);\n  let sourcePath;\n\n  if (metadata.jspm) {\n    let jspm = metadata.jspm;\n\n    if (jspm.directories && jspm.directories.dist) {\n      sourcePath = path.join(location, jspm.directories.dist, jspm.main);\n    } else {\n      sourcePath = path.join(location, metadata.main);\n    }\n  } else {\n    sourcePath = path.join(location, metadata.main);\n  }\n\n  sourcePath = path.relative(path.resolve(project.paths.root), sourcePath);\n\n  description.loaderConfig = {\n    name: description.name,\n    path: removeExtension(sourcePath)\n  };\n}\n\nfunction setLocation(project, description) {\n  switch (description.source) {\n  case 'npm':\n    return getPackageFolder(project, description)\n      .then(packageFolder => {\n        description.location = packageFolder;\n        description.metadataLocation = path.join(description.location, 'package.json');\n      });\n  default:\n    throw new Error(`The package source \"${description.source}\" is not supported.`);\n  }\n}\n\nfunction getPackageFolder(project, description) {\n  if (!description.loaderConfig || !description.loaderConfig.path) {\n    return lookupPackageFolderDefaultStrategy(project.paths.root)\n      .catch(error => { throw new Error('A valid package source could not be found.'); })\n      .then(packageFolder => path.join(packageFolder, description.name));\n  }\n\n  return lookupPackageFolderRelativeStrategy(project.paths.root, description.loaderConfig.path);\n}\n\n// Looks for the node_modules folder from the root path of aurelia\n// with the defined loaderConfig.\nfunction lookupPackageFolderRelativeStrategy(root, relativePath) {\n  let pathParts = relativePath.replace(/\\\\/g, '/').split('/');\n  let packageFolder = '';\n  let stopOnNext = false;\n\n  for (let i = 0; i < pathParts.length; ++i) {\n    let part = pathParts[i];\n\n    packageFolder = path.join(packageFolder, part);\n\n    if (stopOnNext && !part.startsWith('@')) {\n      break;\n    } else if (part === 'node_modules') {\n      stopOnNext = true;\n    }\n  }\n\n  return Promise.resolve(path.resolve(root, packageFolder));\n}\n\n// Looks for a node_modules folder from the root path of aurelia\n// With the default lookup strategy of node\nfunction lookupPackageFolderDefaultStrategy(root) {\n  // Test for root directory\n  if (/^\\/$|^[A-Z]:\\/*$/g.test(root)) return Promise.reject();\n  return fs.readdir(root)\n    .then(files => {\n      let matches = files.filter(file => file === 'node_modules');\n\n      // Just choose first entry. There shouldnt be more of them in one folder\n      if (matches.length) {\n        let cwdToRoot = path.resolve(process.cwd(), root);\n        return path.join(cwdToRoot, matches[0]);\n      }\n\n      return lookupPackageFolderDefaultStrategy(path.resolve(root, '..'));\n    });\n}\n\nfunction removeExtension(filePath) {\n  let ext = path.extname(filePath);\n\n  if (ext) {\n    return filePath.replace(ext, '');\n  }\n\n  return filePath;\n}\n","/home/travis/build/npmtest/node-npmtest-aurelia-cli/node_modules/aurelia-cli/lib/build/dependency-description.js":"'use strict';\nconst path = require('path');\nconst fs = require('../file-system');\nconst knownExtensions = ['.js', '.css', '.svg', '.html'];\n\nexports.DependencyDescription = class {\n  constructor(name, source) {\n    this.name = name;\n    this.source = source;\n  }\n\n  calculateMainPath(root) {\n    let config = this.loaderConfig;\n    let part;\n\n    if (config.main) {\n      part = path.join(config.path, config.main);\n    } else {\n      part = config.path;\n    }\n\n    let ext = path.extname(part);\n    if (knownExtensions.indexOf(ext) === -1) {\n      part = part + '.js';\n    }\n\n    return path.join(process.cwd(), root, part);\n  }\n\n  readMainFileSync(root) {\n    let p = this.calculateMainPath(root);\n\n    try {\n      return fs.readFileSync(p).toString();\n    } catch (e) {\n      console.log('error', p);\n      return '';\n    }\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-aurelia-cli/node_modules/aurelia-cli/gulpfile.js":"require('require-dir')('build/tasks');\n","/home/travis/build/npmtest/node-npmtest-aurelia-cli/node_modules/aurelia-cli/wallaby.conf.js":"module.exports = function() {\n  return {\n    files: [\n      'lib/**/*.js',\n      '!lib/resources/generators/**/*',\n      'package.json',\n      {pattern: 'spec/mocks/**/*', load: false},\n      {pattern: 'spec/helpers/polyfills.js', load: false}\n    ],\n\n    tests: [\n      'spec/**/*[Ss]pec.js'\n    ],\n\n    env: {\n      type: 'node'\n    },\n\n    bootstrap: function(wallaby) {\n      require('aurelia-polyfills');\n    },\n\n    testFramework: 'jasmine'\n  };\n};\n","/home/travis/build/npmtest/node-npmtest-aurelia-cli/node_modules/aurelia-cli/bin/aurelia-cli.js":"#!/usr/bin/env node\n'use strict';\nconst resolve = require('../lib/resolve');\n\nprocess.title = 'aurelia';\n\nlet originalBaseDir = process.cwd();\n\nresolve('aurelia-cli', {\n  basedir: originalBaseDir\n}, function(error, projectLocalCli) {\n  let cli;\n\n  if (error) {\n    cli = new (require('../lib/index').CLI);\n    cli.options.runningGlobally = true;\n  } else {\n    cli = new (require(projectLocalCli).CLI);\n    cli.options.runningLocally = true;\n  }\n\n  cli.options.originalBaseDir = originalBaseDir;\n\n  let userArgs = process.argv.slice(2);\n  let commandName = userArgs[0];\n  let commandArgs = userArgs.slice(1);\n\n  cli.run(commandName, commandArgs).catch((error) => {\n      console.log(error);\n      process.exit(1);\n  });\n});\n","/home/travis/build/npmtest/node-npmtest-aurelia-cli/node_modules/aurelia-cli/lib/resolve/index.js":"var core = require('./lib/core');\nexports = module.exports = require('./lib/async');\nexports.core = core;\nexports.isCore = function(x) { return core[x]; };\nexports.sync = require('./lib/sync');\n","/home/travis/build/npmtest/node-npmtest-aurelia-cli/node_modules/aurelia-cli/lib/resolve/lib/core.js":"module.exports = require('./core.json').reduce(function (acc, x) {\n    acc[x] = true;\n    return acc;\n}, {});\n","/home/travis/build/npmtest/node-npmtest-aurelia-cli/node_modules/aurelia-cli/lib/resolve/lib/async.js":"var core = require('./core');\nvar fs = require('fs');\nvar path = require('path');\nvar caller = require('./caller.js');\nvar nodeModulesPaths = require('./node-modules-paths.js');\nvar splitRe = process.platform === 'win32' ? /[\\/\\\\]/ : /\\//;\n\nmodule.exports = function resolve (x, opts, cb) {\n    if (typeof opts === 'function') {\n        cb = opts;\n        opts = {};\n    }\n    if (!opts) opts = {};\n    if (typeof x !== 'string') {\n        return process.nextTick(function () {\n            cb(new Error('path must be a string'));\n        });\n    }\n    \n    var isFile = opts.isFile || function (file, cb) {\n        fs.stat(file, function (err, stat) {\n            if (err && err.code === 'ENOENT') cb(null, false)\n            else if (err) cb(err)\n            else cb(null, stat.isFile() || stat.isFIFO())\n        });\n    };\n    var readFile = opts.readFile || fs.readFile;\n    \n    var extensions = opts.extensions || [ '.js' ];\n    var y = opts.basedir || path.dirname(caller());\n    \n    opts.paths = opts.paths || [];\n    \n    if (/^(?:\\.\\.?(?:\\/|$)|\\/|([A-Za-z]:)?[\\\\\\/])/.test(x)) {\n        var res = path.resolve(y, x);\n        if (x === '..') res += '/';\n        if (/\\/$/.test(x) && res === y) {\n            loadAsDirectory(res, opts.package, onfile);\n        }\n        else loadAsFile(res, opts.package, onfile);\n    }\n    else loadNodeModules(x, y, function (err, n, pkg) {\n        if (err) cb(err)\n        else if (n) cb(null, n, pkg)\n        else if (core[x]) return cb(null, x);\n        else cb(new Error(\"Cannot find module '\" + x + \"' from '\" + y + \"'\"))\n    });\n    \n    function onfile (err, m, pkg) {\n        if (err) cb(err)\n        else if (m) cb(null, m, pkg)\n        else loadAsDirectory(res, function (err, d, pkg) {\n            if (err) cb(err)\n            else if (d) cb(null, d, pkg)\n            else cb(new Error(\"Cannot find module '\" + x + \"' from '\" + y + \"'\"))\n        })\n    }\n    \n    function loadAsFile (x, pkg, cb) {\n        if (typeof pkg === 'function') {\n            cb = pkg;\n            pkg = undefined;\n        }\n        \n        var exts = [''].concat(extensions);\n        load(exts, x, pkg)\n\t\t\n\t\tfunction load (exts, x, pkg) {\n            if (exts.length === 0) return cb(null, undefined, pkg);\n            var file = x + exts[0];\n            \n            if (pkg) onpkg(null, pkg)\n            else loadpkg(path.dirname(file), onpkg);\n            \n            function onpkg (err, pkg_, dir) {\n                pkg = pkg_;\n                if (err) return cb(err)\n                if (dir && pkg && opts.pathFilter) {\n                    var rfile = path.relative(dir, file);\n                    var rel = rfile.slice(0, rfile.length - exts[0].length);\n                    var r = opts.pathFilter(pkg, x, rel);\n                    if (r) return load(\n                        [''].concat(extensions.slice()),\n                        path.resolve(dir, r),\n                        pkg\n                    );\n                }\n                isFile(file, onex);\n            }\n            function onex (err, ex) {\n                if (err) cb(err)\n                else if (!ex) load(exts.slice(1), x, pkg)\n                else cb(null, file, pkg)\n            }\n        }\n    }\n    \n    function loadpkg (dir, cb) {\n        if (dir === '' || dir === '/') return cb(null);\n        if (process.platform === 'win32' && /^\\w:[\\\\\\/]*$/.test(dir)) {\n            return cb(null);\n        }\n        if (/[\\\\\\/]node_modules[\\\\\\/]*$/.test(dir)) return cb(null);\n        \n        var pkgfile = path.join(dir, 'package.json');\n        isFile(pkgfile, function (err, ex) {\n            // on err, ex is false\n            if (!ex) return loadpkg(\n                path.dirname(dir), cb\n            );\n            \n            readFile(pkgfile, function (err, body) {\n                if (err) cb(err);\n                try { var pkg = JSON.parse(body) }\n                catch (err) {}\n                \n                if (pkg && opts.packageFilter) {\n                    pkg = opts.packageFilter(pkg, pkgfile);\n                }\n                cb(null, pkg, dir);\n            });\n        });\n    }\n    \n    function loadAsDirectory (x, fpkg, cb) {\n        if (typeof fpkg === 'function') {\n            cb = fpkg;\n            fpkg = opts.package;\n        }\n        \n        var pkgfile = path.join(x, '/package.json');\n        isFile(pkgfile, function (err, ex) {\n            if (err) return cb(err);\n            if (!ex) return loadAsFile(path.join(x, '/index'), fpkg, cb);\n            \n            readFile(pkgfile, function (err, body) {\n                if (err) return cb(err);\n                try {\n                    var pkg = JSON.parse(body);\n                }\n                catch (err) {}\n                \n                if (opts.packageFilter) {\n                    pkg = opts.packageFilter(pkg, pkgfile);\n                }\n                \n                if (pkg.main) {\n                    if (pkg.main === '.' || pkg.main === './'){\n                        pkg.main = 'index'\n                    }\n                    loadAsFile(path.resolve(x, pkg.main), pkg, function (err, m, pkg) {\n                        if (err) return cb(err);\n                        if (m) return cb(null, m, pkg);\n                        if (!pkg) return loadAsFile(path.join(x, '/index'), pkg, cb);\n\n                        var dir = path.resolve(x, pkg.main);\n                        loadAsDirectory(dir, pkg, function (err, n, pkg) {\n                            if (err) return cb(err);\n                            if (n) return cb(null, n, pkg);\n                            loadAsFile(path.join(x, '/index'), pkg, cb);\n                        });\n                    });\n                    return;\n                }\n                \n                loadAsFile(path.join(x, '/index'), pkg, cb);\n            });\n        });\n    }\n    \n    function loadNodeModules (x, start, cb) {\n        (function process (dirs) {\n            if (dirs.length === 0) return cb(null, undefined);\n            var dir = dirs[0];\n            \n            var file = path.join(dir, '/', x);\n            loadAsFile(file, undefined, onfile);\n            \n            function onfile (err, m, pkg) {\n                if (err) return cb(err);\n                if (m) return cb(null, m, pkg);\n                loadAsDirectory(path.join(dir, '/', x), undefined, ondir);\n            }\n            \n            function ondir (err, n, pkg) {\n                if (err) return cb(err);\n                if (n) return cb(null, n, pkg);\n                process(dirs.slice(1));\n            }\n        })(nodeModulesPaths(start, opts));\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-aurelia-cli/node_modules/aurelia-cli/lib/resolve/lib/caller.js":"module.exports = function () {\n    // see https://code.google.com/p/v8/wiki/JavaScriptStackTraceApi\n    var origPrepareStackTrace = Error.prepareStackTrace;\n    Error.prepareStackTrace = function (_, stack) { return stack };\n    var stack = (new Error()).stack;\n    Error.prepareStackTrace = origPrepareStackTrace;\n    return stack[2].getFileName();\n};\n","/home/travis/build/npmtest/node-npmtest-aurelia-cli/node_modules/aurelia-cli/lib/resolve/lib/node-modules-paths.js":"var path = require('path');\n\nmodule.exports = function (start, opts) {\n    var modules = opts.moduleDirectory\n        ? [].concat(opts.moduleDirectory)\n        : ['node_modules']\n    ;\n\n    // ensure that `start` is an absolute path at this point,\n    // resolving against the process' current working directory\n    start = path.resolve(start);\n\n    var prefix = '/';\n    if (/^([A-Za-z]:)/.test(start)) {\n        prefix = '';\n    } else if (/^\\\\\\\\/.test(start)) {\n        prefix = '\\\\\\\\';\n    }\n\n    var splitRe = process.platform === 'win32' ? /[\\/\\\\]/ : /\\/+/;\n\n    var parts = start.split(splitRe);\n\n    var dirs = [];\n    for (var i = parts.length - 1; i >= 0; i--) {\n        if (modules.indexOf(parts[i]) !== -1) continue;\n        dirs = dirs.concat(modules.map(function(module_dir) {\n            return prefix + path.join(\n                path.join.apply(path, parts.slice(0, i + 1)),\n                module_dir\n            );\n        }));\n    }\n    if (process.platform === 'win32'){\n        dirs[dirs.length-1] = dirs[dirs.length-1].replace(\":\", \":\\\\\");\n    }\n    return dirs.concat(opts.paths);\n}\n","/home/travis/build/npmtest/node-npmtest-aurelia-cli/node_modules/aurelia-cli/lib/resolve/lib/sync.js":"var core = require('./core');\nvar fs = require('fs');\nvar path = require('path');\nvar caller = require('./caller.js');\nvar nodeModulesPaths = require('./node-modules-paths.js');\n\nmodule.exports = function (x, opts) {\n    if (!opts) opts = {};\n    var isFile = opts.isFile || function (file) {\n        try { var stat = fs.statSync(file) }\n        catch (err) { if (err && err.code === 'ENOENT') return false }\n        return stat.isFile() || stat.isFIFO();\n    };\n    var readFileSync = opts.readFileSync || fs.readFileSync;\n\n    var extensions = opts.extensions || [ '.js' ];\n    var y = opts.basedir || path.dirname(caller());\n\n    opts.paths = opts.paths || [];\n\n    if (/^(?:\\.\\.?(?:\\/|$)|\\/|([A-Za-z]:)?[\\\\\\/])/.test(x)) {\n        var res = path.resolve(y, x);\n        if (x === '..') res += '/';\n        var m = loadAsFileSync(res) || loadAsDirectorySync(res);\n        if (m) return m;\n    } else {\n        var n = loadNodeModulesSync(x, y);\n        if (n) return n;\n    }\n\n    if (core[x]) return x;\n\n    throw new Error(\"Cannot find module '\" + x + \"' from '\" + y + \"'\");\n\n    function loadAsFileSync (x) {\n        if (isFile(x)) {\n            return x;\n        }\n\n        for (var i = 0; i < extensions.length; i++) {\n            var file = x + extensions[i];\n            if (isFile(file)) {\n                return file;\n            }\n        }\n    }\n\n    function loadAsDirectorySync (x) {\n        var pkgfile = path.join(x, '/package.json');\n        if (isFile(pkgfile)) {\n            var body = readFileSync(pkgfile, 'utf8');\n            try {\n                var pkg = JSON.parse(body);\n                if (opts.packageFilter) {\n                    pkg = opts.packageFilter(pkg, x);\n                }\n\n                if (pkg.main) {\n                    var m = loadAsFileSync(path.resolve(x, pkg.main));\n                    if (m) return m;\n                    var n = loadAsDirectorySync(path.resolve(x, pkg.main));\n                    if (n) return n;\n                }\n            }\n            catch (err) {}\n        }\n\n        return loadAsFileSync(path.join( x, '/index'));\n    }\n\n    function loadNodeModulesSync (x, start) {\n        var dirs = nodeModulesPaths(start, opts);\n        for (var i = 0; i < dirs.length; i++) {\n            var dir = dirs[i];\n            var m = loadAsFileSync(path.join( dir, '/', x));\n            if (m) return m;\n            var n = loadAsDirectorySync(path.join( dir, '/', x ));\n            if (n) return n;\n        }\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-aurelia-cli/node_modules/aurelia-cli/lib/dependencies.js":"'use strict';\n\nlet versionMap = {\n  'aurelia-animator-css': '^1.0.1',\n  'aurelia-bootstrapper': '^2.1.0',\n  'aurelia-cli': '^0.27.0',\n  'aurelia-testing': '^1.0.0-beta.2.0.1',\n  'aurelia-tools': '^1.0.0',\n  'autoprefixer': '^6.3.6',\n  'babel-eslint': '^6.0.4',\n  'babel-plugin-syntax-flow': '^6.8.0',\n  'babel-plugin-transform-decorators-legacy': '^1.3.4',\n  'babel-plugin-transform-es2015-modules-amd': '^6.8.0',\n  'babel-plugin-transform-es2015-modules-commonjs': '^6.10.3',\n  'babel-plugin-transform-flow-strip-types': '^6.8.0',\n  'babel-preset-es2015': '^6.13.2',\n  'babel-preset-stage-1': '^6.5.0',\n  'babel-polyfill': '^6.9.1',\n  'babel-register': '^6.9.0',\n  'bluebird': '^3.4.1',\n  'browser-sync': '^2.13.0',\n  'connect-history-api-fallback': '^1.2.0',\n  'event-stream': '^3.3.3',\n  'gulp': 'github:gulpjs/gulp#4.0',\n  'gulp-babel': '^6.1.2',\n  'gulp-changed-in-place': '^2.0.3',\n  'gulp-eslint': '^2.0.0',\n  'gulp-htmlmin': '^3.0.0',\n  'gulp-notify': '^2.2.0',\n  'gulp-plumber': '^1.1.0',\n  'gulp-rename': '^1.2.2',\n  'gulp-sourcemaps': '^2.0.0-alpha',\n  'gulp-less': '^3.1.0',\n  'gulp-postcss': '6.1.1',\n  'gulp-sass': '^2.3.2',\n  'gulp-stylus': '^2.5.0',\n  'gulp-typescript': '^3.1.4',\n  'gulp-tslint': '^5.0.0',\n  'html-minifier': '^3.2.3',\n  'jasmine-core': '^2.4.1',\n  'karma': '^0.13.22',\n  'karma-chrome-launcher': '^1.0.1',\n  'karma-jasmine': '^1.0.2',\n  'karma-babel-preprocessor': '^6.0.1',\n  'karma-typescript-preprocessor': '^0.2.1',\n  'minimatch': '^3.0.2',\n  'requirejs': '^2.3.2',\n  'text': 'github:requirejs/text#latest',\n  'through2': '^2.0.1',\n  'tslint': '^3.11.0',\n  '@types/jasmine': '^2.2.0',\n  '@types/node': '^6.0.45',\n  'typescript': '>=1.9.0-dev || ^2.0.0',\n  'uglify-js': '^2.6.3',\n  'vinyl-fs': '^2.4.3'\n};\n\nexports.getSupportedVersion = function(name) {\n  return versionMap[name] || 'latest';\n};\n","/home/travis/build/npmtest/node-npmtest-aurelia-cli/node_modules/aurelia-cli/lib/npm.js":"'use strict';\n\nlet isLoaded = false;\n\nexports.NPM = class {\n  install(packages, npmOptions) {\n    npmOptions = npmOptions || {};\n    const npm = require('npm');\n\n    let originalWorkingDirectory = process.cwd();\n    process.chdir(npmOptions.workingDirectory || process.cwd());\n\n    return load(npm, npmOptions)\n      .then(() => {\n        return new Promise((resolve, reject) => {\n          npm.commands.install(packages, error => {\n            process.chdir(originalWorkingDirectory);\n\n            if (error) reject(error);\n            else resolve();\n          });\n        });\n      }).catch(error => {\n        process.chdir(originalWorkingDirectory);\n        throw error;\n      });\n  }\n};\n\nfunction load(npm, npmOptions) {\n  if (isLoaded) {\n    for (let key in npmOptions) {\n      npm.config.set(key, npmOptions[key]);\n    }\n\n    return Promise.resolve();\n  }\n\n  return new Promise((resolve, reject) => {\n    npm.load(npmOptions, error => {\n      if (error) reject(error);\n      else {\n        isLoaded = true;\n        resolve();\n      }\n    });\n  });\n}\n","/home/travis/build/npmtest/node-npmtest-aurelia-cli/node_modules/aurelia-cli/lib/colors/index.js":"var colors = {};\nmodule['exports'] = colors;\n\ncolors.themes = {};\n\nvar ansiStyles = colors.styles = require('./styles');\nvar defineProps = Object.defineProperties;\n\ncolors.supportsColor = require('./supports-colors');\n\nif (typeof colors.enabled === \"undefined\") {\n  colors.enabled = colors.supportsColor;\n}\n\ncolors.stripColors = colors.strip = function(str){\n  return (\"\" + str).replace(/\\x1B\\[\\d+m/g, '');\n};\n\n\nvar stylize = colors.stylize = function stylize (str, style) {\n  if (!colors.enabled) {\n    return str+'';\n  }\n\n  return ansiStyles[style].open + str + ansiStyles[style].close;\n}\n\nvar matchOperatorsRe = /[|\\\\{}()[\\]^$+*?.]/g;\nvar escapeStringRegexp = function (str) {\n  if (typeof str !== 'string') {\n    throw new TypeError('Expected a string');\n  }\n  return str.replace(matchOperatorsRe,  '\\\\$&');\n}\n\nfunction build(_styles) {\n  var builder = function builder() {\n    return applyStyle.apply(builder, arguments);\n  };\n  builder._styles = _styles;\n  // __proto__ is used because we must return a function, but there is\n  // no way to create a function with a different prototype.\n  builder.__proto__ = proto;\n  return builder;\n}\n\nvar styles = (function () {\n  var ret = {};\n  ansiStyles.grey = ansiStyles.gray;\n  Object.keys(ansiStyles).forEach(function (key) {\n    ansiStyles[key].closeRe = new RegExp(escapeStringRegexp(ansiStyles[key].close), 'g');\n    ret[key] = {\n      get: function () {\n        return build(this._styles.concat(key));\n      }\n    };\n  });\n  return ret;\n})();\n\nvar proto = defineProps(function colors() {}, styles);\n\nfunction applyStyle() {\n  var args = arguments;\n  var argsLen = args.length;\n  var str = argsLen !== 0 && String(arguments[0]);\n  if (argsLen > 1) {\n    for (var a = 1; a < argsLen; a++) {\n      str += ' ' + args[a];\n    }\n  }\n\n  if (!colors.enabled || !str) {\n    return str;\n  }\n\n  var nestedStyles = this._styles;\n\n  var i = nestedStyles.length;\n  while (i--) {\n    var code = ansiStyles[nestedStyles[i]];\n    str = code.open + str.replace(code.closeRe, code.open) + code.close;\n  }\n\n  return str;\n}\n\nfunction applyTheme (theme) {\n  for (var style in theme) {\n    (function(style){\n      colors[style] = function(str){\n        if (typeof theme[style] === 'object'){\n          var out = str;\n          for (var i in theme[style]){\n            out = colors[theme[style][i]](out);\n          }\n          return out;\n        }\n        return colors[theme[style]](str);\n      };\n    })(style)\n  }\n}\n\ncolors.setTheme = function (theme) {\n  if (typeof theme === 'string') {\n    try {\n      colors.themes[theme] = require(theme);\n      applyTheme(colors.themes[theme]);\n      return colors.themes[theme];\n    } catch (err) {\n      console.log(err);\n      return err;\n    }\n  } else {\n    applyTheme(theme);\n  }\n};\n\nfunction init() {\n  var ret = {};\n  Object.keys(styles).forEach(function (name) {\n    ret[name] = {\n      get: function () {\n        return build([name]);\n      }\n    };\n  });\n  return ret;\n}\n\ndefineProps(colors, init());\n","/home/travis/build/npmtest/node-npmtest-aurelia-cli/node_modules/aurelia-cli/lib/commands/gulp.js":"'use strict';\nconst UI = require('../ui').UI;\nconst CLIOptions = require('../cli-options').CLIOptions;\nconst Container = require('aurelia-dependency-injection').Container;\nconst Project = require('../project').Project;\n\nmodule.exports = class {\n  static inject() { return [Container, UI, CLIOptions, Project]; }\n\n  constructor(container, ui, options, project) {\n    this.container = container;\n    this.ui = ui;\n    this.options = options;\n    this.project = project;\n  }\n\n  execute(args) {\n    return new Promise((resolve, reject) => {\n      const gulp = require('gulp');\n      this.connectLogging(gulp);\n\n      this.project.installTranspiler();\n\n      makeInjectable(gulp, 'series', this.container);\n      makeInjectable(gulp, 'parallel', this.container);\n\n      process.nextTick(() => {\n        let task = this.project.getExport(require(this.options.taskPath), this.options.commandName);\n\n        gulp.series(task)(error => {\n          if (error) reject(error);\n          else resolve();\n        });\n      });\n    });\n  }\n\n  connectLogging(gulp) {\n    gulp.on('start', e => {\n      if (e.name[0] === '<') return;\n      this.ui.log(`Starting '${e.name}'...`);\n    });\n\n    gulp.on('stop', e => {\n      if (e.name[0] === '<') return;\n      this.ui.log(`Finished '${e.name}'`);\n    });\n\n    gulp.on('error', e => this.ui.log(e));\n  }\n};\n\nfunction makeInjectable(gulp, name, container) {\n  let original = gulp[name];\n\n  gulp[name] = function() {\n    let args = new Array(arguments.length);\n\n    for (let i = 0, ii = arguments.length; i < ii; ++i) {\n      let task = arguments[i];\n\n      if (task.inject) {\n        let taskName = task.name;\n        task = container.get(task);\n        task = task.execute.bind(task);\n        task.displayName = taskName;\n      }\n\n      args[i] = task;\n    }\n\n    return original.apply(gulp, args);\n  };\n}\n","/home/travis/build/npmtest/node-npmtest-aurelia-cli/node_modules/aurelia-cli/lib/importer/import-engine.js":"'use strict';\n\nconst fs = require('../file-system');\nconst UI = require('../ui').UI;\nconst CLIOptions = require('../cli-options').CLIOptions;\nconst Container = require('aurelia-dependency-injection').Container;\nconst MetadataService = require('./services/metadata-service');\nconst ResourceInclusion = require('./services/resource-inclusion');\nconst Registry = require('./services/registry');\nconst Package = require('./package');\nconst Project = require('../project').Project;\nconst PackageImporter = require('./package-importer');\n\nmodule.exports = class {\n\n  static inject() { return [CLIOptions, Container, Project, UI]; }\n\n  constructor(cliOptions, container, project, ui) {\n    this.cliOptions = cliOptions;\n    this.container = container;\n    this.project = project;\n    this.ui = ui;\n  }\n\n  import(packages) {\n    let index = 0;\n    let that = this;\n\n    function _importPackage() {\n      if (index === packages.length) {\n        return Promise.resolve();\n      }\n\n      return that.importPackage(packages[index++])\n      .then(_importPackage);\n    }\n\n    return _importPackage();\n  }\n\n  importPackage(pkg) {\n    let container = this.getContainer(pkg);\n    let importer = container.get(PackageImporter);\n    return importer.import();\n  }\n\n  getContainer(pkg) {\n    // use a clean DI container for the entire import process\n    let container = new Container();\n\n    pkg = new Package(pkg);\n\n    container.registerInstance('parameters', {\n      action: 'install',\n      bundle: this.cliOptions.getFlagValue('bundle', '-b') || this.project.getDefaultBundle().name\n    });\n    container.registerInstance(UI, this.ui);\n    container.registerInstance('project', this.project);\n    container.registerInstance('package', pkg);\n    container.registerInstance('fs', fs);\n    container.registerAlias(UI, 'ui');\n    container.registerAlias(ResourceInclusion, 'resource-inclusion');\n    container.registerAlias(MetadataService, 'metadata-service');\n    container.registerAlias(Registry, 'registry');\n\n    pkg.resourceInclusion = container.get('resource-inclusion');\n\n    return container;\n  }\n};\n\n","/home/travis/build/npmtest/node-npmtest-aurelia-cli/node_modules/aurelia-cli/lib/importer/services/metadata-service.js":"'use strict';\n\nconst copySync = require('../../file-system').copySync;\nconst join = require('../../file-system').join;\nconst statSync = require('../../file-system').statSync;\nconst execSync = require('child_process').execSync;\nconst logger = require('aurelia-logging').getLogger('Metadata');\n\nlet MetadataService = class {\n\n  static inject() { return ['package', 'parameters', 'project']; }\n\n  constructor(pkg, parameters, project) {\n    this.package = pkg;\n    this.parameters = parameters;\n    this.project = project;\n  }\n\n  execute(metadata) {\n    return Promise.resolve(this.patches(metadata.patches))\n      .then(() => this.dependencies(metadata.dependencies))\n      .then(() => this.bundles(metadata.bundles))\n      .then(() => this.tasks(metadata.tasks))\n      .then(() => this.scripts(metadata.scripts))\n      .then(() => this.project.writeAureliaJSON());\n  }\n\n  patches(instructions) {\n    if (!instructions || instructions.length === 0) {\n      return;\n    }\n\n    this.project.applyPatch(instructions);\n  }\n\n  dependencies(metadataDependencies) {\n    if (!metadataDependencies || metadataDependencies.length === 0) {\n      return;\n    }\n\n    let targetBundle = this.project.getBundle(this.parameters.bundle);\n\n    if (!targetBundle) {\n      throw new Error(`Could not find target bundle: ${this.parameters.bundle}`);\n    }\n\n    logger.info(`Adding/removing dependencies to the '${targetBundle.name}' bundle`);\n\n    for (let metadataDep of metadataDependencies) {\n      let name = metadataDep.name || metadataDep;\n      let existingDependency = this.project.getDependency(targetBundle, name);\n\n      if (this.parameters.action === 'install') {\n        if (!existingDependency) {\n          this.project.addDependency(targetBundle, metadataDep);\n          logger.info(`The '${name}' dependency has been added.`);\n        } else {\n          this.project.replaceDependency(targetBundle, existingDependency, metadataDep);\n          logger.info(`The '${name}' dependency has been modified.`);\n        }\n      } else if (this.parameters.action === 'uninstall') {\n        this.project.removeDependency(targetBundle, dependency);\n        logger.info(`The '${name}' dependency has been removed.`);\n      }\n    }\n  }\n\n  bundles(bundles) {\n    if (!bundles || bundles.length === 0) {\n      logger.debug('No bundles need to be created');\n      return;\n    }\n\n    logger.info('Bundles found. Creating new bundles in aurelia.json...');\n    for (let bundle of bundles) {\n      let existingBundle = this.project.getBundle(bundle.name);\n\n      if (this.parameters.action === 'install') {\n        if (!existingBundle) {\n          this.project.addBundle(bundle);\n          logger.info(`Bundle '${bundle.name}' has been created.`);\n        } else {\n          this.project.replaceBundle(existingBundle, bundle);\n          logger.info(`Bundle '${bundle.name}' has been modified.`);\n        }\n      } else if (this.parameters.action === 'uninstall') {\n        this.project.removeBundle(bundle);\n        logger.info(`Bundle '${bundle.name}' has been removed.`);\n      }\n    }\n  }\n\n  scripts(instructions) {\n    if (!instructions || instructions.length === 0) {\n      return;\n    }\n\n    try {\n      let scripts = instructions[this.parameters.action];\n\n      if (scripts && scripts.length > 0) {\n        logger.info('Scripts found. Executing...');\n        for (let script of scripts) {\n          logger.info(`Executing: ${script}`);\n          execSync(script, {stdio: [0, 1, 2]});\n        }\n      }\n\n      logger.info('Scripts finished successfully.');\n    } catch (e) {\n      logger.error('An error occurred during script execution.', e.message);\n    }\n  }\n\n  tasks(tasks) {\n    if (!tasks || tasks.length === 0) {\n      logger.debug('No tasks have to be created');\n      return;\n    }\n\n    logger.info(`${tasks.length} custom task(s) found. Copying to aurelia_project/tasks folder...`);\n\n    let projectFolder = 'aurelia_project/';\n    let fileExtension = this.project.getAureliaJSON().transpiler.fileExtension;\n    let destFolder = `${projectFolder}tasks/`;\n\n    for (let taskName of tasks) {\n      // determinate transpiler to set correct file extension\n      let filename = taskName + fileExtension;\n      let destFile = destFolder + filename;\n      let source = null;\n\n      try {\n        // by default, search in installed package directory\n        let pkgName = this.parameters.package;\n        pkgName = pkgName.indexOf('@') !== -1 ? pkgName.split('@')[0] : pkgName;\n        source = join(this.package.pluginPath, 'tasks', taskName);\n        copySync(`${source}.js`, destFile);\n      } catch (err) {\n        logger.error(`Could not copy the '${taskName}' task from '${source}' to '${destFile}`, err);\n      }\n\n      // task metadata is optional\n      try {\n        let fileInfo = statSync(`${source}.json`);\n        if (fileInfo.isFile()) {\n          copySync(`${source}.json`, `${dest + taskName}.json`);\n        }\n      } catch (err) {\n        if (err.code !== 'ENOENT') {\n          logger.error(`Error while copying task metadata '${source}.json': `, err);\n        }\n      }\n\n      logger.info(`Custom task: ${taskName} has been installed.`);\n    }\n\n    logger.info('Custom tasks have been installed successfully.\\n');\n  }\n};\n\nmodule.exports = MetadataService;\n","/home/travis/build/npmtest/node-npmtest-aurelia-cli/node_modules/aurelia-cli/lib/importer/services/resource-inclusion.js":"'use strict';\n\nconst UI = require('../../ui').UI;\nconst path = require('path');\nconst glob = require('glob');\n\nlet ResourceInclusion = class {\n\n  static inject() { return [UI, 'package']; }\n\n  constructor(ui, pkg) {\n    this.ui = ui;\n    this.package = pkg;\n  }\n\n  getCSS() {\n    let subdirs = '?(dist|build|lib|css|style|styles)/**/*.css';\n    let curDir = '*.css';\n\n    return Promise.all([\n      this.getResources(subdirs),\n      this.getResources(curDir)\n    ])\n    .then(cssFiles => cssFiles[0].concat(cssFiles[1]))\n    .then(cssFiles => {\n      if (cssFiles.length === 0) {\n        return [];\n      }\n\n      let question = `The importer has found ${cssFiles.length} css file(s). Do you want to include some?`;\n      let options = [\n        {\n          displayName: 'Yes',\n          description: 'I want choose which css files I need'\n        },\n        {\n          displayName: 'No',\n          description: 'I do not need css files'\n        }\n      ];\n      return this.ui.question(question, options)\n      .then(answer => {\n        if (answer.displayName === 'Yes') {\n          let optionList = cssFiles.map(x => {\n            return {\n              displayName: x\n            };\n          });\n\n          return this.ui.multiselect('What files do you need?', optionList)\n          .then(answers => answers.map(x => x.displayName));\n        }\n\n        return [];\n      });\n    });\n  }\n\n  getResources(globExpr) {\n    return this.glob(globExpr, { cwd: this.package.rootPath })\n    .then(files => files.map(file => path.posix.join(file)));\n  }\n\n  glob(globExpr, options) {\n    return new Promise((resolve, reject) => {\n      glob(globExpr, options, function(er, files) {\n        if (er) {\n          reject(er);\n        }\n        resolve(files);\n      });\n    });\n  }\n};\n\nmodule.exports = ResourceInclusion;\n","/home/travis/build/npmtest/node-npmtest-aurelia-cli/node_modules/aurelia-cli/lib/importer/services/registry.js":"'use strict';\n\nconst fs = require('../../file-system');\nconst semver = require('semver');\n\nlet Registry = class {\n  getPackageConfig(pkg, version) {\n    let folder = fs.join(__dirname, `../registry/${pkg.name}`);\n\n    if (!fs.existsSync(folder)) {\n      return Promise.resolve(null);\n    }\n\n    return this._getAvailableVersions(folder)\n    .then(files => this._findBestMatch(files, version))\n    .then(match => {\n      if (!match) {\n        return Promise.resolve(null);\n      }\n\n      return fs.readFile(fs.join(folder, match + '.json'));\n    }).then(contents => JSON.parse(contents));\n  }\n\n  _getAvailableVersions(folder) {\n    return fs.readdir(folder)\n    .then(files => {\n      return files.map(x => x.replace('.json', ''));\n    });\n  }\n\n  // find the closest matching version to the target\n  // but not anything above the target version\n  _findBestMatch(versions, target) {\n    let bestMatch;\n\n    let validVersions = versions.filter(x => semver.valid(x));\n\n    for (let i = 0; i < validVersions.length; i++) {\n      let version = validVersions[i];\n\n      if (semver.eq(version, target)) {\n        return version;\n      }\n\n      if (semver.lt(version, target)) {\n        if (!bestMatch || semver.gt(version, bestMatch)) {\n          bestMatch = version;\n        }\n      }\n    }\n\n    return bestMatch;\n  }\n};\n\nmodule.exports = Registry;\n","/home/travis/build/npmtest/node-npmtest-aurelia-cli/node_modules/aurelia-cli/lib/importer/package.js":"'use strict';\n\nconst fs = require('../file-system');\nconst path = require('path');\n\nmodule.exports = class {\n  constructor(pkg) {\n    this.name = pkg.name;\n    this.path = path.posix.join('../node_modules/', this.name);\n    this.rootPath = fs.resolve(fs.join('node_modules', this.name));\n    this.packageJSONPath = fs.join(this.rootPath, 'package.json');\n    this.resources = [];\n  }\n\n  isInstalled(pkg) {\n    return fs.existsSync(this.packageJSONPath);\n  }\n\n  fetchPackageJSON() {\n    this.packageJSON = JSON.parse(fs.readFileSync(this.packageJSONPath, 'utf8'));\n    return this;\n  }\n\n  getModuleId(fileName) {\n    let moduleId = fileName.replace(/\\\\/g, '/');\n    let ext = path.extname(moduleId);\n    moduleId = moduleId.substring(0, moduleId.length - ext.length);\n\n    return moduleId;\n  }\n\n  detectResources() {\n    return this.resourceInclusion.getCSS()\n    .then(resources => {\n      for (let resource of resources) {\n        this.resources.push(resource);\n      }\n    });\n  }\n\n  parsePackageJSON() {\n    this.name = this.packageJSON.name;\n    this.version = this.packageJSON.version;\n\n    if (this.packageJSON.main && !this.main) {\n      this.main = this.packageJSON.main;\n    }\n\n    return this;\n  }\n\n  getConfiguration() {\n    let config;\n\n    if (this.main) {\n      config = {\n        name: this.name,\n        main: this.main,\n        path: this.path,\n        resources: this.resources\n      };\n    } else {\n      config = this.name;\n    }\n\n    return config;\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-aurelia-cli/node_modules/aurelia-cli/lib/importer/package-importer.js":"'use strict';\n\nconst Container = require('aurelia-dependency-injection').Container;\nconst StrategyLoader = require('./strategy-loader');\nconst Tutorial = require('./services/tutorial');\nconst MetadataService = require('./services/metadata-service');\nconst logger = require('aurelia-logging').getLogger('Importer');\n\nmodule.exports = class {\n  static inject() { return [Container, 'package', StrategyLoader, Tutorial, MetadataService]; }\n\n  constructor(container, pkg, strategyLoader, tutorial, metadataService) {\n    this.container = container;\n    this.package = pkg;\n    this.strategies = strategyLoader.getStrategies();\n    this.tutorial = tutorial;\n    this.metadataService = metadataService;\n  }\n\n  import() {\n    if (!this.package.isInstalled()) {\n      logger.info(`Package \"${this.package.name}\" has not been installed. Skipping.`);\n      return Promise.resolve();\n    }\n\n    logger.info('---------------------------------------------------------');\n    logger.info(`*********** Configuring ${this.package.name} ***********`);\n\n    this.package.fetchPackageJSON().parsePackageJSON();\n\n    return this.findStrategy()\n    .then(strategy => {\n      if (!strategy) {\n        throw new Error('No strategies were able to configure this package. Please let us know.');\n      }\n\n      logger.info(`[OK] Going to execute the \"${strategy.name}\" strategy`);\n\n      return Promise.resolve(strategy.execute())\n      .catch(err => {\n        logger.error(`An error occurred during the exection of the \"${strategy.name}\" importer strategy`);\n        logger.error(err);\n        logger.error(err.stack);\n\n        throw err;\n      })\n      .then(instructions => {\n        logger.info(`*********** Finished configuring ${this.package.name} ***********`);\n\n        if (instructions) {\n          logger.debug('Applying the following configuration: ', instructions);\n\n          return this.metadataService.execute(instructions)\n          .then(() => this.tutorial.start(instructions));\n        }\n\n        return this.tutorial.start();\n      });\n    })\n    .then(() => logger.info('---------------------------------------------------------'));\n  }\n\n  findStrategy() {\n    let index = 0;\n\n    function _findStrategy() {\n      if (index === this.strategies.length) {\n        return;\n      }\n\n      let strategy = this.strategies[index++];\n\n      return Promise.resolve(strategy.applies())\n      .then(canExecute => {\n        if (!canExecute) {\n          logger.debug(`[SKIP] The \"${strategy.name}\" strategy declined configuration`);\n\n          return _findStrategy.call(this);\n        }\n\n        return strategy;\n      });\n    }\n\n    return _findStrategy.call(this);\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-aurelia-cli/node_modules/aurelia-cli/lib/importer/strategy-loader.js":"'use strict';\n\nconst fs = require('../file-system');\nconst Container = require('aurelia-dependency-injection').Container;\n\nlet StrategyLoader = class {\n\n  static inject() { return [Container]; }\n\n  constructor(container) {\n    this.container = container;\n  }\n\n  getStrategies() {\n    let files = [\n      'metadata',\n      'custom-importer',\n      'aurelia-registry',\n      'jspm-section',\n      'browser-section',\n      'amodro'\n    ];\n    let strategies = [];\n\n    for (let file of files) {\n      let path = fs.join(__dirname, 'strategies', file);\n      let ctor = require(path);\n      let strategy = this.container.get(ctor);\n\n      strategies.push(strategy);\n    }\n\n    return strategies;\n  }\n};\n\nmodule.exports = StrategyLoader;\n","/home/travis/build/npmtest/node-npmtest-aurelia-cli/node_modules/aurelia-cli/lib/importer/services/tutorial.js":"'use strict';\n\nconst logger = require('aurelia-logging').getLogger('Tutorial');\n\nmodule.exports = class {\n  static inject() { return ['registry', 'package']; }\n\n  constructor(registry, pkg) {\n    this.registry = registry;\n    this.package = pkg;\n  }\n\n  start(metadata) {\n    return Promise.resolve(this.getTutorial(metadata))\n    .then(tutorial => {\n      logger.info('*********** Tutorial ***********');\n\n      if (tutorial) {\n        for (let line of tutorial) {\n          logger.info(line);\n        }\n      } else {\n        logger.info(`Are you the maintainer of ${this.package.name} and would you like to define a tutorial that is displayed here?`);\n        logger.info(`In order to do so you can add an \"aurelia\".\"import\".\"tutorial\" section to the package.json of ${this.package.name}. This can be set to an array of strings.`);\n      }\n\n      if (metadata && metadata.dependencies) {\n        let dependenciesWithResources =\n          metadata.dependencies.filter(x => x.resources && x.resources.length > 0);\n\n        if (dependenciesWithResources.length > 0) {\n          logger.info('*********** Using resources ***********');\n\n          for (let dep of dependenciesWithResources) {\n            logger.info(`${dep.name} has resources. The following require statements can be used to load these resources:`);\n\n            for (let resource of dep.resources) {\n              logger.info(`<require from=\"${dep.name}/${resource}\"></require>`);\n            }\n          }\n        }\n      }\n\n      logger.info('*********** Importing the module ***********');\n      logger.info('The following import statements are possible:');\n      logger.info(`import '${this.package.name}';`);\n      logger.info(`import ${this.package.name} from '${this.package.name}';`);\n      logger.info(`import * as ${this.package.name} from '${this.package.name}';`);\n      logger.info('We are looking into ways to detect what is the right one');\n      logger.info('*********** End of tutorial ***********');\n    });\n  }\n\n  getTutorial(metadata) {\n    if (metadata && metadata.tutorial) {\n      return metadata.tutorial;\n    }\n\n    let aureliaSection = this.package.packageJSON.aurelia;\n    if (aureliaSection &&\n        aureliaSection.import &&\n        typeof(aureliaSection.import === 'object') &&\n        aureliaSection.import.tutorial) {\n      return aureliaSection.import.tutorial;\n    }\n\n    return this.registry.getPackageConfig(this.package, this.package.version)\n    .then(config => {\n      if (config) {\n        return config.tutorial;\n      }\n    });\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-aurelia-cli/node_modules/aurelia-cli/lib/importer/package-installer.js":"'use strict';\n\nconst Project = require('../project').Project;\nconst logger = require('aurelia-logging').getLogger('Package-installer');\n\nlet PackageInstaller = class {\n  static inject() { return [Project]; }\n\n  constructor(project) {\n    this.project = project;\n  }\n\n  install(packages) {\n    let aureliaJSON = this.project.model;\n    let packageManager = aureliaJSON.packageManager || 'npm';\n    let options = {};\n    let Ctor;\n\n    logger.info(`Using '${packageManager}' to install the package(s). You can change this by setting the 'packageManager' property in the aurelia.json file to 'npm' or 'yarn'.`);\n\n    try {\n      Ctor = require(`../package-managers/${packageManager}`).default;\n    } catch (e) {\n      logger.error(`Could not load the ${packageManager} package installer. Falling back to NPM`, e);\n\n      packageManager = 'npm';\n      Ctor = require(`../package-managers/${packageManager}`).default;\n    }\n\n    let installer = new Ctor();\n\n    if (packageManager === 'npm') {\n      options = {\n        progress: false,\n        save: true\n      };\n    }\n\n    logger.info('*********** INSTALLING PACKAGES ***********');\n\n    return installer.install(packages.map(x => x.argument), options);\n  }\n};\n\nmodule.exports = PackageInstaller;\n","/home/travis/build/npmtest/node-npmtest-aurelia-cli/node_modules/aurelia-cli/lib/package-managers/yarn.js":"'use strict';\n\nconst childProcess = require('child_process');\n\nexports.yarn = class {\n  install(packages) {\n    return new Promise((resolve, reject) => {\n      let cmd = `yarn add ${packages.join(' ')}`;\n      let options = { cwd: process.cwd() };\n\n      let installProcess = childProcess.exec(cmd, options, (error, stdout, stderr) => {\n        if (error) {\n          reject(error);\n          return;\n        }\n\n        resolve();\n      });\n\n      installProcess.stdout.on('data', data => console.log(data));\n    });\n  }\n};\n\nexports.default = exports.yarn;\n","/home/travis/build/npmtest/node-npmtest-aurelia-cli/node_modules/aurelia-cli/lib/workflow/workflow-engine.js":"'use strict';\nconst Container = require('aurelia-dependency-injection').Container;\n\nexports.WorkflowEngine = class {\n  constructor(definition, container) {\n    this.definition = definition;\n    this.container = container || new Container();\n\n    this.configureContainer(this.container);\n  }\n\n  start(state) {\n    return new Promise((resolve, reject) => {\n      let context = new exports.WorkflowContext(this, state, resolve, reject);\n      let activity = this.createActivity(this.definition.activities[0]);\n      activity.execute(context);\n    });\n  }\n\n  getActivityById(id) {\n    return this.definition.activities.find(x => x.id === id);\n  }\n\n  createActivity(definition) {\n    let activity = this.container.get(definition.type);\n    Object.assign(activity, definition);\n    return activity;\n  }\n\n  configureContainer(container) {\n    [\n      'state-assign',\n      'input-text',\n      'input-select',\n      'branch-switch',\n      'project-create',\n      'project-install'\n    ].forEach(type => {\n      container.registerTransient(type, require(`./activities/${type}`));\n    });\n  }\n};\n\nexports.WorkflowContext = class {\n  constructor(workflow, state, resolve, reject) {\n    this.workflow = workflow;\n    this.state = state || {};\n    this._resolve = resolve;\n    this._reject = reject;\n  }\n\n  next(activityId) {\n    if (activityId === null || activityId === undefined) {\n      return this._resolve(this.state);\n    }\n\n    let next = this.workflow.getActivityById(activityId);\n\n    if (!next) {\n      return this._resolve(this.state);\n    }\n\n    let activity = this.workflow.createActivity(next);\n    activity.execute(this);\n  }\n\n  cancel() {\n    this._reject(this.state);\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-aurelia-cli/node_modules/aurelia-cli/spec/helpers/polyfills.js":"require('aurelia-polyfills');\n","/home/travis/build/npmtest/node-npmtest-aurelia-cli/node_modules/aurelia-cli/spec/lib/cli.spec.js":"\"use strict\";\ndescribe('The cli', () => {\n  let fs;\n  let path;\n  let mockfs;\n  let cli;\n  let Project;\n  let project;\n\n  let dir;\n  let aureliaProject;\n\n  beforeEach(() => {\n    fs = require('../../lib/file-system');\n    path = require('path');\n    cli = new (require('../../lib/cli').CLI)();\n    Project = require('../../lib/project').Project;\n    mockfs = require('mock-fs');\n    project = {};\n\n    dir = 'workspaces';\n    aureliaProject = 'aurelia_project';\n    const fsConfig = {};\n    fsConfig[dir] = {};\n    fsConfig['package.json'] = {};\n    \n    mockfs(fsConfig);    \n  });\n\n  afterEach(() => {\n    mockfs.restore();\n  });\n\n  describe('The _establishProject() function', () => {\n    let establish;\n\n    beforeEach(() => {\n      establish = spyOn(Project, 'establish').and.returnValue(project);\n    });\n\n    it('resolves to nothing', done => {\n      cli._establishProject({})\n        .then(project => {\n          expect(project).not.toBeDefined();\n        })\n        .catch(fail).then(done);\n    });\n\n    it('calls and resolves to Project.establish()', done => {\n      fs.mkdirp(path.join(process.cwd(), aureliaProject))\n        .then(() => cli._establishProject({\n          runningLocally: true\n        }))\n        .then(project => {\n          expect(Project.establish)\n            .toHaveBeenCalledWith(cli.ui, path.join(process.cwd()));\n          expect(project).toBe(project);\n        })\n        .catch(fail).then(done);\n    });\n\n    it('does not catch Project.establish()', done => {\n      establish.and.callFake(() => new Promise((resolve, reject) => reject()));\n\n      fs.mkdirp(path.join(process.cwd(), aureliaProject))\n        .then(() => cli._establishProject({\n          runningLocally: true\n        }))\n        .then(() => {\n          fail('expected promise to be rejected.');\n          done();\n        })\n        .catch(done);\n    });\n\n    it(`logs 'No Aurelia project found.'`, done => {\n      spyOn(cli.ui, 'log');\n      cli._establishProject({\n        runningLocally: true\n      }).then(() => {\n        expect(cli.ui.log).toHaveBeenCalledWith('No Aurelia project found.');\n      }).catch(fail).then(done);\n    });\n  });\n\n  describe('The createHelpCommand() function', () => {\n    it('gets the help command', () => {\n      mockfs({\n        'lib/commands/help/command.js': 'module.exports = {}'\n      });\n      spyOn(cli.container, 'get');\n\n      cli.createHelpCommand();\n      expect(cli.container.get)\n        .toHaveBeenCalledWith(require('../../lib/commands/help/command'));\n    });\n  });\n\n  describe('The configureContainer() function', () => {\n    it('registers the instances', () => {\n      const registerInstanceSpy = spyOn(cli.container, 'registerInstance');\n\n      cli.configureContainer();\n\n      expect(registerInstanceSpy.calls.count()).toBe(2);\n    });\n  });\n\n  describe('The run() function', () => {\n    function getVersionSpec(command) {\n      return () => {\n        beforeEach(() => {\n          mockfs({\n            'package.json': '{\"version\": \"1.0.0\"}'\n          })\n          spyOn(cli.ui, 'log')\n            .and.callFake(() => new Promise(resolve => resolve()));\n        });\n\n        it('logs the cli version', () => {\n          cli.run(command);\n          expect(cli.ui.log).toHaveBeenCalledWith('1.0.0');\n        });\n\n        it('returns an empty promise', done => {\n          cli.run(command).then(resolved => {\n            expect(resolved).not.toBeDefined();\n          }).catch(fail).then(done);\n        });\n      };\n    }\n\n    describe('The --version arg', getVersionSpec('--version'));\n\n    describe('The -v arg', getVersionSpec('-v'));\n\n    it('uses the _establishProject() function', done => {\n      // const project = {};\n      spyOn(cli, '_establishProject').and.returnValue(new Promise(resolve => {\n        resolve(project);\n      }));\n      spyOn(cli.container, 'registerInstance');\n      spyOn(cli, 'createCommand').and.returnValue({ execute: () => {} });\n\n      cli.run()\n        .then(() => {\n          expect(cli._establishProject).toHaveBeenCalledWith(cli.options);\n        }).catch(fail).then(done);\n    });\n\n    it('registers the project instance', done => {\n      spyOn(cli, '_establishProject').and.returnValue(new Promise(resolve => {\n        resolve(project);\n      }));\n      spyOn(cli.container, 'registerInstance');\n      spyOn(cli, 'createCommand').and.returnValue({ execute: () => {} });\n\n      cli.run().then(() => {\n        expect(cli.container.registerInstance)\n          .toHaveBeenCalledWith(Project, project);\n      }).catch(fail).then(done);\n    });\n\n    it('creates the command', done => {\n      const command = 'run';\n      const args = {};\n      spyOn(cli, 'createCommand').and.returnValue({ execute: () => {} });\n\n      cli.run(command, args).then(() => {\n        expect(cli.createCommand).toHaveBeenCalledWith(command, args);\n      }).catch(fail).then(done);\n    });\n\n    it('executes the command', done => {\n      const command = {\n        execute: () => {}\n      };\n      const args = {};\n      spyOn(cli, '_establishProject').and.returnValue(new Promise(resolve => \n        resolve(project)\n      ));\n      spyOn(command, 'execute').and.returnValue(new Promise(resolve => resolve({})));\n      spyOn(cli, 'createCommand').and.returnValue(command);\n\n      cli.run('run', args).then(() => {\n        expect(command.execute).toHaveBeenCalledWith(args);\n      }).catch(fail).then(done);\n    });\n  });\n});","/home/travis/build/npmtest/node-npmtest-aurelia-cli/node_modules/aurelia-cli/spec/lib/file-system.spec.js":"\"use strict\";\n\nconst ERROR_CODES = {\n  ENOENT: 'ENOENT',\n  EEXIST: 'EEXIST'\n};\n\ndescribe('The file-system module', () => {\n  let mockfs;\n  let path;\n  let mkdirp;\n  let fs;\n\n  let readDir;\n  let readFile;\n  let writeDir;\n  let writeFile;\n  \n  beforeEach(() => {\n    mockfs = require('mock-fs');\n    path = require('path');\n    mkdirp = require('../../lib/mkdirp');\n    fs = require('../../lib/file-system');\n\n    readDir = 'read';\n    readFile = {\n      name: 'read.js',\n      content: 'content'\n    };\n    readFile.path = path.join(readDir, readFile.name);\n\n    writeDir = 'write';\n    writeFile = {\n      name: 'write.js',\n      content: 'content'\n    };\n    writeFile.path = path.join(writeDir, writeFile.name);\n\n    const config = {};\n    config[readFile.path] = readFile.content;\n\n    mockfs(config);\n  });\n  \n  afterEach(() => {\n    mockfs.restore();\n  });\n\n  describe('The stat() function', () => {\n    it('reads the stats for a directory', done => {\n      fs.stat(readDir).then(stats => {\n        expect(stats).toBeDefined();\n      }).catch(fail).then(done);\n    });\n\n    it('reads the stats for a file', done => {\n      fs.stat(readFile.path).then(stats => {\n        expect(stats).toBeDefined();\n      }).catch(fail).then(done);\n    });\n\n    it('rejects with an ENOENT error on a non-existing directory', done => {\n      fs.stat(writeDir).then(() => {\n        fail('expected promise to be rejected');\n      }).catch(e => {\n        expect(e.code).toBe(ERROR_CODES.ENOENT);\n      }).then(done);\n    });\n\n    it('rejects with an ENOENT error on a non-existing file', done => {\n      fs.stat(writeFile.path).then(() => {\n        fail('expected promise to be rejected');\n      }).catch(e => {\n        expect(e.code).toBe(ERROR_CODES.ENOENT);\n      }).then(done);\n    })\n  });\n\n  describe('The readdir() function', () => {\n    it('reads a directory', done => {\n      fs.readdir(readDir).then(files => {\n        expect(files).toEqual([readFile.name]);\n      }).catch(fail).then(done);\n    });\n\n    it('rejects with ENOENT', done => {\n      fs.readdir(writeDir).then(() => {\n        fail('expected promise to be rejected');\n      }).catch(e => {\n        expect(e.code).toBe(ERROR_CODES.ENOENT);\n      }).then(done);\n    });\n  });\n\n  describe('The mkdir() function', () => {\n    it('makes a directory', done => {\n      fs.mkdir(writeDir)\n        .catch(fail)\n        .then(() => fs.readdir(writeDir))\n        .catch(fail)\n        .then(done);\n    });\n\n    it('rejects with EEXIST', done => {\n      fs.mkdir(readDir)\n        .then(() => fail('expected promise to be rejected'))\n        .catch(e => expect(e.code).toBe(ERROR_CODES.EEXIST))\n        .then(done);\n    });\n  });\n\n  describe('The mkdirp() function', () => {\n    it('makes deep directories', done => {\n      fs.mkdirp(writeDir + readDir).then(() => {\n        return fs.readdir(writeDir + readDir);\n      }).catch(fail).then(done);\n    });\n\n    it('rejects if mkdirp returns an error', done => {\n      pending(`change file-system to mkdirp.mkdirp or more helpers.`);\n    });\n  });\n\n  describe('The readFile() function', () => {\n    it('returns a promise resolving to the files content', done => {\n      fs.readFile(readFile.path).then(content => {\n        expect(content).toBe(readFile.content);\n      }).catch(fail).then(done);\n    });\n\n    it('rejects with ENOENT error', done => {\n      fs.readFile(writeFile.path).then(() => {\n        fail('expected promise to be rejected');\n      }).catch(e => {\n        expect(e.code).toBe(ERROR_CODES.ENOENT);\n        done();\n      });\n    });\n  });\n\n  describe('The readFileSync() function', () => {\n    it('returns the files content', () => {\n      expect(fs.readFileSync(readFile.path))\n        .toBe(readFile.content);\n    });\n\n    it('throws an ENOENT error', () => {\n      try {\n        fs.readFileSync(writeFile.path);\n        fail(`expected fs.readFileSync('${writeFile.path}') to throw`);\n      } catch (e) {\n        expect(e.code).toBe(ERROR_CODES.ENOENT);\n      }\n    });\n  });\n\n  describe('The writeFile() function', () => {\n    it('creates a new file', done => {\n      fs.writeFile(writeFile.path, writeFile.content).then(() => {\n        return fs.readFile(writeFile.path)\n      }).then(content => {\n        expect(content).toBe(writeFile.content);\n        done();\n      });\n    });\n  });\n});\n","/home/travis/build/npmtest/node-npmtest-aurelia-cli/node_modules/aurelia-cli/spec/lib/project-item.spec.js":"'use strict';\n\ndescribe('The project-item module', () => {\n  let mockfs;\n\n  let fs;\n\n  let ProjectItem;\n  let project;\n\n  beforeEach(() => {\n    mockfs = require('mock-fs');\n\n    fs = require('../../lib/file-system');\n\n    ProjectItem = require('../../lib/project-item').ProjectItem;\n\n    mockfs();\n  });\n\n  afterEach(() => {\n    mockfs.restore();\n  });\n\n  describe('The create() function', () => {\n    beforeEach(() => {\n      project = new ProjectItem();\n    });\n\n    describe('isDirectory = true', () => {\n      beforeEach(() => {\n        project.isDirectory = true;\n      });\n\n      it('creates a directory if it is missing', done => {\n        project.name = 'cli-app';\n        project.create()\n          .then(() => fs.readdir(project.name))\n          .then(files => {\n            expect(files).toBeDefined();\n          }).catch(fail).then(done);\n      });\n\n      it('creates the childs', done => {\n        const ui = {};\n        const child = { create: () => { } };\n        project.children.push(child);\n        spyOn(child, 'create');\n\n        project.name = 'cli-app';\n        project.create(ui)\n          .then(() => {\n            expect(child.create).toHaveBeenCalledWith(ui, project.name);\n          })\n          .catch(fail).then(done);\n      });\n    });\n  });\n\n  describe('The _write() function', () => {\n    beforeEach(() => {\n      project = new ProjectItem();\n    });\n    it('creates non-existing files', done => {\n      const file = {\n        path: 'index.html',\n        content: '<html></html>',\n      };\n\n      project._write(file.path, file.content)\n        .then(() => fs.readFile(file.path))\n        .then(content => {\n          expect(content).toBe(file.content);\n        }).catch(fail).then(done);\n    });\n    \n    describe('in `skip` strategy', () => {\n      beforeEach(() => {\n        project._fileExistsStrategy = 'skip';\n      });\n\n      it('does not override an existing file', done => {\n        const file = {\n          path: 'index.html',\n          content: '<html></html>'\n        };\n\n        fs.writeFile(file.path, file.content)\n          .then(() => project._write(file.path, 'evil'))\n          .then(() => fs.readFile(file.path))\n          .then(content => {\n            expect(content).toBe(file.content);\n          }).catch(fail).then(done);\n      });\n    });\n  });\n});","/home/travis/build/npmtest/node-npmtest-aurelia-cli/node_modules/aurelia-cli/spec/lib/project.spec.js":"'use strict';\n\ndescribe('The project module', () => {\n  let mockfs;\n  let path;\n\n  let fs;\n  let ui;\n\n  let Project;\n  let project;\n\n  beforeEach(() => {\n    mockfs = require('mock-fs');\n    path = require('path');\n\n    fs = require('../../lib/file-system');\n    ui = new (require('../../lib/ui').ConsoleUI)();\n\n    Project = require('../../lib/project').Project;\n\n    mockfs();\n    \n    project = new Project(ui, '', {\n      paths: { },\n      transpiler: {\n        fileExtension: '.js'\n      }\n    });\n  });\n\n  afterEach(() => {\n    mockfs.restore();\n  });\n\n  describe('The resolveGenerator() function', () => {\n    it('resolves to teh generators location', done => {\n      fs.writeFile('aurelia_project/generators/test.js', '')\n        .then(() => project.resolveGenerator('test'))\n        .then(location => {\n          expect(location).toBe(path.join('aurelia_project', 'generators', 'test.js'));\n        }).catch(fail).then(done);\n    });\n\n    it('resolves to null', done => {\n      project.resolveGenerator('test')\n        .then(location => {\n          expect(location).toBe(null);\n        }).catch(fail).then(done);\n    });\n  });\n\n  describe('The resolveTask() function', () => {\n    it('resolves to the tasks location', done => {\n      fs.writeFile('aurelia_project/tasks/test.js', '')\n        .then(() => project.resolveTask('test'))\n        .then(location => {\n          expect(location).toBe(path.join('aurelia_project', 'tasks', 'test.js'));\n        }).catch(fail).then(done);\n    });\n\n    it('resolves to null', done => {\n      project.resolveTask('test')\n        .then(location => {\n          expect(location).toBe(null);\n        }).catch(fail).then(done);\n    });\n  });\n});","/home/travis/build/npmtest/node-npmtest-aurelia-cli/node_modules/aurelia-cli/lib/commands/generate/command.js":"'use strict';\nconst UI = require('../../ui').UI;\nconst CLIOptions = require('../../cli-options').CLIOptions;\nconst Container = require('aurelia-dependency-injection').Container;\nconst Project = require('../../project').Project;\nconst string = require('../../string');\nconst os = require('os');\n\nmodule.exports = class {\n  static inject() { return [Container, UI, CLIOptions, Project]; }\n\n  constructor(container, ui, options, project) {\n    this.container = container;\n    this.ui = ui;\n    this.options = options;\n    this.project = project;\n  }\n\n  execute(args) {\n    if (args.length < 1) {\n      return this.displayGeneratorInfo('No Generator Specified. Available Generators:');\n    }\n\n    this.project.installTranspiler();\n\n    return this.project.resolveGenerator(args[0]).then(generatorPath => {\n      Object.assign(this.options, {\n        generatorPath: generatorPath,\n        args: args.slice(1)\n      });\n\n      if (generatorPath) {\n        let generator = this.project.getExport(require(generatorPath));\n\n        if (generator.inject) {\n          generator = this.container.get(generator);\n          generator = generator.execute.bind(generator);\n        }\n\n        return generator();\n      }\n\n      return this.displayGeneratorInfo(`Invalid Generator: ${args[0]}. Available Generators:`);\n    });\n  }\n\n  displayGeneratorInfo(message) {\n    return this.ui.displayLogo()\n      .then(() => this.ui.log(message + os.EOL))\n      .then(() => this.project.getGeneratorMetadata())\n      .then(metadata => string.buildFromMetadata(metadata, this.ui.getWidth()))\n      .then(str => this.ui.log(str));\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-aurelia-cli/node_modules/aurelia-cli/lib/commands/install/package-argument-parser.js":"'use strict';\n\nconst gitRegex = /(?:git|ssh|https?|git@[\\w\\.]+):(?:\\/\\/)?([\\w\\.@:\\/~_-]+)\\.git(?:\\/?|\\#[\\d\\w\\.\\-_]+?)$/;\n\nclass PackageArgumentParser {\n\n  parse(args) {\n    let packages = [];\n    let flag = false;\n\n    for (let i = 0; i < args.length; i++) {\n      let arg = args[i];\n\n      if (flag) {\n        flag = false;\n        continue;\n      }\n\n      // skip arguments starting with - or --\n      if (arg.startsWith('--')) continue;\n      if (arg.match(/^-.$/)) {\n        flag = true;\n        continue;\n      }\n\n      let pkg;\n\n      if (this.isGitUrl(arg)) {\n        pkg = this.parseGitUrl(arg);\n      } else if (this.hasVersion(arg)) {\n        pkg = this.parseVersioned(arg);\n      } else {\n        pkg = {\n          argument: arg,\n          name: arg\n        };\n      }\n      packages.push(pkg);\n    }\n\n    return packages;\n  }\n\n  parseVersioned(argument) {\n    let split = argument.split('@');\n    return {\n      argument: argument,\n      name: split[0],\n      version: split[1]\n    };\n  }\n\n  hasVersion(argument) {\n    return argument.indexOf('@') > -1;\n  }\n\n  isGitUrl(argument) {\n    return argument.match(gitRegex);\n  }\n\n  parseGitUrl(argument) {\n    let matches = argument.match(gitRegex);\n\n    // github.com/aurelia/i18n\n    let segment = matches[1];\n\n    // aurelia/i18n\n    let repo = segment.substring(segment.indexOf('/') + 1);\n\n    // aurelia-i18n\n    let name = repo.replace('/', '-');\n\n    return {\n      argument: argument,\n      name: name\n    };\n  }\n}\n\nmodule.exports = PackageArgumentParser;\n","/home/travis/build/npmtest/node-npmtest-aurelia-cli/node_modules/aurelia-cli/lib/commands/new/project-template.js":"'use strict';\nconst ProjectItem = require('../../project-item').ProjectItem;\nconst NPM = require('../../package-managers/npm').NPM;\nconst path = require('path');\nconst string = require('../../string');\nconst getSupportedVersion = require('../../dependencies').getSupportedVersion;\nconst spawn = require('child_process').spawn;\nconst add = ProjectItem.prototype.add;\n\nexports.ProjectTemplate = class {\n  constructor(model, options) {\n    this.options = options;\n    this.package = {\n      name: string.sluggify(model.name),\n      description: 'An Aurelia client application.',\n      version: '0.1.0',\n      repository: {\n        type: '???',\n        url: '???'\n      },\n      license: 'MIT',\n      dependencies: {},\n      peerDependencies: {},\n      devDependencies: {}\n    };\n\n    this.model = Object.assign({}, model, {\n      paths: {}\n    });\n\n    this.postInstallProcesses = [];\n\n    this.root = options.hasFlag('here')\n      ? ProjectItem.directory(process.cwd())\n      : ProjectItem.directory(model.name);\n\n    this.resources = ProjectItem.directory('resources');\n    this.elements = ProjectItem.directory('elements');\n    this.attributes = ProjectItem.directory('attributes');\n    this.valueConverters = ProjectItem.directory('value-converters');\n    this.bindingBehaviors = ProjectItem.directory('binding-behaviors');\n    this.src = ProjectItem.directory('src').add(\n      this.resources.add(\n        this.elements,\n        this.attributes,\n        this.valueConverters,\n        this.bindingBehaviors\n      )\n    );\n\n    this.unitTests = ProjectItem.directory('unit');\n    this.e2eTests = ProjectItem.directory('e2e');\n    this.tests = ProjectItem.directory('test');\n\n    this.tasks = ProjectItem.directory('tasks');\n    this.generators = ProjectItem.directory('generators');\n    this.environments = ProjectItem.directory('environments');\n\n    this.projectFolder = ProjectItem.directory('aurelia_project').add(\n      this.tasks,\n      this.generators,\n      this.environments,\n      ProjectItem.jsonObject('aurelia.json', this.model)\n    );\n  }\n\n  get name() {\n    return this.package.name;\n  }\n\n  configureVisualStudioStructure() {\n    this.content = this.root;\n\n    this.projectOutput = ProjectItem.directory('wwwroot');\n\n    this.addToContent(\n      this.projectFolder,\n      this.src,\n      this.projectOutput.add(\n        ProjectItem.resource('index.html', 'content/index.html').askUserIfExists(),\n        ProjectItem.resource('favicon.ico', 'img/favicon.ico').skipIfExists()\n      ),\n      ProjectItem.jsonObject('package.json', this.package).mergeIfExists(),\n      ProjectItem.resource('.editorconfig', 'content/editorconfig').skipIfExists(),\n      ProjectItem.resource('.gitignore', 'content/gitignore').skipIfExists()\n    );\n  }\n\n  // If content is always empty (web.js platform invokes this method without parameters) we can remove it. Otherwise shouldn't we add it in the configureVisualStudioStructure too?\n  configureDefaultStructure(content) {\n    this.content = content || this.root;\n    this.projectOutput = this.root;\n\n    this.addToContent(\n      this.projectFolder,\n      this.src,\n      ProjectItem.jsonObject('package.json', this.package),\n      ProjectItem.resource('.editorconfig', 'content/editorconfig'),\n      ProjectItem.resource('.gitignore', 'content/gitignore'),\n      ProjectItem.resource('favicon.ico', 'img/favicon.ico'),\n      ProjectItem.resource('index.html', 'content/index.html')\n    );\n  }\n\n  configureDefaultSetup() {\n    this.scripts = ProjectItem.directory('scripts');\n    this.projectOutput.add(this.scripts);\n\n    this.addToSource(\n      ProjectItem.resource('main.ext', 'src/main.ext', this.model.transpiler),\n      ProjectItem.resource('app.ext', 'src/app.ext', this.model.transpiler),\n      ProjectItem.resource('app.ext', 'src/app.ext', this.model.markupProcessor),\n      ProjectItem.resource('environment.ext', 'environments/dev.js', this.model.transpiler)\n    ).addToResources(\n      ProjectItem.resource('index.ext', 'src/resources/index.ext', this.model.transpiler)\n    ).addToTasks(\n      ProjectItem.resource('build.ext', 'tasks/build.ext', this.model.transpiler),\n      ProjectItem.resource('build.json', 'tasks/build.json'),\n      ProjectItem.resource('copy-files.ext', 'tasks/copy-files.ext', this.model.transpiler),\n      ProjectItem.resource('run.ext', 'tasks/run.ext', this.model.transpiler),\n      ProjectItem.resource('run.json', 'tasks/run.json')\n    ).addToGenerators(\n      ProjectItem.resource('attribute.ext', 'generators/attribute.ext', this.model.transpiler),\n      ProjectItem.resource('attribute.json', 'generators/attribute.json'),\n      ProjectItem.resource('element.ext', 'generators/element.ext', this.model.transpiler),\n      ProjectItem.resource('element.json', 'generators/element.json'),\n      ProjectItem.resource('value-converter.ext', 'generators/value-converter.ext', this.model.transpiler),\n      ProjectItem.resource('value-converter.json', 'generators/value-converter.json'),\n      ProjectItem.resource('binding-behavior.ext', 'generators/binding-behavior.ext', this.model.transpiler),\n      ProjectItem.resource('binding-behavior.json', 'generators/binding-behavior.json'),\n      ProjectItem.resource('task.ext', 'generators/task.ext', this.model.transpiler),\n      ProjectItem.resource('task.json', 'generators/task.json'),\n      ProjectItem.resource('component.ext', 'generators/component.ext', this.model.transpiler),\n      ProjectItem.resource('component.json', 'generators/component.json'),\n      ProjectItem.resource('generator.ext', 'generators/generator.ext', this.model.transpiler),\n      ProjectItem.resource('generator.json', 'generators/generator.json')\n    ).addToEnvironments(\n      ProjectItem.resource('dev.ext', 'environments/dev.js', this.model.transpiler),\n      ProjectItem.resource('stage.ext', 'environments/stage.js', this.model.transpiler),\n      ProjectItem.resource('prod.ext', 'environments/prod.js', this.model.transpiler)\n    ).addToClientDependencies(\n      'aurelia-bootstrapper',\n      'aurelia-animator-css',\n      'bluebird',\n      'requirejs',\n      'text'\n    ).addToDevDependencies(\n      'aurelia-cli',\n      'aurelia-testing',\n      'aurelia-tools',\n      'browser-sync',\n      'connect-history-api-fallback',\n      'gulp',\n      'gulp-changed-in-place',\n      'gulp-plumber',\n      'gulp-rename',\n      'gulp-sourcemaps',\n      'gulp-notify',\n      'minimatch',\n      'through2',\n      'uglify-js',\n      'vinyl-fs'\n    );\n  }\n\n  addPostInstallProcess(config) {\n    this.postInstallProcesses.push(config);\n    return this;\n  }\n\n  addToRoot() {\n    add.apply(this.root, arguments);\n    return this;\n  }\n\n  addToContent() {\n    add.apply(this.content, arguments);\n    return this;\n  }\n\n  addToSource() {\n    add.apply(this.src, arguments);\n    return this;\n  }\n\n  addToResources() {\n    add.apply(this.resources, arguments);\n    return this;\n  }\n\n  addToTests() {\n    add.apply(this.tests, arguments);\n    return this;\n  }\n\n  addToUnitTests() {\n    add.apply(this.unitTests, arguments);\n    return this;\n  }\n\n  addToE2ETests() {\n    add.apply(this.e2eTests, arguments);\n    return this;\n  }\n\n  addToScripts() {\n    add.apply(this.scripts, arguments);\n    return this;\n  }\n\n  addToTasks() {\n    add.apply(this.tasks, arguments);\n    return this;\n  }\n\n  addToGenerators() {\n    add.apply(this.generators, arguments);\n    return this;\n  }\n\n  addToEnvironments() {\n    add.apply(this.environments, arguments);\n    return this;\n  }\n\n  addToClientDependencies() {\n    addDependencies(this.package.dependencies, arguments);\n    return this;\n  }\n\n  addToDevDependencies() {\n    addDependencies(this.package.devDependencies, arguments);\n    return this;\n  }\n\n  addToDependencies() {\n    addDependencies(this.package.dependencies, arguments);\n    return this;\n  }\n\n  addToPeerDependencies() {\n    addDependencies(this.package.peerDependencies, arguments);\n    return this;\n  }\n\n  create(ui, location) {\n    let appRoot = this.src.calculateRelativePath(this.root);\n\n    this.model.paths = Object.assign(this.model.paths, {\n      root: appRoot,\n      resources: this.resources.calculateRelativePath(this.src),\n      elements: this.elements.calculateRelativePath(this.src),\n      attributes: this.attributes.calculateRelativePath(this.src),\n      valueConverters: this.valueConverters.calculateRelativePath(this.src),\n      bindingBehaviors: this.bindingBehaviors.calculateRelativePath(this.src)\n    });\n\n    this.model.transpiler.source = path.posix.join(appRoot, '**/*' + this.model.transpiler.fileExtension);\n    this.model.markupProcessor.source = path.posix.join(appRoot, '**/*' + this.model.markupProcessor.fileExtension);\n    this.model.cssProcessor.source = path.posix.join(appRoot, '**/*' + this.model.cssProcessor.fileExtension);\n    this.model.platform.output = this.scripts.calculateRelativePath(this.root);\n    this.model.platform.index = path.posix.join(this.projectOutput.calculateRelativePath(this.root), 'index.html');\n    this.model.platform.baseDir = '.';\n\n    if (this.model.platform.id === 'aspnetcore') {\n      this.model.platform.baseUrl = this.scripts.calculateRelativePath(this.projectOutput);\n      this.model.platform.baseDir = './wwwroot';\n    }\n\n    if (this.unitTests.parent) {\n      this.model.unitTestRunner.source = path.posix.join(\n        this.unitTests.calculateRelativePath(this.root),\n        '**/*' + this.model.transpiler.fileExtension\n      );\n    }\n\n    this.model.build = {\n      'targets': [\n        this.model.platform\n      ],\n      'loader': {\n        'type': 'require',\n        'configTarget': 'vendor-bundle.js',\n        'includeBundleMetadataInConfig': 'auto',\n        'plugins': [\n          { 'name': 'text', 'extensions': ['.html', '.css'], 'stub': true }\n        ]\n      },\n      'options': {\n        'minify': 'stage & prod',\n        'sourcemaps': 'dev & stage'\n      },\n      'bundles': [\n        {\n          'name': 'app-bundle.js',\n          'source': [\n            '[**/*.js]',\n            '**/*.{css,html}'\n          ]\n        },\n        {\n          'name': 'vendor-bundle.js',\n          'prepend': [\n            'node_modules/bluebird/js/browser/bluebird.core.js',\n            'node_modules/aurelia-cli/lib/resources/scripts/configure-bluebird.js',\n            'node_modules/requirejs/require.js'\n          ],\n          'dependencies': [\n            'aurelia-binding',\n            'aurelia-bootstrapper',\n            'aurelia-dependency-injection',\n            'aurelia-event-aggregator',\n            'aurelia-framework',\n            'aurelia-history',\n            'aurelia-history-browser',\n            'aurelia-loader',\n            'aurelia-loader-default',\n            'aurelia-logging',\n            'aurelia-logging-console',\n            'aurelia-metadata',\n            'aurelia-pal',\n            'aurelia-pal-browser',\n            'aurelia-path',\n            'aurelia-polyfills',\n            'aurelia-route-recognizer',\n            'aurelia-router',\n            'aurelia-task-queue',\n            'aurelia-templating',\n            'aurelia-templating-binding',\n            'text',\n            {\n              'name': 'aurelia-templating-resources',\n              'path': '../node_modules/aurelia-templating-resources/dist/amd',\n              'main': 'aurelia-templating-resources'\n            },\n            {\n              'name': 'aurelia-templating-router',\n              'path': '../node_modules/aurelia-templating-router/dist/amd',\n              'main': 'aurelia-templating-router'\n            },\n            {\n              'name': 'aurelia-testing',\n              'path': '../node_modules/aurelia-testing/dist/amd',\n              'main': 'aurelia-testing',\n              'env': 'dev'\n            }\n          ]\n        }\n      ]\n    };\n\n    return this.root.create(ui, location);\n  }\n\n  install(ui) {\n    let workingDirectory = this.options.hasFlag('here')\n      ? process.cwd()\n      : path.posix.join(process.cwd(), this.content.calculateRelativePath());\n\n    return installDependencies(ui, workingDirectory)\n      .then(() => runPostInstallProcesses(ui, workingDirectory, this.postInstallProcesses));\n  }\n};\n\nfunction installDependencies(ui, workingDirectory, dependencies) {\n  let npm = new NPM();\n  let npmOptions = {\n    loglevel: 'error',\n    color: 'always',\n    save: true,\n    'save-dev': true,\n    workingDirectory: workingDirectory\n  };\n\n  return npm.install([], npmOptions);\n}\n\nfunction addDependencies(current, toAdd) {\n  for (let i = 0, ii = toAdd.length; i < ii; ++i) {\n    let name = toAdd[i];\n\n    if (name in current) {\n      return;\n    }\n\n    current[name] = getSupportedVersion(name).replace('\\\"', '').replace('\\\"', '');\n  }\n}\n\nfunction runPostInstallProcesses(ui, cwd, scripts) {\n  let i = -1;\n\n  function run() {\n    i++;\n\n    if (i < scripts.length) {\n      return runPostInstall(ui, cwd, scripts[i]).then(run);\n    }\n\n    return Promise.resolve();\n  }\n\n  return run();\n}\n\nfunction runPostInstall(ui, cwd, config) {\n  return ui.log(config.description)\n    .then(() => {\n      return new Promise((resolve, reject) => {\n        const p = spawn(config.command, config.args, { cwd: cwd });\n        p.stdout.on('data', data => ui.log(data.toString()));\n        p.stderr.on('data', data => reject(data.toString()));\n        p.on('close', resolve);\n      });\n    });\n}\n","/home/travis/build/npmtest/node-npmtest-aurelia-cli/node_modules/aurelia-cli/lib/package-managers/npm.js":"'use strict';\n\nlet isLoaded = false;\n\nexports.NPM = class {\n  install(packages, npmOptions) {\n    npmOptions = npmOptions || {};\n    const npm = require('npm');\n\n    let originalWorkingDirectory = process.cwd();\n    process.chdir(npmOptions.workingDirectory || process.cwd());\n\n    return load(npm, npmOptions)\n      .then(() => {\n        return new Promise((resolve, reject) => {\n          npm.commands.install(packages, error => {\n            process.chdir(originalWorkingDirectory);\n\n            if (error) reject(error);\n            else resolve();\n          });\n        });\n      }).catch(error => {\n        process.chdir(originalWorkingDirectory);\n        throw error;\n      });\n  }\n};\n\nexports.default = exports.NPM;\n\nfunction load(npm, npmOptions) {\n  if (isLoaded) {\n    for (let key in npmOptions) {\n      npm.config.set(key, npmOptions[key]);\n    }\n\n    return Promise.resolve();\n  }\n\n  return new Promise((resolve, reject) => {\n    npm.load(npmOptions, error => {\n      if (error) reject(error);\n      else {\n        isLoaded = true;\n        resolve();\n      }\n    });\n  });\n}\n","/home/travis/build/npmtest/node-npmtest-aurelia-cli/node_modules/aurelia-cli/lib/importer/strategies/amodro.js":"'use strict';\n\nconst fs = require('../../file-system');\nconst logger = require('aurelia-logging').getLogger('Amodro');\nconst path = require('path');\nconst amodroTrace = require('../../build/amodro-trace');\nconst cjsTransform = require('../../build/amodro-trace/read/cjs');\n\nlet AmodroStrategy = class {\n\n  static inject() { return ['package']; }\n\n  constructor(pkg) {\n    this.package = pkg;\n  }\n\n  applies() {\n    if (!this.package.main) {\n      logger.debug('This package did not specify a \"main\" file in package.json. Skipping');\n      return false;\n    }\n\n    return true;\n  }\n\n  execute() {\n    this.moduleId = this.package.getModuleId(this.package.main);\n\n    return this.trace(this.package.name, this.moduleId)\n    .then(tracedFiles => {\n      logger.debug(`The package has ${tracedFiles} dependency file(s).`);\n\n      if (tracedFiles === 0) {\n        throw new Error(`Could not trace '${this.package.main}' of the '${this.package.name}' package. There were 0 traced files`);\n      }\n\n      return this.package.detectResources()\n      .then(() => {\n        if (tracedFiles > 1 || this.package.resources.length > 0) {\n          logger.debug('Using multi file configuration for this package.');\n        } else {\n          logger.debug('Using single file configuration for this package.');\n          this.package.main = null;\n          this.package.path = path.posix.join('../node_modules/', this.package.name, this.moduleId);\n        }\n      });\n    })\n    .then(() => {\n      return {\n        dependencies: [this.package.getConfiguration()]\n      };\n    });\n  }\n\n  trace(packageName, moduleId) {\n    let rootDir = path.join(process.cwd(), 'node_modules', packageName);\n\n    let existingFilesMap = {};\n\n    return amodroTrace(\n      {\n        rootDir: rootDir,\n        id: moduleId,\n        fileRead: function(defaultRead, id, filePath) {\n          if (fs.existsSync(filePath)) {\n            existingFilesMap[filePath] = true;\n            let contents = fs.readFileSync(filePath).toString();\n\n            return contents;\n          }\n\n          existingFilesMap[filePath] = false;\n\n          return '';\n        },\n        readTransform: function(id, url, contents) {\n          return cjsTransform(url, contents);\n        }\n      }\n    ).then(traceResult => {\n      let traced = traceResult.traced;\n      let found = traced.filter(x => existingFilesMap[x.path]);\n\n      return found.length;\n    });\n  }\n\n  get name() {\n    return 'Amodrotrace Strategy';\n  }\n};\n\nmodule.exports = AmodroStrategy;\n","/home/travis/build/npmtest/node-npmtest-aurelia-cli/node_modules/aurelia-cli/lib/importer/strategies/aurelia-registry.js":"'use strict';\n\nconst semver = require('semver');\nconst logger = require('aurelia-logging').getLogger('Registry');\n\nlet AureliaRegistryStrategy = class {\n\n  static inject() { return ['package', 'registry']; }\n\n  constructor(pkg, registry) {\n    this.package = pkg;\n    this.registry = registry;\n  }\n\n  applies() {\n    let version = semver.clean(this.package.version);\n\n    return this.registry.getPackageConfig(this.package, version)\n    .then(config => {\n      if (config) {\n        this.config = config;\n        return this.isUsableConfig(config);\n      }\n\n      logger.debug(`The registry does not contain a package configuration for ${this.package.name}`);\n      return false;\n    });\n  }\n\n  execute() {\n    return this.config;\n  }\n\n  isUsableConfig(c) {\n    let props = ['patches', 'dependencies', 'bundles', 'tasks', 'scripts'];\n    return Object.keys(c).some(key => props.includes(key));\n  }\n\n  get name() {\n    return 'Registry Strategy';\n  }\n};\n\nmodule.exports = AureliaRegistryStrategy;\n","/home/travis/build/npmtest/node-npmtest-aurelia-cli/node_modules/aurelia-cli/lib/importer/strategies/browser-section.js":"'use strict';\n\nconst logger = require('aurelia-logging').getLogger('Browser');\n\nlet BrowserSectionStrategy = class {\n\n  static inject() { return ['package']; }\n\n  constructor(pkg) {\n    this.package = pkg;\n  }\n\n  applies() {\n    if (!this.hasBrowserSection(this.package.packageJSON)) {\n      logger.debug(`There is no (usable) \"browser\" section in the package.json file of the plugin (looked in '${this.package.packageJSONPath}')`);\n      return false;\n    }\n\n    return true;\n  }\n\n  execute() {\n    let browser = this.package.packageJSON.browser;\n    this.package.main = this.package.getModuleId(browser);\n\n    return this.package.detectResources()\n    .then(() => {\n      return {\n        dependencies: [this.package.getConfiguration()]\n      };\n    });\n  }\n\n  hasBrowserSection(packageJSON) {\n    return packageJSON.browser && typeof packageJSON.browser === 'string';\n  }\n\n  get name() {\n    return 'Browser Section Strategy';\n  }\n};\n\nmodule.exports = BrowserSectionStrategy;\n","/home/travis/build/npmtest/node-npmtest-aurelia-cli/node_modules/aurelia-cli/lib/importer/strategies/custom-importer.js":"'use strict';\n\nconst fs = require('../../file-system');\nconst Container = require('aurelia-dependency-injection').Container;\nconst logger = require('aurelia-logging').getLogger('Custom-importer');\n\nlet CustomImporterStrategy = class {\n\n  static inject() { return [Container, 'package']; }\n\n  constructor(container, pkg) {\n    this.container = container;\n    this.package = pkg;\n  }\n\n  applies() {\n    let location = this.getStrategyLocation();\n\n    return fs.exists(location)\n    .then(available => {\n      if (available) {\n        let strategy = this.getStrategy();\n        let result = strategy.applies();\n\n        return result;\n      }\n\n      logger.debug(`The plugin does not have a custom importer module. Looked for \"${location}\"`);\n\n      return false;\n    });\n  }\n\n  execute() {\n    let strategy = this.getStrategy();\n    let result = strategy.execute();\n\n    return result;\n  }\n\n  getStrategy() {\n    let ctor = require(this.getStrategyLocation());\n    return this.container.get(ctor);\n  }\n\n  getStrategyLocation() {\n    let pjson = this.package.packageJSON;\n\n    if (pjson.aurelia && (typeof pjson.aurelia.import === 'string')) {\n      return fs.resolve(fs.join(this.package.rootPath, pjson.aurelia.import));\n    }\n\n    return fs.resolve(fs.join(this.package.rootPath, 'install', 'importer-callbacks.js'));\n  }\n\n  get name() {\n    return 'Custom Importer Strategy';\n  }\n};\n\nmodule.exports = CustomImporterStrategy;\n","/home/travis/build/npmtest/node-npmtest-aurelia-cli/node_modules/aurelia-cli/lib/importer/strategies/jspm-section.js":"'use strict';\n\nconst logger = require('aurelia-logging').getLogger('JSPM');\nconst path = require('path');\n\nlet JSPMSectionStrategy = class {\n\n  static inject() { return ['package']; }\n\n  constructor(pkg) {\n    this.package = pkg;\n  }\n\n  applies() {\n    if (!this.hasJSPMConfig(this.package.packageJSON)) {\n      logger.debug(`There is no \"jspm\" section in the package.json file of the plugin (looked in '${this.package.packageJSONPath}')`);\n      return false;\n    }\n\n    return true;\n  }\n\n  execute() {\n    let jspm = this.package.packageJSON.jspm;\n    let main = jspm.main || this.package.packageJSON.main;\n    let directories = jspm.directories;\n    let distFolder = '';\n\n    if (directories) {\n      distFolder = directories.dist || directories.lib;\n    }\n\n    this.package.path = path.posix.join('../node_modules/', this.package.name, distFolder);\n    this.package.main = main;\n\n    if (jspm.shim && jspm.shim[main]) {\n      let shim = jspm.shim[main];\n      this.package.deps = shim.deps;\n      this.package.exports = shim.exports;\n    }\n\n    return this.package.detectResources()\n    .then(() => {\n      return {\n        dependencies: [this.package.getConfiguration()]\n      };\n    });\n  }\n\n  hasJSPMConfig(packageJSON) {\n    return packageJSON.jspm;\n  }\n\n  get name() {\n    return 'JSPM Section Strategy';\n  }\n};\n\nmodule.exports = JSPMSectionStrategy;\n","/home/travis/build/npmtest/node-npmtest-aurelia-cli/node_modules/aurelia-cli/lib/importer/strategies/metadata.js":"'use strict';\n\nconst logger = require('aurelia-logging').getLogger('Metadata');\n\nlet MetadataStrategy = class {\n\n  static inject() { return ['package']; }\n\n  constructor(pkg) {\n    this.package = pkg;\n  }\n\n  applies() {\n    if (!this.hasMetadata(this.package.packageJSON)) {\n      logger.debug(`There is no \"aurelia\".\"import\" section in the package.json file of the plugin (looked in \"${this.package.packageJSONPath}\")`);\n      return false;\n    }\n\n    return true;\n  }\n\n  execute() {\n    let metadata = this.getMetadata(this.package.packageJSON);\n\n    return metadata;\n  }\n\n  getMetadata(packageJSON) {\n    return packageJSON.aurelia.import;\n  }\n\n  hasMetadata(packageJSON) {\n    return packageJSON.aurelia !== undefined &&\n           packageJSON.aurelia.import !== undefined &&\n           typeof packageJSON.aurelia.import === 'object';\n  }\n\n  get name() {\n    return 'Metadata Strategy';\n  }\n};\n\nmodule.exports = MetadataStrategy;\n","/home/travis/build/npmtest/node-npmtest-aurelia-cli/node_modules/aurelia-cli/lib/resources/content/karma.conf.js":"'use strict';\nconst path = require('path');\nconst project = require('./aurelia_project/aurelia.json');\n\nlet testSrc = [\n  { pattern: project.unitTestRunner.source, included: false },\n  'test/aurelia-karma.js'\n];\n\nlet output = project.platform.output;\nlet appSrc = project.build.bundles.map(x => path.join(output, x.name));\nlet entryIndex = appSrc.indexOf(path.join(output, project.build.loader.configTarget));\nlet entryBundle = appSrc.splice(entryIndex, 1)[0];\nlet files = [entryBundle].concat(testSrc).concat(appSrc);\n\nmodule.exports = function(config) {\n  config.set({\n    basePath: '',\n    frameworks: [project.testFramework.id],\n    files: files,\n    exclude: [],\n    preprocessors: {\n      [project.unitTestRunner.source]: [project.transpiler.id]\n    },\n    'babelPreprocessor': { options: project.transpiler.options },\n    reporters: ['progress'],\n    port: 9876,\n    colors: true,\n    logLevel: config.LOG_INFO,\n    autoWatch: true,\n    browsers: ['Chrome'],\n    singleRun: false,\n    // client.args must be a array of string.\n    // Leave 'aurelia-root', project.paths.root in this order so we can find\n    // the root of the aurelia project.\n    client: {\n      args: ['aurelia-root', project.paths.root]\n    }\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-aurelia-cli/node_modules/aurelia-cli/lib/resources/environments/dev.js":"export default {\n  debug: true,\n  testing: true\n};\n","/home/travis/build/npmtest/node-npmtest-aurelia-cli/node_modules/aurelia-cli/lib/resources/environments/prod.js":"export default {\n  debug: false,\n  testing: false\n};\n","/home/travis/build/npmtest/node-npmtest-aurelia-cli/node_modules/aurelia-cli/lib/resources/environments/stage.js":"export default {\n  debug: true,\n  testing: false\n};\n","/home/travis/build/npmtest/node-npmtest-aurelia-cli/node_modules/aurelia-cli/lib/resources/generators/attribute.js":"import {inject} from 'aurelia-dependency-injection';\nimport {Project, ProjectItem, CLIOptions, UI} from 'aurelia-cli';\n\n@inject(Project, CLIOptions, UI)\nexport default class AttributeGenerator {\n  constructor(project, options, ui) {\n    this.project = project;\n    this.options = options;\n    this.ui = ui;\n  }\n\n  execute() {\n    return this.ui\n      .ensureAnswer(this.options.args[0], 'What would you like to call the custom attribute?')\n      .then(name => {\n        let fileName = this.project.makeFileName(name);\n        let className = this.project.makeClassName(name);\n\n        this.project.attributes.add(\n          ProjectItem.text(`${fileName}.js`, this.generateSource(className))\n        );\n\n        return this.project.commitChanges()\n          .then(() => this.ui.log(`Created ${fileName}.`));\n      });\n  }\n\n  generateSource(className) {\n    return `import {inject} from 'aurelia-framework';\n\n@inject(Element)\nexport class ${className}CustomAttribute {\n  constructor(element) {\n    this.element = element;\n  }\n\n  valueChanged(newValue, oldValue) {\n\n  }\n}\n\n`;\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-aurelia-cli/node_modules/aurelia-cli/lib/resources/generators/binding-behavior.js":"import {inject} from 'aurelia-dependency-injection';\nimport {Project, ProjectItem, CLIOptions, UI} from 'aurelia-cli';\n\n@inject(Project, CLIOptions, UI)\nexport default class BindingBehaviorGenerator {\n  constructor(project, options, ui) {\n    this.project = project;\n    this.options = options;\n    this.ui = ui;\n  }\n\n  execute() {\n    return this.ui\n      .ensureAnswer(this.options.args[0], 'What would you like to call the binding behavior?')\n      .then(name => {\n        let fileName = this.project.makeFileName(name);\n        let className = this.project.makeClassName(name);\n\n        this.project.bindingBehaviors.add(\n          ProjectItem.text(`${fileName}.js`, this.generateSource(className))\n        );\n\n        return this.project.commitChanges()\n          .then(() => this.ui.log(`Created ${fileName}.`));\n      });\n  }\n\n  generateSource(className) {\n    return `export class ${className}BindingBehavior {\n  bind(binding, source) {\n\n  }\n\n  unbind(binding, source) {\n\n  }\n}\n\n`\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-aurelia-cli/node_modules/aurelia-cli/lib/resources/generators/component.js":"import { inject } from 'aurelia-dependency-injection';\nimport { Project, ProjectItem, CLIOptions, UI } from 'aurelia-cli';\n\nvar path = require('path');\n\n@inject(Project, CLIOptions, UI)\nexport default class ElementGenerator {\n  constructor(project, options, ui) { \n    this.project = project;\n    this.options = options;\n    this.ui = ui;\n  }\n\n  execute() {\n    let self = this;\n\n    return this.ui\n      .ensureAnswer(this.options.args[0], 'What would you like to call the component?')\n      .then(name => {\n\n        return self.ui.ensureAnswer(this.options.args[1], 'What sub-folder would you like to add it to?\\nIf it doesn\\'t exist it will be created for you.\\n\\nDefault folder is the source folder (src).', \".\")\n          .then(subFolders => {\n\n            let fileName = this.project.makeFileName(name);\n            let className = this.project.makeClassName(name);\n\n            self.project.root.add(\n              ProjectItem.text(path.join(subFolders, fileName + \".js\"), this.generateJSSource(className)),\n              ProjectItem.text(path.join(subFolders, fileName + \".html\"), this.generateHTMLSource(className))\n            );\n\n            return this.project.commitChanges()\n              .then(() => this.ui.log(`Created ${name} in the '${path.join(self.project.root.name, subFolders)}' folder`));\n          });\n      });\n  }\n\n  generateJSSource(className) {\n    return `export class ${className} {     \n  constructor() {\n    this.message = 'Hello world';\n  }\n}`\n  }\n\n  generateHTMLSource(className) {\n    return `<template>\n  <h1>\\${message}</h1>\n</template>`\n  }\n}","/home/travis/build/npmtest/node-npmtest-aurelia-cli/node_modules/aurelia-cli/lib/resources/generators/element.js":"import {inject} from 'aurelia-dependency-injection';\nimport {Project, ProjectItem, CLIOptions, UI} from 'aurelia-cli';\n\n@inject(Project, CLIOptions, UI)\nexport default class ElementGenerator {\n  constructor(project, options, ui) {\n    this.project = project;\n    this.options = options;\n    this.ui = ui;\n  }\n\n  execute() {\n    return this.ui\n      .ensureAnswer(this.options.args[0], 'What would you like to call the custom element?')\n      .then(name => {\n        let fileName = this.project.makeFileName(name);\n        let className = this.project.makeClassName(name);\n\n        this.project.elements.add(\n          ProjectItem.text(`${fileName}.js`, this.generateJSSource(className)),\n          ProjectItem.text(`${fileName}.html`, this.generateHTMLSource(className))\n        );\n\n        return this.project.commitChanges()\n          .then(() => this.ui.log(`Created ${fileName}.`));\n      });\n  }\n\n  generateJSSource(className) {\n    return `import {bindable} from 'aurelia-framework';\n\nexport class ${className} {\n  @bindable value;\n\n  valueChanged(newValue, oldValue) {\n\n  }\n}\n\n`;\n  }\n\n  generateHTMLSource(className) {\n    return `<template>\n  <h1>\\${value}</h1>\n</template>`;\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-aurelia-cli/node_modules/aurelia-cli/lib/resources/generators/generator.js":"import {inject} from 'aurelia-dependency-injection';\nimport {Project, ProjectItem, CLIOptions, UI} from 'aurelia-cli';\n\n@inject(Project, CLIOptions, UI)\nexport default class GeneratorGenerator {\n  constructor(project, options, ui) {\n    this.project = project;\n    this.options = options;\n    this.ui = ui;\n  }\n\n  execute() {\n    return this.ui\n      .ensureAnswer(this.options.args[0], 'What would you like to call the generator?')\n      .then(name => {\n        let fileName = this.project.makeFileName(name);\n        let className = this.project.makeClassName(name);\n\n        this.project.generators.add(\n          ProjectItem.text(`${fileName}.js`, this.generateSource(className))\n        );\n\n        return this.project.commitChanges()\n          .then(() => this.ui.log(`Created ${fileName}.`));\n      });\n  }\n\n  generateSource(className) {\n    return `import {inject} from 'aurelia-dependency-injection';\nimport {Project, ProjectItem, CLIOptions, UI} from 'aurelia-cli';\n\n@inject(Project, CLIOptions, UI)\nexport default class ${className}Generator {\n  constructor(project, options, ui) {\n    this.project = project;\n    this.options = options;\n    this.ui = ui;\n  }\n\n  execute() {\n    return this.ui\n      .ensureAnswer(this.options.args[0], 'What would you like to call the new item?')\n      .then(name => {\n        let fileName = this.project.makeFileName(name);\n        let className = this.project.makeClassName(name);\n\n        this.project.elements.add(\n          ProjectItem.text(\\`\\${fileName}.js\\`, this.generateSource(className))\n        );\n\n        return this.project.commitChanges()\n          .then(() => this.ui.log(\\`Created \\${fileName}.\\`));\n      });\n  }\n\n  generateSource(className) {\nreturn \\`import {bindable} from 'aurelia-framework';\n\nexport class \\${className} {\n  @bindable value;\n\n  valueChanged(newValue, oldValue) {\n\n  }\n}\n\n\\`\n  }\n}\n\n`;\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-aurelia-cli/node_modules/aurelia-cli/lib/resources/generators/task.js":"import {inject} from 'aurelia-dependency-injection';\nimport {Project, ProjectItem, CLIOptions, UI} from 'aurelia-cli';\n\n@inject(Project, CLIOptions, UI)\nexport default class TaskGenerator {\n  constructor(project, options, ui) {\n    this.project = project;\n    this.options = options;\n    this.ui = ui;\n  }\n\n  execute() {\n    return this.ui\n      .ensureAnswer(this.options.args[0], 'What would you like to call the task?')\n      .then(name => {\n        let fileName = this.project.makeFileName(name);\n        let functionName = this.project.makeFunctionName(name);\n\n        this.project.tasks.add(\n          ProjectItem.text(`${fileName}.js`, this.generateSource(functionName))\n        );\n\n        return this.project.commitChanges()\n          .then(() => this.ui.log(`Created ${fileName}.`));\n      });\n  }\n\n  generateSource(functionName) {\n    return `import gulp from 'gulp';\nimport changed from 'gulp-changed';\nimport project from '../aurelia.json';\n\nexport default function ${functionName}() {\n  return gulp.src(project.paths.???)\n    .pipe(changed(project.paths.output, {extension: '.???'}))\n    .pipe(gulp.dest(project.paths.output));\n}\n\n`;\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-aurelia-cli/node_modules/aurelia-cli/lib/resources/generators/value-converter.js":"import {inject} from 'aurelia-dependency-injection';\nimport {Project, ProjectItem, CLIOptions, UI} from 'aurelia-cli';\n\n@inject(Project, CLIOptions, UI)\nexport default class ValueConverterGenerator {\n  constructor(project, options, ui) {\n    this.project = project;\n    this.options = options;\n    this.ui = ui;\n  }\n\n  execute() {\n    return this.ui\n      .ensureAnswer(this.options.args[0], 'What would you like to call the value converter?')\n      .then(name => {\n        let fileName = this.project.makeFileName(name);\n        let className = this.project.makeClassName(name);\n\n        this.project.valueConverters.add(\n          ProjectItem.text(`${fileName}.js`, this.generateSource(className))\n        );\n\n        return this.project.commitChanges()\n          .then(() => this.ui.log(`Created ${fileName}.`));\n      });\n  }\n\n  generateSource(className) {\n    return `export class ${className}ValueConverter {\n  toView(value) {\n\n  }\n\n  fromView(value) {\n\n  }\n}\n\n`;\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-aurelia-cli/node_modules/aurelia-cli/lib/resources/scripts/configure-bluebird.js":"//Configure Bluebird Promises.\nPromise.config({\n  warnings: {\n    wForgottenReturn: false\n  }\n});\n","/home/travis/build/npmtest/node-npmtest-aurelia-cli/node_modules/aurelia-cli/lib/resources/scripts/require.js":"/*\n RequireJS 2.2.0 Copyright jQuery Foundation and other contributors.\n Released under MIT license, http://github.com/requirejs/requirejs/LICENSE\n*/\nvar requirejs,require,define;\n(function(ga){function ka(b,c,d,g){return g||\"\"}function K(b){return\"[object Function]\"===Q.call(b)}function L(b){return\"[object Array]\"===Q.call(b)}function y(b,c){if(b){var d;for(d=0;d<b.length&&(!b[d]||!c(b[d],d,b));d+=1);}}function X(b,c){if(b){var d;for(d=b.length-1;-1<d&&(!b[d]||!c(b[d],d,b));--d);}}function x(b,c){return la.call(b,c)}function e(b,c){return x(b,c)&&b[c]}function D(b,c){for(var d in b)if(x(b,d)&&c(b[d],d))break}function Y(b,c,d,g){c&&D(c,function(c,e){if(d||!x(b,e))!g||\"object\"!==\ntypeof c||!c||L(c)||K(c)||c instanceof RegExp?b[e]=c:(b[e]||(b[e]={}),Y(b[e],c,d,g))});return b}function z(b,c){return function(){return c.apply(b,arguments)}}function ha(b){throw b;}function ia(b){if(!b)return b;var c=ga;y(b.split(\".\"),function(b){c=c[b]});return c}function F(b,c,d,g){c=Error(c+\"\\nhttp://requirejs.org/docs/errors.html#\"+b);c.requireType=b;c.requireModules=g;d&&(c.originalError=d);return c}function ma(b){function c(a,n,b){var h,k,f,c,d,l,g,r;n=n&&n.split(\"/\");var q=p.map,m=q&&q[\"*\"];\nif(a){a=a.split(\"/\");k=a.length-1;p.nodeIdCompat&&U.test(a[k])&&(a[k]=a[k].replace(U,\"\"));\".\"===a[0].charAt(0)&&n&&(k=n.slice(0,n.length-1),a=k.concat(a));k=a;for(f=0;f<k.length;f++)c=k[f],\".\"===c?(k.splice(f,1),--f):\"..\"===c&&0!==f&&(1!==f||\"..\"!==k[2])&&\"..\"!==k[f-1]&&0<f&&(k.splice(f-1,2),f-=2);a=a.join(\"/\")}if(b&&q&&(n||m)){k=a.split(\"/\");f=k.length;a:for(;0<f;--f){d=k.slice(0,f).join(\"/\");if(n)for(c=n.length;0<c;--c)if(b=e(q,n.slice(0,c).join(\"/\")))if(b=e(b,d)){h=b;l=f;break a}!g&&m&&e(m,d)&&\n(g=e(m,d),r=f)}!h&&g&&(h=g,l=r);h&&(k.splice(0,l,h),a=k.join(\"/\"))}return(h=e(p.pkgs,a))?h:a}function d(a){E&&y(document.getElementsByTagName(\"script\"),function(n){if(n.getAttribute(\"data-requiremodule\")===a&&n.getAttribute(\"data-requirecontext\")===l.contextName)return n.parentNode.removeChild(n),!0})}function m(a){var n=e(p.paths,a);if(n&&L(n)&&1<n.length)return n.shift(),l.require.undef(a),l.makeRequire(null,{skipMap:!0})([a]),!0}function r(a){var n,b=a?a.indexOf(\"!\"):-1;-1<b&&(n=a.substring(0,\nb),a=a.substring(b+1,a.length));return[n,a]}function q(a,n,b,h){var k,f,d=null,g=n?n.name:null,p=a,q=!0,m=\"\";a||(q=!1,a=\"_@r\"+(Q+=1));a=r(a);d=a[0];a=a[1];d&&(d=c(d,g,h),f=e(v,d));a&&(d?m=f&&f.normalize?f.normalize(a,function(a){return c(a,g,h)}):-1===a.indexOf(\"!\")?c(a,g,h):a:(m=c(a,g,h),a=r(m),d=a[0],m=a[1],b=!0,k=l.nameToUrl(m)));b=!d||f||b?\"\":\"_unnormalized\"+(T+=1);return{prefix:d,name:m,parentMap:n,unnormalized:!!b,url:k,originalName:p,isDefine:q,id:(d?d+\"!\"+m:m)+b}}function u(a){var b=a.id,\nc=e(t,b);c||(c=t[b]=new l.Module(a));return c}function w(a,b,c){var h=a.id,k=e(t,h);if(!x(v,h)||k&&!k.defineEmitComplete)if(k=u(a),k.error&&\"error\"===b)c(k.error);else k.on(b,c);else\"defined\"===b&&c(v[h])}function A(a,b){var c=a.requireModules,h=!1;if(b)b(a);else if(y(c,function(b){if(b=e(t,b))b.error=a,b.events.error&&(h=!0,b.emit(\"error\",a))}),!h)g.onError(a)}function B(){V.length&&(y(V,function(a){var b=a[0];\"string\"===typeof b&&(l.defQueueMap[b]=!0);G.push(a)}),V=[])}function C(a){delete t[a];\ndelete Z[a]}function J(a,b,c){var h=a.map.id;a.error?a.emit(\"error\",a.error):(b[h]=!0,y(a.depMaps,function(h,f){var d=h.id,g=e(t,d);!g||a.depMatched[f]||c[d]||(e(b,d)?(a.defineDep(f,v[d]),a.check()):J(g,b,c))}),c[h]=!0)}function H(){var a,b,c=(a=1E3*p.waitSeconds)&&l.startTime+a<(new Date).getTime(),h=[],k=[],f=!1,g=!0;if(!aa){aa=!0;D(Z,function(a){var l=a.map,e=l.id;if(a.enabled&&(l.isDefine||k.push(a),!a.error))if(!a.inited&&c)m(e)?f=b=!0:(h.push(e),d(e));else if(!a.inited&&a.fetched&&l.isDefine&&\n(f=!0,!l.prefix))return g=!1});if(c&&h.length)return a=F(\"timeout\",\"Load timeout for modules: \"+h,null,h),a.contextName=l.contextName,A(a);g&&y(k,function(a){J(a,{},{})});c&&!b||!f||!E&&!ja||ba||(ba=setTimeout(function(){ba=0;H()},50));aa=!1}}function I(a){x(v,a[0])||u(q(a[0],null,!0)).init(a[1],a[2])}function O(a){a=a.currentTarget||a.srcElement;var b=l.onScriptLoad;a.detachEvent&&!ca?a.detachEvent(\"onreadystatechange\",b):a.removeEventListener(\"load\",b,!1);b=l.onScriptError;a.detachEvent&&!ca||a.removeEventListener(\"error\",\nb,!1);return{node:a,id:a&&a.getAttribute(\"data-requiremodule\")}}function P(){var a;for(B();G.length;){a=G.shift();if(null===a[0])return A(F(\"mismatch\",\"Mismatched anonymous define() module: \"+a[a.length-1]));I(a)}l.defQueueMap={}}var aa,da,l,R,ba,p={waitSeconds:7,baseUrl:\"./\",paths:{},bundles:{},pkgs:{},shim:{},config:{}},t={},Z={},ea={},G=[],v={},W={},fa={},Q=1,T=1;R={require:function(a){return a.require?a.require:a.require=l.makeRequire(a.map)},exports:function(a){a.usingExports=!0;if(a.map.isDefine)return a.exports?\nv[a.map.id]=a.exports:a.exports=v[a.map.id]={}},module:function(a){return a.module?a.module:a.module={id:a.map.id,uri:a.map.url,config:function(){return e(p.config,a.map.id)||{}},exports:a.exports||(a.exports={})}}};da=function(a){this.events=e(ea,a.id)||{};this.map=a;this.shim=e(p.shim,a.id);this.depExports=[];this.depMaps=[];this.depMatched=[];this.pluginMaps={};this.depCount=0};da.prototype={init:function(a,b,c,h){h=h||{};if(!this.inited){this.factory=b;if(c)this.on(\"error\",c);else this.events.error&&\n(c=z(this,function(a){this.emit(\"error\",a)}));this.depMaps=a&&a.slice(0);this.errback=c;this.inited=!0;this.ignore=h.ignore;h.enabled||this.enabled?this.enable():this.check()}},defineDep:function(a,b){this.depMatched[a]||(this.depMatched[a]=!0,--this.depCount,this.depExports[a]=b)},fetch:function(){if(!this.fetched){this.fetched=!0;l.startTime=(new Date).getTime();var a=this.map;if(this.shim)l.makeRequire(this.map,{enableBuildCallback:!0})(this.shim.deps||[],z(this,function(){return a.prefix?this.callPlugin():\nthis.load()}));else return a.prefix?this.callPlugin():this.load()}},load:function(){var a=this.map.url;W[a]||(W[a]=!0,l.load(this.map.id,a))},check:function(){if(this.enabled&&!this.enabling){var a,b,c=this.map.id;b=this.depExports;var h=this.exports,k=this.factory;if(!this.inited)x(l.defQueueMap,c)||this.fetch();else if(this.error)this.emit(\"error\",this.error);else if(!this.defining){this.defining=!0;if(1>this.depCount&&!this.defined){if(K(k)){if(this.events.error&&this.map.isDefine||g.onError!==\nha)try{h=l.execCb(c,k,b,h)}catch(d){a=d}else h=l.execCb(c,k,b,h);this.map.isDefine&&void 0===h&&((b=this.module)?h=b.exports:this.usingExports&&(h=this.exports));if(a)return a.requireMap=this.map,a.requireModules=this.map.isDefine?[this.map.id]:null,a.requireType=this.map.isDefine?\"define\":\"require\",A(this.error=a)}else h=k;this.exports=h;if(this.map.isDefine&&!this.ignore&&(v[c]=h,g.onResourceLoad)){var f=[];y(this.depMaps,function(a){f.push(a.normalizedMap||a)});g.onResourceLoad(l,this.map,f)}C(c);\nthis.defined=!0}this.defining=!1;this.defined&&!this.defineEmitted&&(this.defineEmitted=!0,this.emit(\"defined\",this.exports),this.defineEmitComplete=!0)}}},callPlugin:function(){var a=this.map,b=a.id,d=q(a.prefix);this.depMaps.push(d);w(d,\"defined\",z(this,function(h){var k,f,d=e(fa,this.map.id),M=this.map.name,r=this.map.parentMap?this.map.parentMap.name:null,m=l.makeRequire(a.parentMap,{enableBuildCallback:!0});if(this.map.unnormalized){if(h.normalize&&(M=h.normalize(M,function(a){return c(a,r,!0)})||\n\"\"),f=q(a.prefix+\"!\"+M,this.map.parentMap),w(f,\"defined\",z(this,function(a){this.map.normalizedMap=f;this.init([],function(){return a},null,{enabled:!0,ignore:!0})})),h=e(t,f.id)){this.depMaps.push(f);if(this.events.error)h.on(\"error\",z(this,function(a){this.emit(\"error\",a)}));h.enable()}}else d?(this.map.url=l.nameToUrl(d),this.load()):(k=z(this,function(a){this.init([],function(){return a},null,{enabled:!0})}),k.error=z(this,function(a){this.inited=!0;this.error=a;a.requireModules=[b];D(t,function(a){0===\na.map.id.indexOf(b+\"_unnormalized\")&&C(a.map.id)});A(a)}),k.fromText=z(this,function(h,c){var d=a.name,f=q(d),M=S;c&&(h=c);M&&(S=!1);u(f);x(p.config,b)&&(p.config[d]=p.config[b]);try{g.exec(h)}catch(e){return A(F(\"fromtexteval\",\"fromText eval for \"+b+\" failed: \"+e,e,[b]))}M&&(S=!0);this.depMaps.push(f);l.completeLoad(d);m([d],k)}),h.load(a.name,m,k,p))}));l.enable(d,this);this.pluginMaps[d.id]=d},enable:function(){Z[this.map.id]=this;this.enabling=this.enabled=!0;y(this.depMaps,z(this,function(a,\nb){var c,h;if(\"string\"===typeof a){a=q(a,this.map.isDefine?this.map:this.map.parentMap,!1,!this.skipMap);this.depMaps[b]=a;if(c=e(R,a.id)){this.depExports[b]=c(this);return}this.depCount+=1;w(a,\"defined\",z(this,function(a){this.undefed||(this.defineDep(b,a),this.check())}));this.errback?w(a,\"error\",z(this,this.errback)):this.events.error&&w(a,\"error\",z(this,function(a){this.emit(\"error\",a)}))}c=a.id;h=t[c];x(R,c)||!h||h.enabled||l.enable(a,this)}));D(this.pluginMaps,z(this,function(a){var b=e(t,a.id);\nb&&!b.enabled&&l.enable(a,this)}));this.enabling=!1;this.check()},on:function(a,b){var c=this.events[a];c||(c=this.events[a]=[]);c.push(b)},emit:function(a,b){y(this.events[a],function(a){a(b)});\"error\"===a&&delete this.events[a]}};l={config:p,contextName:b,registry:t,defined:v,urlFetched:W,defQueue:G,defQueueMap:{},Module:da,makeModuleMap:q,nextTick:g.nextTick,onError:A,configure:function(a){a.baseUrl&&\"/\"!==a.baseUrl.charAt(a.baseUrl.length-1)&&(a.baseUrl+=\"/\");if(\"string\"===typeof a.urlArgs){var b=\na.urlArgs;a.urlArgs=function(a,c){return(-1===c.indexOf(\"?\")?\"?\":\"&\")+b}}var c=p.shim,h={paths:!0,bundles:!0,config:!0,map:!0};D(a,function(a,b){h[b]?(p[b]||(p[b]={}),Y(p[b],a,!0,!0)):p[b]=a});a.bundles&&D(a.bundles,function(a,b){y(a,function(a){a!==b&&(fa[a]=b)})});a.shim&&(D(a.shim,function(a,b){L(a)&&(a={deps:a});!a.exports&&!a.init||a.exportsFn||(a.exportsFn=l.makeShimExports(a));c[b]=a}),p.shim=c);a.packages&&y(a.packages,function(a){var b;a=\"string\"===typeof a?{name:a}:a;b=a.name;a.location&&\n(p.paths[b]=a.location);p.pkgs[b]=a.name+\"/\"+(a.main||\"main\").replace(na,\"\").replace(U,\"\")});D(t,function(a,b){a.inited||a.map.unnormalized||(a.map=q(b,null,!0))});(a.deps||a.callback)&&l.require(a.deps||[],a.callback)},makeShimExports:function(a){return function(){var b;a.init&&(b=a.init.apply(ga,arguments));return b||a.exports&&ia(a.exports)}},makeRequire:function(a,n){function m(c,d,f){var e,r;n.enableBuildCallback&&d&&K(d)&&(d.__requireJsBuild=!0);if(\"string\"===typeof c){if(K(d))return A(F(\"requireargs\",\n\"Invalid require call\"),f);if(a&&x(R,c))return R[c](t[a.id]);if(g.get)return g.get(l,c,a,m);e=q(c,a,!1,!0);e=e.id;return x(v,e)?v[e]:A(F(\"notloaded\",'Module name \"'+e+'\" has not been loaded yet for context: '+b+(a?\"\":\". Use require([])\")))}P();l.nextTick(function(){P();r=u(q(null,a));r.skipMap=n.skipMap;r.init(c,d,f,{enabled:!0});H()});return m}n=n||{};Y(m,{isBrowser:E,toUrl:function(b){var d,f=b.lastIndexOf(\".\"),g=b.split(\"/\")[0];-1!==f&&(\".\"!==g&&\"..\"!==g||1<f)&&(d=b.substring(f,b.length),b=b.substring(0,\nf));return l.nameToUrl(c(b,a&&a.id,!0),d,!0)},defined:function(b){return x(v,q(b,a,!1,!0).id)},specified:function(b){b=q(b,a,!1,!0).id;return x(v,b)||x(t,b)}});a||(m.undef=function(b){B();var c=q(b,a,!0),f=e(t,b);f.undefed=!0;d(b);delete v[b];delete W[c.url];delete ea[b];X(G,function(a,c){a[0]===b&&G.splice(c,1)});delete l.defQueueMap[b];f&&(f.events.defined&&(ea[b]=f.events),C(b))});return m},enable:function(a){e(t,a.id)&&u(a).enable()},completeLoad:function(a){var b,c,d=e(p.shim,a)||{},g=d.exports;\nfor(B();G.length;){c=G.shift();if(null===c[0]){c[0]=a;if(b)break;b=!0}else c[0]===a&&(b=!0);I(c)}l.defQueueMap={};c=e(t,a);if(!b&&!x(v,a)&&c&&!c.inited)if(!p.enforceDefine||g&&ia(g))I([a,d.deps||[],d.exportsFn]);else return m(a)?void 0:A(F(\"nodefine\",\"No define call for \"+a,null,[a]));H()},nameToUrl:function(a,b,c){var d,k,f,m;(d=e(p.pkgs,a))&&(a=d);if(d=e(fa,a))return l.nameToUrl(d,b,c);if(g.jsExtRegExp.test(a))d=a+(b||\"\");else{d=p.paths;k=a.split(\"/\");for(f=k.length;0<f;--f)if(m=k.slice(0,f).join(\"/\"),\nm=e(d,m)){L(m)&&(m=m[0]);k.splice(0,f,m);break}d=k.join(\"/\");d+=b||(/^data\\:|^blob\\:|\\?/.test(d)||c?\"\":\".js\");d=(\"/\"===d.charAt(0)||d.match(/^[\\w\\+\\.\\-]+:/)?\"\":p.baseUrl)+d}return p.urlArgs&&!/^blob\\:/.test(d)?d+p.urlArgs(a,d):d},load:function(a,b){g.load(l,a,b)},execCb:function(a,b,c,d){return b.apply(d,c)},onScriptLoad:function(a){if(\"load\"===a.type||oa.test((a.currentTarget||a.srcElement).readyState))N=null,a=O(a),l.completeLoad(a.id)},onScriptError:function(a){var b=O(a);if(!m(b.id)){var c=[];\nD(t,function(a,d){0!==d.indexOf(\"_@r\")&&y(a.depMaps,function(a){if(a.id===b.id)return c.push(d),!0})});return A(F(\"scripterror\",'Script error for \"'+b.id+(c.length?'\", needed by: '+c.join(\", \"):'\"'),a,[b.id]))}}};l.require=l.makeRequire();return l}function pa(){if(N&&\"interactive\"===N.readyState)return N;X(document.getElementsByTagName(\"script\"),function(b){if(\"interactive\"===b.readyState)return N=b});return N}var g,B,C,H,O,I,N,P,u,T,qa=/(\\/\\*([\\s\\S]*?)\\*\\/|([^:]|^)\\/\\/(.*)$)/mg,ra=/[^.]\\s*require\\s*\\(\\s*[\"']([^'\"\\s]+)[\"']\\s*\\)/g,\nU=/\\.js$/,na=/^\\.\\//;B=Object.prototype;var Q=B.toString,la=B.hasOwnProperty,E=!(\"undefined\"===typeof window||\"undefined\"===typeof navigator||!window.document),ja=!E&&\"undefined\"!==typeof importScripts,oa=E&&\"PLAYSTATION 3\"===navigator.platform?/^complete$/:/^(complete|loaded)$/,ca=\"undefined\"!==typeof opera&&\"[object Opera]\"===opera.toString(),J={},w={},V=[],S=!1;if(\"undefined\"===typeof define){if(\"undefined\"!==typeof requirejs){if(K(requirejs))return;w=requirejs;requirejs=void 0}\"undefined\"===typeof require||\nK(require)||(w=require,require=void 0);g=requirejs=function(b,c,d,m){var r,q=\"_\";L(b)||\"string\"===typeof b||(r=b,L(c)?(b=c,c=d,d=m):b=[]);r&&r.context&&(q=r.context);(m=e(J,q))||(m=J[q]=g.s.newContext(q));r&&m.configure(r);return m.require(b,c,d)};g.config=function(b){return g(b)};g.nextTick=\"undefined\"!==typeof setTimeout?function(b){setTimeout(b,4)}:function(b){b()};require||(require=g);g.version=\"2.2.0\";g.jsExtRegExp=/^\\/|:|\\?|\\.js$/;g.isBrowser=E;B=g.s={contexts:J,newContext:ma};g({});y([\"toUrl\",\n\"undef\",\"defined\",\"specified\"],function(b){g[b]=function(){var c=J._;return c.require[b].apply(c,arguments)}});E&&(C=B.head=document.getElementsByTagName(\"head\")[0],H=document.getElementsByTagName(\"base\")[0])&&(C=B.head=H.parentNode);g.onError=ha;g.createNode=function(b,c,d){c=b.xhtml?document.createElementNS(\"http://www.w3.org/1999/xhtml\",\"html:script\"):document.createElement(\"script\");c.type=b.scriptType||\"text/javascript\";c.charset=\"utf-8\";c.async=!0;return c};g.load=function(b,c,d){var m=b&&b.config||\n{},e;if(E){e=g.createNode(m,c,d);e.setAttribute(\"data-requirecontext\",b.contextName);e.setAttribute(\"data-requiremodule\",c);!e.attachEvent||e.attachEvent.toString&&0>e.attachEvent.toString().indexOf(\"[native code\")||ca?(e.addEventListener(\"load\",b.onScriptLoad,!1),e.addEventListener(\"error\",b.onScriptError,!1)):(S=!0,e.attachEvent(\"onreadystatechange\",b.onScriptLoad));e.src=d;if(m.onNodeCreated)m.onNodeCreated(e,m,c,d);P=e;H?C.insertBefore(e,H):C.appendChild(e);P=null;return e}if(ja)try{setTimeout(function(){},\n0),importScripts(d),b.completeLoad(c)}catch(q){b.onError(F(\"importscripts\",\"importScripts failed for \"+c+\" at \"+d,q,[c]))}};E&&!w.skipDataMain&&X(document.getElementsByTagName(\"script\"),function(b){C||(C=b.parentNode);if(O=b.getAttribute(\"data-main\"))return u=O,w.baseUrl||-1!==u.indexOf(\"!\")||(I=u.split(\"/\"),u=I.pop(),T=I.length?I.join(\"/\")+\"/\":\"./\",w.baseUrl=T),u=u.replace(U,\"\"),g.jsExtRegExp.test(u)&&(u=O),w.deps=w.deps?w.deps.concat(u):[u],!0});define=function(b,c,d){var e,g;\"string\"!==typeof b&&\n(d=c,c=b,b=null);L(c)||(d=c,c=null);!c&&K(d)&&(c=[],d.length&&(d.toString().replace(qa,ka).replace(ra,function(b,d){c.push(d)}),c=(1===d.length?[\"require\"]:[\"require\",\"exports\",\"module\"]).concat(c)));S&&(e=P||pa())&&(b||(b=e.getAttribute(\"data-requiremodule\")),g=J[e.getAttribute(\"data-requirecontext\")]);g?(g.defQueue.push([b,c,d]),g.defQueueMap[b]=!0):V.push([b,c,d])};define.amd={jQuery:!0};g.exec=function(b){return eval(b)};g(w)}})(this);\n","/home/travis/build/npmtest/node-npmtest-aurelia-cli/node_modules/aurelia-cli/lib/resources/scripts/text.js":"/**\n * @license RequireJS text 2.0.14 Copyright (c) 2010-2014, The Dojo Foundation All Rights Reserved.\n * Available via the MIT or new BSD license.\n * see: http://github.com/requirejs/text for details\n */\n/*jslint regexp: true */\n/*global require, XMLHttpRequest, ActiveXObject,\n  define, window, process, Packages,\n  java, location, Components, FileUtils */\n\ndefine(['module'], function (module) {\n    'use strict';\n\n    var text, fs, Cc, Ci, xpcIsWindows,\n        progIds = ['Msxml2.XMLHTTP', 'Microsoft.XMLHTTP', 'Msxml2.XMLHTTP.4.0'],\n        xmlRegExp = /^\\s*<\\?xml(\\s)+version=[\\'\\\"](\\d)*.(\\d)*[\\'\\\"](\\s)*\\?>/im,\n        bodyRegExp = /<body[^>]*>\\s*([\\s\\S]+)\\s*<\\/body>/im,\n        hasLocation = typeof location !== 'undefined' && location.href,\n        defaultProtocol = hasLocation && location.protocol && location.protocol.replace(/\\:/, ''),\n        defaultHostName = hasLocation && location.hostname,\n        defaultPort = hasLocation && (location.port || undefined),\n        buildMap = {},\n        masterConfig = (module.config && module.config()) || {};\n\n    text = {\n        version: '2.0.14',\n\n        strip: function (content) {\n            //Strips <?xml ...?> declarations so that external SVG and XML\n            //documents can be added to a document without worry. Also, if the string\n            //is an HTML document, only the part inside the body tag is returned.\n            if (content) {\n                content = content.replace(xmlRegExp, \"\");\n                var matches = content.match(bodyRegExp);\n                if (matches) {\n                    content = matches[1];\n                }\n            } else {\n                content = \"\";\n            }\n            return content;\n        },\n\n        jsEscape: function (content) {\n            return content.replace(/(['\\\\])/g, '\\\\$1')\n                .replace(/[\\f]/g, \"\\\\f\")\n                .replace(/[\\b]/g, \"\\\\b\")\n                .replace(/[\\n]/g, \"\\\\n\")\n                .replace(/[\\t]/g, \"\\\\t\")\n                .replace(/[\\r]/g, \"\\\\r\")\n                .replace(/[\\u2028]/g, \"\\\\u2028\")\n                .replace(/[\\u2029]/g, \"\\\\u2029\");\n        },\n\n        createXhr: masterConfig.createXhr || function () {\n            //Would love to dump the ActiveX crap in here. Need IE 6 to die first.\n            var xhr, i, progId;\n            if (typeof XMLHttpRequest !== \"undefined\") {\n                return new XMLHttpRequest();\n            } else if (typeof ActiveXObject !== \"undefined\") {\n                for (i = 0; i < 3; i += 1) {\n                    progId = progIds[i];\n                    try {\n                        xhr = new ActiveXObject(progId);\n                    } catch (e) {}\n\n                    if (xhr) {\n                        progIds = [progId];  // so faster next time\n                        break;\n                    }\n                }\n            }\n\n            return xhr;\n        },\n\n        /**\n         * Parses a resource name into its component parts. Resource names\n         * look like: module/name.ext!strip, where the !strip part is\n         * optional.\n         * @param {String} name the resource name\n         * @returns {Object} with properties \"moduleName\", \"ext\" and \"strip\"\n         * where strip is a boolean.\n         */\n        parseName: function (name) {\n            var modName, ext, temp,\n                strip = false,\n                index = name.lastIndexOf(\".\"),\n                isRelative = name.indexOf('./') === 0 ||\n                             name.indexOf('../') === 0;\n\n            if (index !== -1 && (!isRelative || index > 1)) {\n                modName = name.substring(0, index);\n                ext = name.substring(index + 1);\n            } else {\n                modName = name;\n            }\n\n            temp = ext || modName;\n            index = temp.indexOf(\"!\");\n            if (index !== -1) {\n                //Pull off the strip arg.\n                strip = temp.substring(index + 1) === \"strip\";\n                temp = temp.substring(0, index);\n                if (ext) {\n                    ext = temp;\n                } else {\n                    modName = temp;\n                }\n            }\n\n            return {\n                moduleName: modName,\n                ext: ext,\n                strip: strip\n            };\n        },\n\n        xdRegExp: /^((\\w+)\\:)?\\/\\/([^\\/\\\\]+)/,\n\n        /**\n         * Is an URL on another domain. Only works for browser use, returns\n         * false in non-browser environments. Only used to know if an\n         * optimized .js version of a text resource should be loaded\n         * instead.\n         * @param {String} url\n         * @returns Boolean\n         */\n        useXhr: function (url, protocol, hostname, port) {\n            var uProtocol, uHostName, uPort,\n                match = text.xdRegExp.exec(url);\n            if (!match) {\n                return true;\n            }\n            uProtocol = match[2];\n            uHostName = match[3];\n\n            uHostName = uHostName.split(':');\n            uPort = uHostName[1];\n            uHostName = uHostName[0];\n\n            return (!uProtocol || uProtocol === protocol) &&\n                   (!uHostName || uHostName.toLowerCase() === hostname.toLowerCase()) &&\n                   ((!uPort && !uHostName) || uPort === port);\n        },\n\n        finishLoad: function (name, strip, content, onLoad) {\n            content = strip ? text.strip(content) : content;\n            if (masterConfig.isBuild) {\n                buildMap[name] = content;\n            }\n            onLoad(content);\n        },\n\n        load: function (name, req, onLoad, config) {\n            //Name has format: some.module.filext!strip\n            //The strip part is optional.\n            //if strip is present, then that means only get the string contents\n            //inside a body tag in an HTML string. For XML/SVG content it means\n            //removing the <?xml ...?> declarations so the content can be inserted\n            //into the current doc without problems.\n\n            // Do not bother with the work if a build and text will\n            // not be inlined.\n            if (config && config.isBuild && !config.inlineText) {\n                onLoad();\n                return;\n            }\n\n            masterConfig.isBuild = config && config.isBuild;\n\n            var parsed = text.parseName(name),\n                nonStripName = parsed.moduleName +\n                    (parsed.ext ? '.' + parsed.ext : ''),\n                url = req.toUrl(nonStripName),\n                useXhr = (masterConfig.useXhr) ||\n                         text.useXhr;\n\n            // Do not load if it is an empty: url\n            if (url.indexOf('empty:') === 0) {\n                onLoad();\n                return;\n            }\n\n            //Load the text. Use XHR if possible and in a browser.\n            if (!hasLocation || useXhr(url, defaultProtocol, defaultHostName, defaultPort)) {\n                text.get(url, function (content) {\n                    text.finishLoad(name, parsed.strip, content, onLoad);\n                }, function (err) {\n                    if (onLoad.error) {\n                        onLoad.error(err);\n                    }\n                });\n            } else {\n                //Need to fetch the resource across domains. Assume\n                //the resource has been optimized into a JS module. Fetch\n                //by the module name + extension, but do not include the\n                //!strip part to avoid file system issues.\n                req([nonStripName], function (content) {\n                    text.finishLoad(parsed.moduleName + '.' + parsed.ext,\n                                    parsed.strip, content, onLoad);\n                });\n            }\n        },\n\n        write: function (pluginName, moduleName, write, config) {\n            if (buildMap.hasOwnProperty(moduleName)) {\n                var content = text.jsEscape(buildMap[moduleName]);\n                write.asModule(pluginName + \"!\" + moduleName,\n                               \"define(function () { return '\" +\n                                   content +\n                               \"';});\\n\");\n            }\n        },\n\n        writeFile: function (pluginName, moduleName, req, write, config) {\n            var parsed = text.parseName(moduleName),\n                extPart = parsed.ext ? '.' + parsed.ext : '',\n                nonStripName = parsed.moduleName + extPart,\n                //Use a '.js' file name so that it indicates it is a\n                //script that can be loaded across domains.\n                fileName = req.toUrl(parsed.moduleName + extPart) + '.js';\n\n            //Leverage own load() method to load plugin value, but only\n            //write out values that do not have the strip argument,\n            //to avoid any potential issues with ! in file names.\n            text.load(nonStripName, req, function (value) {\n                //Use own write() method to construct full module value.\n                //But need to create shell that translates writeFile's\n                //write() to the right interface.\n                var textWrite = function (contents) {\n                    return write(fileName, contents);\n                };\n                textWrite.asModule = function (moduleName, contents) {\n                    return write.asModule(moduleName, fileName, contents);\n                };\n\n                text.write(pluginName, nonStripName, textWrite, config);\n            }, config);\n        }\n    };\n\n    if (masterConfig.env === 'node' || (!masterConfig.env &&\n            typeof process !== \"undefined\" &&\n            process.versions &&\n            !!process.versions.node &&\n            !process.versions['node-webkit'] &&\n            !process.versions['atom-shell'])) {\n        //Using special require.nodeRequire, something added by r.js.\n        fs = require.nodeRequire('fs');\n\n        text.get = function (url, callback, errback) {\n            try {\n                var file = fs.readFileSync(url, 'utf8');\n                //Remove BOM (Byte Mark Order) from utf8 files if it is there.\n                if (file[0] === '\\uFEFF') {\n                    file = file.substring(1);\n                }\n                callback(file);\n            } catch (e) {\n                if (errback) {\n                    errback(e);\n                }\n            }\n        };\n    } else if (masterConfig.env === 'xhr' || (!masterConfig.env &&\n            text.createXhr())) {\n        text.get = function (url, callback, errback, headers) {\n            var xhr = text.createXhr(), header;\n            xhr.open('GET', url, true);\n\n            //Allow plugins direct access to xhr headers\n            if (headers) {\n                for (header in headers) {\n                    if (headers.hasOwnProperty(header)) {\n                        xhr.setRequestHeader(header.toLowerCase(), headers[header]);\n                    }\n                }\n            }\n\n            //Allow overrides specified in config\n            if (masterConfig.onXhr) {\n                masterConfig.onXhr(xhr, url);\n            }\n\n            xhr.onreadystatechange = function (evt) {\n                var status, err;\n                //Do not explicitly handle errors, those should be\n                //visible via console output in the browser.\n                if (xhr.readyState === 4) {\n                    status = xhr.status || 0;\n                    if (status > 399 && status < 600) {\n                        //An http 4xx or 5xx error. Signal an error.\n                        err = new Error(url + ' HTTP status: ' + status);\n                        err.xhr = xhr;\n                        if (errback) {\n                            errback(err);\n                        }\n                    } else {\n                        callback(xhr.responseText);\n                    }\n\n                    if (masterConfig.onXhrComplete) {\n                        masterConfig.onXhrComplete(xhr, url);\n                    }\n                }\n            };\n            xhr.send(null);\n        };\n    } else if (masterConfig.env === 'rhino' || (!masterConfig.env &&\n            typeof Packages !== 'undefined' && typeof java !== 'undefined')) {\n        //Why Java, why is this so awkward?\n        text.get = function (url, callback) {\n            var stringBuffer, line,\n                encoding = \"utf-8\",\n                file = new java.io.File(url),\n                lineSeparator = java.lang.System.getProperty(\"line.separator\"),\n                input = new java.io.BufferedReader(new java.io.InputStreamReader(new java.io.FileInputStream(file), encoding)),\n                content = '';\n            try {\n                stringBuffer = new java.lang.StringBuffer();\n                line = input.readLine();\n\n                // Byte Order Mark (BOM) - The Unicode Standard, version 3.0, page 324\n                // http://www.unicode.org/faq/utf_bom.html\n\n                // Note that when we use utf-8, the BOM should appear as \"EF BB BF\", but it doesn't due to this bug in the JDK:\n                // http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4508058\n                if (line && line.length() && line.charAt(0) === 0xfeff) {\n                    // Eat the BOM, since we've already found the encoding on this file,\n                    // and we plan to concatenating this buffer with others; the BOM should\n                    // only appear at the top of a file.\n                    line = line.substring(1);\n                }\n\n                if (line !== null) {\n                    stringBuffer.append(line);\n                }\n\n                while ((line = input.readLine()) !== null) {\n                    stringBuffer.append(lineSeparator);\n                    stringBuffer.append(line);\n                }\n                //Make sure we return a JavaScript string and not a Java string.\n                content = String(stringBuffer.toString()); //String\n            } finally {\n                input.close();\n            }\n            callback(content);\n        };\n    } else if (masterConfig.env === 'xpconnect' || (!masterConfig.env &&\n            typeof Components !== 'undefined' && Components.classes &&\n            Components.interfaces)) {\n        //Avert your gaze!\n        Cc = Components.classes;\n        Ci = Components.interfaces;\n        Components.utils['import']('resource://gre/modules/FileUtils.jsm');\n        xpcIsWindows = ('@mozilla.org/windows-registry-key;1' in Cc);\n\n        text.get = function (url, callback) {\n            var inStream, convertStream, fileObj,\n                readData = {};\n\n            if (xpcIsWindows) {\n                url = url.replace(/\\//g, '\\\\');\n            }\n\n            fileObj = new FileUtils.File(url);\n\n            //XPCOM, you so crazy\n            try {\n                inStream = Cc['@mozilla.org/network/file-input-stream;1']\n                           .createInstance(Ci.nsIFileInputStream);\n                inStream.init(fileObj, 1, 0, false);\n\n                convertStream = Cc['@mozilla.org/intl/converter-input-stream;1']\n                                .createInstance(Ci.nsIConverterInputStream);\n                convertStream.init(inStream, \"utf-8\", inStream.available(),\n                Ci.nsIConverterInputStream.DEFAULT_REPLACEMENT_CHARACTER);\n\n                convertStream.readString(inStream.available(), readData);\n                convertStream.close();\n                inStream.close();\n                callback(readData.value);\n            } catch (e) {\n                throw new Error((fileObj && fileObj.path || '') + ': ' + e);\n            }\n        };\n    }\n    return text;\n});\n","/home/travis/build/npmtest/node-npmtest-aurelia-cli/node_modules/aurelia-cli/lib/resources/src/app.js":"export class App {\n  constructor() {\n    this.message = 'Hello World!';\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-aurelia-cli/node_modules/aurelia-cli/lib/resources/src/main.js":"import environment from './environment';\n\nexport function configure(aurelia) {\n  aurelia.use\n    .standardConfiguration()\n    .feature('resources');\n\n  if (environment.debug) {\n    aurelia.use.developmentLogging();\n  }\n\n  if (environment.testing) {\n    aurelia.use.plugin('aurelia-testing');\n  }\n\n  aurelia.start().then(() => aurelia.setRoot());\n}\n","/home/travis/build/npmtest/node-npmtest-aurelia-cli/node_modules/aurelia-cli/lib/resources/tasks/copy-files.js":"import gulp from 'gulp';\nimport path from 'path';\nimport minimatch from 'minimatch';\nimport changedInPlace from 'gulp-changed-in-place';\nimport project from '../aurelia.json';\n\nexport default function copyFiles(done) {\n  if (typeof project.build.copyFiles !== 'object') {\n    done();\n    return;\n  }\n\n  const instruction = getNormalizedInstruction();\n  const files = Object.keys(instruction);\n\n  return gulp.src(files)\n    .pipe(changedInPlace({ firstPass: true }))\n    .pipe(gulp.dest(x => {\n      const filePath = prepareFilePath(x.path);\n      const key = files.find(f => minimatch(filePath, f));\n      return instruction[key];\n    }));\n}\n\nfunction getNormalizedInstruction() {\n  const files = project.build.copyFiles;\n  let normalizedInstruction = {};\n\n  for (let key in files) {\n    normalizedInstruction[path.posix.normalize(key)] = files[key];\n  }\n\n  return normalizedInstruction;\n}\n\nfunction prepareFilePath(filePath) {\n  let preparedPath = filePath.replace(process.cwd(), '').substring(1);\n\n  //if we are running on windows we have to fix the path\n  if (/^win/.test(process.platform)) {\n    preparedPath = preparedPath.replace(/\\\\/g, '/');\n  }\n\n  return preparedPath;\n}\n","/home/travis/build/npmtest/node-npmtest-aurelia-cli/node_modules/aurelia-cli/lib/resources/tasks/process-css.js":"import gulp from 'gulp';\nimport changedInPlace from 'gulp-changed-in-place';\nimport project from '../aurelia.json';\nimport {build} from 'aurelia-cli';\n\nexport default function processCSS() {\n  return gulp.src(project.cssProcessor.source)\n    .pipe(changedInPlace({firstPass: true}))\n    .pipe(build.bundle());\n}\n","/home/travis/build/npmtest/node-npmtest-aurelia-cli/node_modules/aurelia-cli/lib/resources/tasks/process-less.js":"import gulp from 'gulp';\nimport changedInPlace from 'gulp-changed-in-place';\nimport sourcemaps from 'gulp-sourcemaps';\nimport less from 'gulp-less';\nimport plumber from 'gulp-plumber';\nimport notify from 'gulp-notify';\nimport project from '../aurelia.json';\nimport {build} from 'aurelia-cli';\n\nexport default function processCSS() {\n  return gulp.src(project.cssProcessor.source)\n    .pipe(changedInPlace({firstPass: true}))\n    .pipe(plumber({ errorHandler: notify.onError('Error: <%= error.message %>') }))\n    .pipe(sourcemaps.init())\n    .pipe(less())\n    .pipe(build.bundle());\n}\n","/home/travis/build/npmtest/node-npmtest-aurelia-cli/node_modules/aurelia-cli/lib/resources/tasks/process-markup.js":"import gulp from 'gulp';\nimport changedInPlace from 'gulp-changed-in-place';\nimport project from '../aurelia.json';\nimport {build} from 'aurelia-cli';\n\nexport default function processMarkup() {\n  return gulp.src(project.markupProcessor.source)\n    .pipe(changedInPlace({firstPass: true}))\n    .pipe(build.bundle());\n}\n","/home/travis/build/npmtest/node-npmtest-aurelia-cli/node_modules/aurelia-cli/lib/resources/tasks/process-markup-minify-max.js":"import gulp from 'gulp';\nimport htmlmin from 'gulp-htmlmin';\nimport changedInPlace from 'gulp-changed-in-place';\nimport project from '../aurelia.json';\nimport {build} from 'aurelia-cli';\n\nexport default function processMarkup() {\n  return gulp.src(project.markupProcessor.source)\n    .pipe(changedInPlace({firstPass:true}))\n    .pipe(htmlmin({\n        removeComments: true,\n        collapseWhitespace: true,\n        collapseInlineTagWhitespace: true,\n        collapseBooleanAttributes: true,\n        removeAttributeQuotes: true,\n        minifyCSS: true,\n        minifyJS: true,\n        removeScriptTypeAttributes: true,\n        removeStyleLinkTypeAttributes: true\n    }))\n    .pipe(build.bundle());\n}","/home/travis/build/npmtest/node-npmtest-aurelia-cli/node_modules/aurelia-cli/lib/resources/tasks/process-postcss.js":"import gulp from 'gulp';\nimport changedInPlace from 'gulp-changed-in-place';\nimport sourcemaps from 'gulp-sourcemaps';\nimport postcss from 'gulp-postcss';\nimport autoprefixer from 'autoprefixer';\nimport project from '../aurelia.json';\nimport {build} from 'aurelia-cli';\n\nexport default function processCSS() {\n  let processors = [\n    autoprefixer({browsers: ['last 1 version']})\n  ];\n\n  return gulp.src(project.cssProcessor.source)\n    .pipe(changedInPlace({firstPass: true}))\n    .pipe(sourcemaps.init())\n    .pipe(postcss(processors))\n    .pipe(build.bundle());\n}\n","/home/travis/build/npmtest/node-npmtest-aurelia-cli/node_modules/aurelia-cli/lib/resources/tasks/process-pug.js":"import gulp from 'gulp';\nimport changedInPlace from 'gulp-changed-in-place';\nimport sourcemaps from 'gulp-sourcemaps';\nimport jade from 'gulp-jade';\nimport project from '../aurelia.json';\nimport {build} from 'aurelia-cli';\n\nexport default function processMarkup() {\n  return gulp.src(project.markupProcessor.source)\n    .pipe(changedInPlace({firstPass: true}))\n    .pipe(sourcemaps.init())\n    .pipe(jade())\n    .pipe(build.bundle());\n}\n","/home/travis/build/npmtest/node-npmtest-aurelia-cli/node_modules/aurelia-cli/lib/resources/tasks/process-sass.js":"import gulp from 'gulp';\nimport sourcemaps from 'gulp-sourcemaps';\nimport sass from 'gulp-sass';\nimport project from '../aurelia.json';\nimport {build} from 'aurelia-cli';\n\nexport default function processCSS() {\n  return gulp.src(project.cssProcessor.source)\n    .pipe(sourcemaps.init())\n    .pipe(sass().on('error', sass.logError))\n    .pipe(build.bundle());\n}\n","/home/travis/build/npmtest/node-npmtest-aurelia-cli/node_modules/aurelia-cli/lib/resources/tasks/process-stylus.js":"import gulp from 'gulp';\nimport changedInPlace from 'gulp-changed-in-place';\nimport sourcemaps from 'gulp-sourcemaps';\nimport stylus from 'gulp-stylus';\nimport project from '../aurelia.json';\nimport {build} from 'aurelia-cli';\n\nexport default function processCSS() {\n  return gulp.src(project.cssProcessor.source)\n    .pipe(changedInPlace({firstPass: true}))\n    .pipe(sourcemaps.init())\n    .pipe(stylus())\n    .pipe(build.bundle());\n}\n","/home/travis/build/npmtest/node-npmtest-aurelia-cli/node_modules/aurelia-cli/lib/resources/tasks/run.js":"import gulp from 'gulp';\nimport browserSync from 'browser-sync';\nimport historyApiFallback from 'connect-history-api-fallback/lib';\nimport project from '../aurelia.json';\nimport build from './build';\nimport {CLIOptions} from 'aurelia-cli';\n\nfunction log(message) {\n  console.log(message); //eslint-disable-line no-console\n}\n\nfunction onChange(path) {\n  log(`File Changed: ${path}`);\n}\n\nfunction reload(done) {\n  browserSync.reload();\n  done();\n}\n\nlet serve = gulp.series(\n  build,\n  done => {\n    browserSync({\n      online: false,\n      open: false,\n      port: 9000,\n      logLevel: 'silent',\n      server: {\n        baseDir: [project.platform.baseDir],\n        middleware: [historyApiFallback(), function(req, res, next) {\n          res.setHeader('Access-Control-Allow-Origin', '*');\n          next();\n        }]\n      }\n    }, function(err, bs) {\n      if (err) return done(err);\n      let urls = bs.options.get('urls').toJS();\n      log(`Application Available At: ${urls.local}`);\n      log(`BrowserSync Available At: ${urls.ui}`);\n      done();\n    });\n  }\n);\n\nlet refresh = gulp.series(\n  build,\n  reload\n);\n\nlet watch = function(refreshCb, onChangeCb) {\n  return function(done) {\n    gulp.watch(project.transpiler.source, refreshCb).on('change', onChangeCb);\n    gulp.watch(project.markupProcessor.source, refreshCb).on('change', onChangeCb);\n    gulp.watch(project.cssProcessor.source, refreshCb).on('change', onChangeCb);\n\n    //see if there are static files to be watched\n    if (typeof project.build.copyFiles === 'object') {\n      const files = Object.keys(project.build.copyFiles);\n      gulp.watch(files, refreshCb).on('change', onChangeCb);\n    }\n  };\n};\n\nlet run;\n\nif (CLIOptions.hasFlag('watch')) {\n  run = gulp.series(\n    serve,\n    watch(refresh, onChange)\n  );\n} else {\n  run = serve;\n}\n\nexport { run as default, watch };\n","/home/travis/build/npmtest/node-npmtest-aurelia-cli/node_modules/aurelia-cli/lib/resources/tasks/transpile.js":"import gulp from 'gulp';\nimport changedInPlace from 'gulp-changed-in-place';\nimport plumber from 'gulp-plumber';\nimport babel from 'gulp-babel';\nimport sourcemaps from 'gulp-sourcemaps';\nimport notify from 'gulp-notify';\nimport rename from 'gulp-rename';\nimport project from '../aurelia.json';\nimport {CLIOptions, build} from 'aurelia-cli';\n\nfunction configureEnvironment() {\n  let env = CLIOptions.getEnvironment();\n\n  return gulp.src(`aurelia_project/environments/${env}.js`)\n    .pipe(changedInPlace({firstPass: true}))\n    .pipe(rename('environment.js'))\n    .pipe(gulp.dest(project.paths.root));\n}\n\nfunction buildJavaScript() {\n  return gulp.src(project.transpiler.source)\n    .pipe(plumber({errorHandler: notify.onError('Error: <%= error.message %>')}))\n    .pipe(changedInPlace({firstPass: true}))\n    .pipe(sourcemaps.init())\n    .pipe(babel(project.transpiler.options))\n    .pipe(build.bundle());\n}\n\nexport default gulp.series(\n  configureEnvironment,\n  buildJavaScript\n);\n","/home/travis/build/npmtest/node-npmtest-aurelia-cli/node_modules/aurelia-cli/lib/workflow/activities/branch-switch.js":"'use strict';\n\nmodule.exports = class {\n  execute(context) {\n    let switchVariable = context.state[this.stateProperty];\n\n    if (switchVariable.id) {\n      switchVariable = switchVariable.id;\n    }\n\n    let found = this.branches.find(x => x.case === switchVariable)\n      || this.branches.find(x => x.case === 'default');\n\n    context.next(found.nextActivity);\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-aurelia-cli/node_modules/aurelia-cli/lib/workflow/activities/input-select.js":"'use strict';\nconst UI = require('../../ui').UI;\n\nmodule.exports = class {\n  static inject() { return [UI]; }\n\n  constructor(ui) {\n    this.ui = ui;\n  }\n\n  execute(context) {\n    let overrideProperty = this.stateProperty + 'Override';\n\n    if (overrideProperty in context.state) {\n      context.state[this.stateProperty] = context.state[overrideProperty];\n      context.next(this.nextActivity);\n    } else {\n      this.ui.question(this.question, this.options).then(answer => {\n        context.state[this.stateProperty] = answer.value;\n        context.next(this.nextActivity);\n      });\n    }\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-aurelia-cli/node_modules/aurelia-cli/lib/workflow/activities/input-text.js":"'use strict';\nconst UI = require('../../ui').UI;\n\nmodule.exports = class {\n  static inject() { return [UI]; }\n\n  constructor(ui) {\n    this.ui = ui;\n  }\n\n  execute(context) {\n    this.ui.ensureAnswer(context.state[this.stateProperty], this.question, this.defaultValue).then(answer => {\n      context.state[this.stateProperty] = answer;\n      context.next(this.nextActivity);\n    });\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-aurelia-cli/node_modules/aurelia-cli/lib/workflow/activities/project-create.js":"'use strict';\nconst os = require('os');\nconst ProjectTemplate = require('../../commands/new/project-template').ProjectTemplate;\nconst UI = require('../../ui').UI;\nconst transform = require('../../colors/transform');\nconst CLIOptions = require('../../cli-options').CLIOptions;\nconst fs = require('../../file-system');\n\nmodule.exports = class {\n  static inject() { return [UI, CLIOptions]; }\n\n  constructor(ui, options) {\n    this.ui = ui;\n    this.options = options;\n  }\n\n  execute(context) {\n    let model = {\n      name: context.state.name,\n      type: context.state.type,\n      platform: context.state.platform,\n      transpiler: context.state.transpiler,\n      markupProcessor: context.state.markupProcessor,\n      cssProcessor: context.state.cssProcessor,\n      editor: context.state.editor\n    };\n\n    if (context.state.unitTestRunner) {\n      model.unitTestRunner = context.state.unitTestRunner;\n    }\n\n    let project = context.state.project = new ProjectTemplate(model, this.options);\n\n    return this.ui.clearScreen()\n      .then(() => this.ui.log(this.createProjectDescription(model)))\n      .then(() => this.projectConfirmation(project))\n      .then(answer => {\n        if (answer.value === 'yes') {\n          let configurePlatform = require(`../../commands/new/platforms/${model.platform.id}`);\n          configurePlatform(project, this.options);\n\n          let configureTranspiler = require(`../../commands/new/transpilers/${model.transpiler.id}`);\n          configureTranspiler(project, this.options);\n\n          let configureMarkupProcessor = require(`../../commands/new/markup-processors/${model.markupProcessor.id}`);\n          configureMarkupProcessor(project, this.options);\n\n          let configureCSSProcessor = require(`../../commands/new/css-processors/${model.cssProcessor.id}`);\n          configureCSSProcessor(project, this.options);\n\n          let configureUnitTestRunner = require(`../../commands/new/unit-test-runners/${model.unitTestRunner.id}`);\n          configureUnitTestRunner(project, this.options);\n\n          let configureEditor = require(`../../commands/new/editors/${model.editor.id}`);\n          configureEditor(project, this.options);\n\n          return project.create(this.ui, this.options.hasFlag('here') ? undefined : process.cwd())\n            .then(() => this.ui.clearScreen())\n            .then(() => this.ui.log('Project structure created and configured.'))\n            .then(() => context.next(this.nextActivity));\n        } else if (answer.value === 'restart') {\n          return context.next(this.restartActivity);\n        }\n\n        return this.ui.log(os.EOL + 'Project creation aborted.')\n          .then(() => context.next());\n      });\n  }\n\n  createProjectDescription(model) {\n    let text = os.EOL + 'Project Configuration' + os.EOL + os.EOL;\n\n    text += `    <magenta><bold>Name: </bold></magenta>${model.name}` + os.EOL;\n    text += `    <magenta><bold>Platform: </bold></magenta>${model.platform.displayName}` + os.EOL;\n    text += `    <magenta><bold>Transpiler: </bold></magenta>${model.transpiler.displayName}` + os.EOL;\n    text += `    <magenta><bold>Markup Processor: </bold></magenta>${model.markupProcessor.displayName}` + os.EOL;\n    text += `    <magenta><bold>CSS Processor: </bold></magenta>${model.cssProcessor.displayName}` + os.EOL;\n\n    if (model.unitTestRunner) {\n      text += `    <magenta><bold>Unit Test Runner: </bold></magenta>${model.unitTestRunner.displayName}` + os.EOL;\n    }\n\n    text += `    <magenta><bold>Editor: </bold></magenta>${model.editor.displayName}` + os.EOL;\n\n    return transform(text);\n  }\n\n  projectConfirmation(project) {\n    let question = 'Would you like to create this project?';\n    let yesDescription = 'Creates the project structure based on your selections.';\n\n    if (!this.options.hasFlag('here') && fs.existsSync(project.root.name)) {\n      question = transform(`<red><bold>WARNING:</bold></red> The '${project.root.name}' folder already exists. Would you like to create the project in this folder?`);\n      yesDescription = transform(`Creates the project structure based on your selections <red><bold>even though the '${project.root.name}' directory already exists</bold></red>`);\n    } else if (this.options.hasFlag('here') && fs.readdirSync(process.cwd()).length > 0) {\n      question = transform('<red><bold>WARNING:</bold></red> The current directory is not empty. Would you like to create the project in this folder?');\n      yesDescription = transform('Creates the project structure based on your selections <red><bold>even though the current directory is not empty</bold></red>');\n    }\n\n    return this.ui.question(question, [\n      {\n        displayName: 'Yes',\n        description: yesDescription,\n        value: 'yes'\n      },\n      {\n        displayName: 'Restart',\n        description: 'Restarts the wizard, allowing you to make different selections.',\n        value: 'restart'\n      },\n      {\n        displayName: 'Abort',\n        description: 'Aborts the new project wizard.',\n        value: 'abort'\n      }\n    ]);\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-aurelia-cli/node_modules/aurelia-cli/lib/workflow/activities/project-install.js":"'use strict';\nconst os = require('os');\nconst UI = require('../../ui').UI;\nconst transform = require('../../colors/transform');\nconst createLines = require('../../string').createLines;\nconst CLIOptions = require('../../cli-options').CLIOptions;\n\nmodule.exports = class {\n  static inject() { return [UI, CLIOptions]; }\n\n  constructor(ui, options) {\n    this.ui = ui;\n    this.options = options;\n  }\n\n  execute(context) {\n    let project = context.state.project;\n\n    return this.ui.question('Would you like to install the project dependencies?', [\n      {\n        displayName: 'Yes',\n        description: 'Installs all server, client and tooling dependencies needed to build the project.',\n        value: 'yes'\n      },\n      {\n        displayName: 'No',\n        description: 'Completes the new project wizard without installing dependencies.',\n        value: 'no'\n      }\n    ]).then(answer => {\n      if (answer.value === 'yes') {\n        return this.ui.log(os.EOL + 'Installing project dependencies.')\n          .then(() => project.install(this.ui))\n          .then(() => this.displayCompletionMessage(project))\n          .then(() => context.next(this.nextActivity));\n      }\n\n      return this.ui.log(os.EOL + 'Dependencies not installed.')\n        .then(() => context.next());\n    });\n  }\n\n  displayCompletionMessage(project) {\n    let notHereMessage = ` First, change directory into your new project's folder. You can use <magenta><bold>cd ${project.model.name}</bold></magenta> to get there. Once in your project folder, simply run your new app with <magenta><bold>au run</bold></magenta>.`;\n    let hereMessage = ' Simply run your new app with <magenta><bold>au run</bold></magenta>.';\n\n    let message = transform('Now it\\'s time for you to get started. It\\'s easy.' +\n    (this.options.hasFlag('here') ? hereMessage : notHereMessage) +\n    ' Your app will run fully bundled. If you would like to have it auto-refresh whenever you make changes to your HTML, JavaScript or CSS, simply use the <yellow>--watch</yellow> flag. If you want to build your app for production, run <magenta><bold>au build --env prod</bold></magenta>. That\\'s just about all there is to it. If you need help, simply run <magenta><bold>au help</bold></magenta>.');\n\n    return this.ui.clearScreen()\n      .then(() => this.ui.log(`Congratulations! Your Project \"${project.model.name}\" Has Been Created!` + os.EOL + os.EOL))\n      .then(() => this.ui.log(createLines(message, '', this.ui.getWidth())))\n      .then(() => this.ui.log(os.EOL + os.EOL + 'Happy Coding!'));\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-aurelia-cli/node_modules/aurelia-cli/lib/workflow/activities/state-assign.js":"'use strict';\n\nmodule.exports = class {\n  execute(context) {\n    Object.assign(context.state, this.state);\n    context.next(this.nextActivity);\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-aurelia-cli/node_modules/aurelia-cli/lib/commands/help/command.js":"'use strict';\nconst UI = require('../../ui').UI;\nconst CLIOptions = require('../../cli-options').CLIOptions;\nconst Optional = require('aurelia-dependency-injection').Optional;\nconst Project = require('../../project').Project;\nconst string = require('../../string');\n\nmodule.exports = class {\n  static inject() { return [CLIOptions, UI, Optional.of(Project)]; }\n\n  constructor(options, ui, project) {\n    this.options = options;\n    this.ui = ui;\n    this.project = project;\n  }\n\n  execute(args) {\n    return this.ui.displayLogo()\n      .then(() => {\n        if (this.options.runningGlobally) {\n          return this.getGlobalCommandText();\n        }\n\n        return this.getLocalCommandText();\n      }).then(text => this.ui.log(text));\n  }\n\n  getGlobalCommandText() {\n    return string.buildFromMetadata([\n      require('../new/command.json'),\n      require('./command.json')\n    ], this.ui.getWidth());\n  }\n\n  getLocalCommandText() {\n    let commands = [\n      require('../generate/command.json'),\n      require('../import/command.json'),\n      require('../install/command.json'),\n      require('./command.json')\n    ];\n\n    return this.project.getTaskMetadata().then(metadata => {\n      return string.buildFromMetadata(metadata.concat(commands), this.ui.getWidth());\n    });\n  }\n};\n"}